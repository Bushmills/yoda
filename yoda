#!/bin/bash

# ----- about -------------------------------------------- #fold00
# yoda is an acronym of Yet Onather Delirious Application, and does
# naturally not refer to any greenish midget with pointy ears, albeit
# it had been said that reading yoda source aloud sounds like the very
# same midget talking.
# yoda implements a compiler which converts a close resemblance of Forth
# source code to bash functions, an interpreter which runs them, and
# a base vocabulary of useful functions, strongly orientated towards
# what a common Forth interpreter offers.
# What learned you have, unlearn you must!

# editor used is efte, folds in source files are therefore efte compatible.

# ----- versions ----------------------------------------- #fold00
# invoke shellcheck with:    shellcheck -x yoda.
# shellcheck disable=SC2016 disable=SC2034 disable=SC2154
# SC2016: "expressions don't expand between single quotes"
#         right, that's the reason for using single quotes there.
# SC2034  "... appears unused. Verify use (or export if used externally)"
#         in most cases is "appears" the correct term.
# SC2154 "(warning): base is referenced but not assigned."
#        is assigned, but shellcheck can't see how


# times in UTC
# dates in post-gregorian Sol3
# numbers in decimal. Mostly.

v="0.7.0"
# changelog now in directory changes. Or, type "changes" in yoda
# for changes to current version.
read -ra version <<< "${v//./ }"

# ----- declarations ------------------------------------- #fold00

shopt -s extglob
shopt -u nullglob

config="yoda.conf"                                                   # name of configuration file which may override any of the below settings
declare -i break=2                                                   # break will return (0), exit (1) or execute coldvector (2)
declare -i clean=1                                                   # empty stack on error/ctrl-c
declare -i codedump=0

read -r tmp _ < <(realpath "$0")
mydir="${tmp%/*}"
doc="$mydir/doc"                                                     # documentation base directory
worddoc_prefix="word"                                                # used as part of file names, prevents files to go hidden by leading period
worddoc="$doc/words/$worddoc_prefix"                                 # directory of words documentation, also first part of word doc file name
dependencies="$mydir/dependencies"                                   # dependency file, path and name

# only first added directory - and its subdirectories -
# contain forward referencable libs.
libdirs=()                                                           # array of possible library paths
for dir in                          \
   "$mydir/lib"                     \
   "$mydir"                         \
   "/usr/local/lib/yoda"
do                                                                   # loop through directory candidates
   [[ -d "$dir" ]] && libdirs+=("$dir")                              # add directory if existing
done

nameprefix="yoda"                                                    # prefix to bash function names,  _${xt} will be appended upon header creation
xt="1000"                                                            # names enumeration, initially. Can be any positive integer

declare -ai r=() s=() m=()
declare -a strings=()                                                # string memory
declare -i sp=0 rp=0 dp=0 sdp=0
declare -a ss=()
declare -i s1 s2 s3 s4                                               # temp variables to hold stack items s[-1] ... s[-4]
                                                                     # easier to read than "tmp, tmp2"
declare -A doescode                                                  # items associated with defining word. Detokeniser extracted code

# naming:
#  wordlist:     name of a wordlist
#  wordlistwid:  wid of a wordlist
# convert wid to wordlist:   $@    ( ${strings[wid]} )
declare -a builtin_wordlists=("only" "forth" "interpretonly" "compileonly" "unresolved")
for wordlist in "${builtin_wordlists[@]}"; do
   declare -Ai "flags_$sdp"                                          # header flags per vocabulary
   declare -A  "wordlist_$sdp"                                       # this is the name of the wordlist array, named "wordlist_$wid"
   declare -n  "$wordlist"="wordlist_$sdp"                           # allow referencing builtins by name without indirection ( ${unresolved[...]} )
   ((${wordlist}wid=sdp))                                            # builtins can also be refered by wid, assigned here
   strings[sdp++]="$wordlist"                                        # finally associate wid with name.
done

declare -ai order=("$forthwid" "$onlywid")                           # only forth
declare -i  currentwid="${order[0]}"                                 # definitions

declare -n  context="wordlist_${order[0]}"                           # set pointer variables to array name of wordlists
declare -n  current="wordlist_$currentwid"
declare -n  flags="flags_$currentwid"                                # pointer var to vocabulary specific header flags

declare -a names                                                     # xt -> name
declare -a transients                                                # transient headers.
declare -A where                                                     # source location file:line
declare -A lib                                                       # dependencies cache

declare -i filehandle=1                                              # 1=yoda. 0=tty.  >1=loaded source
declare -a files=("tty")                                             # list of included files
declare -a loaded                                                    # list of inclusion counters for included files
declare -a conclude=()                                               # compiler words can add actions to array conclude, which
                                                                     # will be executed when semicolon executes
declare -a lasterror
lasterror=("" "-1" "0")

# header flags:
inline=1                                                             # inlined words compile code rather than function call.
protected=2                                                          # protect code body against trashing when set.
# detokeniser flags:
flagscount="0"
newflag()  { (( $1 = 1<<flagscount++ )); }
newflag functionheader                                               # create header
newflag sourcelocation                                               # store source location
newflag atomiccode                                                   # expand
newflag push                                                         # generate code pushing a cell
newflag call                                                         # generate code calling xt
newflag does                                                         # rip code apart into define- and run time portions

declare -A atom=()                                                   # a table with token -> code mappings.


# what to execute when no command line args given
default='from defaults'                                              # load defaults from file

# number of bits per cell.
# one address increment is always a cell, this setting
# won't change that.
declare -i bits
bits=63                                                              # Can't use 64 bit - bash doesn't know unsigned. 63 bit is best I can do for now.
#bits=48                                                              # 0...281,474,976,710,655
#bits=32                                                              # 0...4,294,967,295
#bits=21                                                              # covers 6 decimal digits signed numeric space
#bits=20                                                              # 20 bits, unusual but not impractical. 8086 address space
#bits=16                                                              # 16 bits, a tad retro
#bits=11                                                              # covers 3 decimal digits signed numeric space
#bits=8                                                               # 8 bits are nice for testing

declare -i msb="1<<(bits-1)"
declare -i maxint="msb-1"
declare -i maxuint="maxint|msb"
declare -i true="maxuint"
declare -i false=0
declare -i compiling="false"                                         # state flag: interpreting or compiling
line=""                                                              # source line being worked on. modified during parsing and processing
word=""                                                              # bl delimited string from line currently being processed
lastword=""                                                          # most recently created word, set by defining words

# xeditor runs detached from yoda process and doesn't block input
# therefore an xeditor should open its own window
editor="vi"
#xeditor="efte"
[[ -n "$editor" ]]  && editor()  { $editor "$@"; }                   # used with doc, edit
[[ -n "$xeditor" ]] && {
   editor()  { $xeditor "$@" & }                                     # used with doc, edit
   editor="$xeditor"
}

declare -i magic=100000
remagic()  { magic+=RANDOM+10000; }
remagic

declare -Ai asc=()                                                   # ascii table
declare -a char=()                                                   # character table
for i in {1..255}; do                                                # ascii->char LUT for emit, pack$, char$
   char[i]="$(echo -en "\\x$(printf "%x" "$i")")"
   ((i == 10)) || asc["${char[i]}"]="$i"                             # linefeed is invalid hash key
done

# ----- diagnostics  ------------------------------------- #fold00

declare -a comp=("" ":")

trace()  {
   printf "### %-1s %-20s %s\n" "${comp[compiling & 1]}" "[${FUNCNAME[1]}]" "$@"
#                                                  ^^^  convert any non-zero to 1, used as array index
}

pretend()         {
   echo "${FUNCNAME[1]} pretends to $*"; }                           # placeholder for use in unfinished code


# ----- headers ------------------------------------------ #fold00

#setheaderflag()  { (( flags["$lastword"] |= "$1" )); }              # a bash glitch doesn't allow me to use this form, because it produces errors with
                                                                     # some array keys like "'".
setheaderflag()  {                                                   # where against this form has no problem with those,
   flags["$lastword"]="$(( ${flags["$lastword"]} | "$1" ))"
}

inline()     { setheaderflag "$inline" ; }
protect()    { setheaderflag "$protected"; }

# move headers, along with header flags, between wordlists
# header is assumed in current vocabulary, where it was
# recently compiled into
# arg1: destination wid
towordlist()  {
   local dest destflags wid
   wid="$1"                                                          # destination wid
   declare -n dest="wordlist_$wid"                                   # set up pointers to destination wordlist
   declare -n destflags="flags_$wid"
   dest["$lastword"]="${current["$lastword"]}"                       # copy function name and header flags
   destflags["$lastword"]="${flags["$lastword"]}"
   unset -v 'current["$lastword"]'                                   # remove from source wordlist
   unset -v 'flags["$lastword"]'
}

compiled()     { towordlist "$compileonlywid"; }                     # move last header to compiler context vocabulary
interpreted()  { towordlist "$interpretonlywid"; }                   # move last header to interpreter context vocabulary

compiler_init()  {
   body=()
   analyser=()                                                       # reinitialise code tags for analyser
   target=()
}

# create header, but don't compile, and don't generate function yet.
# compiling (that is, creating a bash function) is left to
# semicolon, calling compile won't detect redefinition if word was
# moved to context vocabulary
# arg1: word name
# arg2: function name
# not allowed to generate function names because some names want
# to be determined by caller
# NOTE: leave it to header to prepend $nameprefix.
header()  {
   lastword="$1"
   [[ -z "${current["$lastword"]}" ]] ||
      echo "redefining $lastword"
   current["$lastword"]="$2"                                         # associate word with name
   flags["$lastword"]="0"                                            # default to no flags
}

# results array
declare -a exists                                                    # result array:  exists[0]=0|xt,  exists[1]=flags

# arg1:word  arg2+:wids
# returns: exists[0]=0|xt, [1]=flags,  [2]=wid where word was found
exists()  {
   local context word="$1"                                           # this is what we're looking for
   shift
   for wid in "$@"; do                                               # in these word lists
      declare -n context="wordlist_$wid"                             # make next wordlist visible
      declare -n flags="flags_$wid"
      [[ -n "${context[$word]}" ]] && {                              # word found in it?
         exists=(                                                    # yes: return xt, flags and wid as result
            "${context[$word]##*_}"
            "${flags[$word]}"
            "$wid"
            )
         return 0
      }
   done                                                              # not yet found: loop through all wids in arguments
   exists=(0)                                                        # word not found: return 0
   return 1                                                          # and indicate error
}




# ----- detokeniser / pretend optimiser ------------------ #fold00
# currently only a detokeniser. Plugged preparing further use.
# The way it works:
#    when a word gets compiled to a function, it will first be
#    cached in an array "body". semicolon then calls compile,
#    which generates a bash function from body.
#    first thing compile does is calling optimise, which visits
#    all items in body, potentially modifies or substitutes them
#    while transferring to an array named target.
#    compile then creates the bash function from target, which
#    at that point is expected to contain literal code only.
#    Compiling words which add to body array can tag entries,
#    informing optimiser/detokeniser about their nature, so it
#    can respond in an appropriate way to body array entries.


# construct function name from xt
# arg1:xt
# result: name:functionname
name()  {
   name="${nameprefix}_$1"                                           # create function name from xt as argument
}


# return a new function name in variable name
# arg1:word
# result: name:functionname
newname()  {
   names[xt]="$1"                                                    # keep word name for .name, name$
   name "$xt"
   ((xt++))
}


# arg1: code token, arg2: code token type (opt)
code()  {                                                            # instruction stream injector
   body+=("$1")
   analyser+=("${2:-0}")                                             # default to literal code
}


where()  {
   code "$1:$2" "$sourcelocation"
}

# doesn't actually do any optimizing.
# Function is limited to:
# - expanding atoms
# - generating code for pushing literals
# - generating code for function calls from xts
# - dealing with does>
# - delayed headers creation
# - storing source location
optimise()  {                                                        # run code generator on ${analyser[@]} data
   ((${#body[@]}==${#analyser[@]}))||echo "body/analyser<>1"
   target=()
   dodoes_at=0
#   corresponding=()                                                 # index array source line to target line.
   ((codedump))&& {
      echo ": $lastword"
      for ((tmp=0; tmp<${#body[@]}; tmp++)); do
         printf "%2d %-5s %s\n" "$tmp" "${analyser[tmp]}" "${body[tmp]}"
      done
      echo "------------------------------------------------"
   }
   for ((tmp=0; tmp<${#body[@]}; tmp++)); do
#      corresponding[tmp]="${#target[@]}"                            # allow optimiser to locate target code for any source line.
      bodyline="${body[tmp]}"
      bodyflag="${analyser[tmp]}"
      targetline="$bodyline"                                         # Default action: pass through
      if (( bodyflag )); then                                        # flags: examine
         if (( bodyflag & functionheader )); then                    # create header pseudo op
            word="$bodyline"                                         # word name of new word
            name="${unresolved[$word]}"                              # if forward ref, reuse function name of forward ref
            if [[ -z "$name" ]]; then
               newname "$word"                                       # not a forward ref: invent new name
            else
               unset -v "unresolved['$word']"                        # going to resolve word, remove from forward refs
            fi
            header "$word" "$name"                                   # create new header
            continue
         elif (( bodyflag & atomiccode )); then                      # atomic code: expand
            targetline="${atom[$bodyline]}"
         elif (( bodyflag & push )); then                            # generate code pushing the number
            targetline="((s[++sp]=$bodyline))"
         elif (( bodyflag & sourcelocation )); then                  # source location: set
            where["$lastword"]="$bodyline"                           # remember source location
            continue
         elif (( bodyflag & call )); then
            name "$bodyline"                                         # convert xt to function name
            targetline="$name"
         elif (( bodyflag & does )); then                            # does>
            dodoes_at="$((${#target[@]}+1))"                         # remember end of target for splitting code (but only when whole word
         fi                                                          # was compiled - we want to rip out all the run time code, after all.
      fi
      [[ -z "$targetline" ]] || target+=("$targetline")
   done
   ((dodoes_at)) && {
# in raw code was a does> encountered: split generated code in
# two parts. first part is compiled to defining word, second part
# is seperated to an array item associated with defining word.
# dodoes, when executed, knows how to retrieve and
# compile that code to defined word.
# a workaround is needed here too:  create ... does> ;   does without following code will let bash run into an empty function,
# which bash doesn't like, and complain about.  Therefore this condition is caught here and acted upon.
     if (( ${#target[@]} > dodoes_at )); then                        # everything ok: there was code between does> and ; - extract and store it.
        doescode[${current[$lastword]}]=$(printf "%s\n" "${target[@]:$dodoes_at}")
        target=("${target[@]:0:$dodoes_at}")
     else                                                            # but does> without code ...
        unset "target[-1]"                                           # will cause to compile without any does run time action. no code behind does>
     fi                                                              # would result in no action at all, therefore the whole does> can be dropped too.
   }
}

# ----- line parser -------------------------------------- #fold00

# these need extglobs, set with "shopt -s extglob"

# read space delimited word from line without removing it.
peek_word()  {
   word="${line##+([[:space:]])}"                                    # remove all leading spaces (needs extglobs)
   word="${word%%[[:space:]]*}"                                      # bl lookahead
}

# read space delimited word from line, remove it,
# remove single leading space from remainder of line.
word()  {
   peek_word
   line="${line#*"$word"}"                                           # quotes around word are needed
   line="${line#+([[:space:]])}"                                     # remove single leading space (n
}

# read string from line and remove it, also remove delimiter.
# delimiter passed as arg1.
# leading spaces aren't removed from remainder of line.
parse()  {
   word="${line%%"${1}"*}"
   [[ -z "$1" ]] && word="$line"
   line="${line#"${word}"}"
   line="${line#"$1"}"
}

# ----- compiler ----------------------------------------- #fold00


# atoms may be:
#  - micro instructions
#  - single instructions
#  - primitives
# those can describe their effects more easily to the optimiser,
# enabling it to combine and remove them to target code.
# in addition are meta directives allowed:
#  - compile time instructions for word creation, such as header building

atom()  {
   [[ -z "${atom[$1]}" ]] && error "no atomic $1"
   code "$1" "$atomiccode"; }                                        # insert into code buffer, mark as atom


codebody()  {                                                        # inline compiler
   name "$1"                                                         # xt to function name
   while read -r tmp; do
      [[ "${tmp:0:1}" == "{" ]] &&
      while read -r tmp; do
         [[ "${tmp:0:1}" == "}" ]] && break
         code "$tmp"
      done
   done < <(type "$name")
}

# rewrite run time semantics of most recently defined word
# arg1: new run time code.
use()  {
   name="${current["$lastword"]}"                                    # rewrites function "$name",
   eval "$name() { $(printf '%s\n' "$@"); }"                         # using instructions received as arguments
}

compile()  {
   optimise                                                          # rewrite ${body[@]} to ${target[@]}
   use "${target[@]}"                                                # generate function from $target[@] with name of $lastword
   compiler_init
}

# execute or compile args. Similar to invoke,
# maybe one of these can be eliminated.
stateless()   {
   if ((compiling)); then
      code "$@"
   else
      eval "$*"
   fi
}

#


# ----- defining words ----------------------------------- #fold00


push()  {                                                            # leave it to detokeniser to generate code
   code "$1"   "$push"                                               # only insert value or expression, mark it.
}



# compile a call to function associated with word arg1
# arg1:word
call()  {
   local word
   for word in "$@"; do
      exists "$word" "${order[@]}" || notfound "$word"
      code "${exists[0]}"  "$call"
   done
}

# variable last doesn't exist yet, but is used in header, and
# can't be defined earlier, because defining it calls header.
# remedy: remember here, allot cell, define it as constant later.
#((last=dp++))

# arg1: wordname
# arg2: filehandle
# arg3: line number
delayheader()  {
   lastword="$1"
   [[ -z "$lastword" ]] && emptyname
   compiler_init
   code "$lastword" "$functionheader"
   [[ -z "$2" ]] || where "$2" "$3"
}

nowheader()  {
   delayheader "$1" "$2" "$3"
   optimise
}


# primitive "wordname"  "functionname|code"
primitive()  {
   nowheader "$1" "$filehandle" "${BASH_LINENO[0]}"
   use "$2"
   inline
}

colon()  {
   tmp="${BASH_LINENO[0]}"                                           # assume not evaluate
   (( filehandle == 1 )) &&                                          # if defined in yoda
   [[ "${FUNCNAME[2]}" == "evaluate" ]] &&                           # by evaluate
   tmp="${BASH_LINENO[2]}"                                           # then take line number from different entry
   delayheader "$1" "$filehandle" "${linenr:-$tmp}"
}

# arg1: add action for semicolon to execute to conclude[@]
conclude()  { conclude+=("$@"); }

semicolon()  {
   for ((nextconclude=0; nextconclude<${#conclude[@]};nextconclude++)); do
      eval "${conclude[nextconclude]}"
   done
   conclude=()
   compile                                                           # compilation is gathered in an array body. Only
   compiling="$false"                                                # when semicolon completes compilation, is
}                                                                    # a function created from contents of array.


constant()  {
   delayheader "$1" "$filehandle" "${linenr:-${BASH_LINENO[0]}}"
   push "$2"
   semicolon
   inline
}


# arg1=name  arg2=val
# initialized with 0 or optional arg2
variable()  {
   (( "$1"="$dp" ))
   m[dp]="${2:-0}"
   delayheader "$1" "$filehandle" "${linenr:-${BASH_LINENO[0]}}"
   push "$((dp++))"
   semicolon
   inline
}


variable 'shell'              "0"
variable 'forwardrefs'        "0"
variable 'instantresolve'     "1"
variable 'callstack'          "0"
variable 'base'               "10"

constant 'maxuint'            "$maxuint"
constant 'maxint'             "$maxint"
constant 'msb'                "$msb"
constant 'true'               "$true"
constant 'false'              "false"
constant '0'                  "0"
constant 'esc'                "27"
constant 'bl'                 "32"
constant 'bits'               "$bits"



# arg1: deferred word
# arg2: initially deferred to, word name
# example:  defer 'foo'  'bar'
# NOTE: be aware of possibility to defer an inlined word, then
# trash header of inlined word. trashing function body in that
# situation will leave the deferred word with a dangling xt.
# thought of: "protected" header flag which disables trashing,
# set by is, noname, possibly xt,
defer()  {                                                           # use in yoda source
   local context
   delayheader "$1" "$filehandle" "${linenr:-${BASH_LINENO[0]}}"
   push "$((dp))"
   semicolon
# NOTE: instead of use, code could be compiled through "code", then leaving it to above semicolon to create whole word
   name "\${m[$dp]}"                                                 # convert xt to function name
   use "$name"
# NOTE: may have to look through all wordlists in order
# postponed because this needs some attention anyway.
   declare -n context="wordlist_${order[0]}"
   ((m[dp++]="${context[$2]##*_}"))                                  # extract and comma xt from function
   inline
}



# ----- errors, traps, entry points----------------------- #fold00

warm()  {
   filehandle=0                                                      # 1=yoda. 0=tty.  >1=loaded source
   line=""                                                           # signal to evaluate to stop evaluation of current line
   linenr="-1"                                                       # signal to from to stop sending more lines to evaluate
   compiling="$false"                                                # interpret
   error=0
   r=() rp=0
   ((sp<0)) &&s=() sp=0                                              # always clear stack underflow
   ((clean))&&s=() sp=0 ss=()                                        # empty stacks
   m[base]="10"                                                      # set decimal if base exists
   compiler_init
}

coldvector=""                                                        # colon word "boot" assigns coldvector. started when compilation completed.
cold()  {                                                            # also by running cold. error restarts interpreter at cold
   [[ -z "$coldvector" ]] && exit 1
   warm
   $coldvector
}

callstack()  {
   printf "%s: " "Call stack"
   printf "%s " "${FUNCNAME[@]:5:${m[callstack]}}"                   # remove callstack and error from output
   printf "\n"
}


read -r redbg  < <(tput setab 1)
read -r normal < <(tput sgr0)

error()  {
#           >--<                                             >----<      error word
   printf "%s%s %s\n" "${tib%"${word}"*"${line}"}" "${redbg}${word}${normal}" "$line"
   printf 'ERROR: %s\n' "$@"
   row=$((${#tib}-${#line}-${#word}))
# NOTE: passing file name in lasterror - could pass file handle instead
   lasterror=("$file" "$linenr" "$row")
   (( linenr < 0 )) || printf "at %s of %s\n" "$linenr,$row" "$file"
   ((m[callstack]))&&callstack
   cold
}

declare -a errortext
declare -i nexterror=0

errornr()   {
   error="$1"
   shift
   error "${errortext[error]} $*"
}

# a somewhat wild construct, sort of attempting
# to emulate Forth's create ... does> here. I'm
# surprised that shellcheck finds this acceptable
newerror() {
   (( "$1"=nexterror ))                                              # assign new error number to error name
   eval "$1()  { errornr \"$1\" "\"\$*"\"; }"                        # synthesise error function with error name
   shift
   errortext[nexterror++]="$*"                                       # associate error message with error number
}

newerror "noerror"         "no error"
newerror "emptyname"       "no or empty name"
newerror "stackunderflow"  "stack underflow"
newerror "notfound"        "not found:"
newerror "nosource"        "no source for"
newerror "stillcompiling"  "still compiling after"
newerror "unbalancedstack" "unbalanced stack in file"
newerror "unstructured"    "unstructured: missing"
newerror "shellerror"      "shell returned"
newerror "filenotfound"    "file not found:"


ctrl-c()  {                                                          # "break" is configurable item to control
   printf "%s\n" "break"                                             # how yoda responds to break signal.
   ((break == 1))  && exit 1                                         # This is due to not having a clean
   ((m[callstack]))&& callstack                                      # warm start procedure.
   ((break == 2))  && cold
}
trap ctrl-c SIGINT

#err()  { echo "error trap:  $word ${FUNCNAME[1]}"; }
# trap err ERR
# ----- patterns ----------------------------------------- #fold00

# wondering whether a case statement would make this look any better
declare -A bases=(['%']=2 ['#']=10 ['$']=16)
pattern()  {                                                         # pattern interpreted as
   ((radix=m[base]))
   tmp="0123456789abcdefghijklmnopqrstuvwxyz"                        # cut legal chars for base
   [[ $word =~ ^[${tmp:0:$radix}]+$ ]] && {                          # 1234      unsigned number
      stateless "((s[++sp]=$((${radix}#${word}&true))))"             # convert signless numbers without special treatment
      return 0; }
   [[ $word =~ ^-[${tmp:0:$radix}]+$ ]] && {                         # -1234     negative number
      stateless "((s[++sp]=$((-${radix}#${word:1}&true))))"
      return 0; }
   [[ ${word:0:1} == [%\$\#] ]] && {
      radix="${bases[${word:0:1}]}"                                  # yes: read radix associated with char
      [[ ${word:1} =~ ^[${tmp:0:$radix}]+$ ]] && {                   # remainder of number all legal chars?
         stateless "((s[++sp]=$((${radix}#${word:1}&true))))"        # yes: convert from base and deal with it
         return 0; }; }
   [[ ${word} == \'? || ${word} == \'?\' ]] && {                     # 'X bzw 'X' return ASCII - easier on editor syntax highlighting
      read -r tmp < <(printf "%d" "'${word:1:1}'")
      stateless "s[++sp]=\"$tmp\""; return 0; }
   [[ ${word} == ^[a-zA-Z\[] ]] && {                                 # ^X        return control char
      read -r tmp < <(printf "%d" "'${word:1:1}")
      stateless "s[++sp]=\"$((tmp&31))\""; return 0; }
   [[ "${word:0:1}${word:0-1}" == '""' ]] && {                       # quoted string, single word
      (( ${#word} > 1 )) &&  {                                       # prevent false matches with leading spaces where a single " is both 0:1 and 0-1
         ((compiling)) && {                                          # arg for compile differs with quoting, to make strings like $1 $2  literal
            code  "ss+=('${word:1:${#word}-2}')"                     # But variable expansion take place in interpreted branch.
            return 0; }                                              # Both requirements are hard to formulate in one common version.
         ss+=("${word:1:${#word}-2}")
         return 0; }; }
   [[ "${word:0:2}" == '#!' ]] && {                                  # #!        ignore hashbang
      line=""; return 0; }                                           # only relevant when loading hashbang file with from. OS doesn't pass hashbang line
   [[ "${word:0:1}" == \" ]] && {                                    # quoted string, multiple words (single words already dealt with)
      tmp="${word:1}"                                                # strip leading " from first word
      parse '"'                                                      # parse rest of line for closing quotes
         ((compiling)) && {
            code "ss+=('$tmp $word')"                                # compile: compile code to add string to string stack
            return 0; }
         ss+=("$tmp $word")                                          # interpret push string to string stack
         return 0; }
   [[ "${word:0:1}" == '>' ]] && {                                   # >foo...                   execute a shell command
      tmp="${word:1}"                                                # >foo... ->  foo...
      if [[ ${tmp:0-1} == ";" ]]; then                               # semicolon attached to command
         tmp="${tmp%;}"                                              # foo; -> foo
      elif [[ "$line" == *';'* ]]; then                              # semicolon space seperated from command
         parse ';'                                                   # parse input until ;
         tmp+=" $word"
      else                                                           # no semicolon at all
         tmp+=" $line"
         line=""                                                     # and removed from further evaluation
      fi
      stateless "$tmp"                                               # execute or compile the parsed shell command
      return 0; }
   return 1
}


# ----- resolve forward refs ----------------------------- #fold00

# total headers count is used to help determining if resolving
# forward refs create new forward refs, in which case resolving
# will be repeated.
totalheaders()  {
# NOTE: change to take account of all vocabularies
   (( totalheaders =
         ${#current[@]}
       + ${#compileonly[@]}
       + ${#interpretonly[@]}
       + ${#unresolved[@]}
   ))
}


# create a forward ref by the name of arg1
forwardref()  {
   [[ -z ${unresolved["$word"]} ]] && {                              # don't re-forwardref and already forward ref'ed word
      newname "$1"                                                   # generate new function name
      unresolved["$1"]="$name"                                       # keep in unresolved vocabulary
   }
}


# satisfy one single reference, passed as arg1.
# tries by loading source immediately if available.
# if source isn't available, a forward ref will be generated.
satisfy1()  {
   exists "$1" "${order[@]}" && return 0                             # word already defined, nothing to do
   local word="$1"
   [[ -z "${lib[$word]}" ]] || {                                     # library of needed word known?
      forwardref "$word"                                             # yes: create forward ref only
      ((${#body[@]})) && return 1                                    #   refuse to satisfy while building new word is in progress
      tmp="${libdirs[0]}/${lib["$word"]}"                            #   path and name of lib file
      [[ -f "$tmp" ]] && from "$tmp"                                 #   load if file exists
      return 0
   }
   return 1
}

resolving=0                                                          # early termination helper
# looping resolve until header count stabilised.
# doing so because resolving forward references may create
# new forward references, which also need resolving.
resolve()  {
   (( ${#unresolved[@]} )) || return                                 # only run if unresolved words exist
   ((resolving)) && return                                           # nesting into resolve doesn't get any more work done -
   local file                                                        #   we'll resolve anything open, or we don't, no matter
   local resolving=1                                                 #   how often resolve calls itself. This would only slow down
   previousheaders="-1"
   totalheaders                                                      # total headers count before inclusion
   until (( totalheaders == previousheaders )); do                   # loop until header count stabilises
      previousheaders="$totalheaders"
      for word in "${!unresolved[@]}"; do                            # try to resolve all in unresolved vocabulary
         satisfy1 "$word"                                            # satisfying a word can create new forward references
      done
      ((${#unresolved[@]})) || break                                 # no forwardrefs left: done
      totalheaders                                                   # total headers count now, after inclusion
   done
}


# ----- line interpreter, evaluate------------------------ #fold00

# text compiler and interpreter, the so-called outer interpreter

# interpret/compile the line passed as argument
# in here most compiling and interpreting work is done.
# time to split this thing up, as it's getting a tad unwieldy
evaluate()  {
   local line="$*"                                                   # line may get modified, and that must be. some words depend on being able to change it,
   local tib="$line"                                                 # tib remains unaffected unless explicitely modified (query et al), for error reporting.
   while [[ -n "$line" ]]; do                                        # still more to process on line (parsing removes strings from line)
      ((error | (sp<0)))&&break
      word                                                           # parse white space delimited word
      [[ -z "$word" ]] && continue                                   # empty: tabs, line end, nothing of substance
# --- search word in order ---
      exists "$word" "${order[@]}" && {                              # stateless word found?
         tmp="${exists[0]}"
         ((compiling)) && {
            ((exists[1]&inline)) && {
               codebody "$tmp"                                       # inline: compile function body
               continue
            }
            code "$tmp" "$call"                                      # not inline: compile call to function
            continue
         }
         name "$tmp"                                                 # not compiling: convert xt to function name
         $name                                                       # execute function
         continue                                                    # done processing this word
      }
# --- word not found ---
      if ((compiling)); then                                         # word wasn't found. search state specific vocabularies
         [[ -z "${compileonly["$word"]}" ]] || {                     # found in in compileonly while compiling
            ${compileonly["$word"]}                                  # word in there are inherently "immediate", therefore they're executed here
            continue                                                 #     because that also deals with inline compilation.
         }
         [[ -z "${unresolved["$word"]}" ]] || {                      # found in unresolved while compiling
            code "${unresolved[$word]}"                              # compile it
            continue
         }
      else                                                           # interpreting
         [[ -z "${interpretonly["$word"]}" ]] || {                   # word found in interpretonly
            ${interpretonly["$word"]}
            continue
         }
      fi
# --- words isn't interpret or compile only
      pattern "$word" && continue                                    # not found yet: try patterns (numbers, strings, chars, hashbang, shell commands)
      (( m[forwardrefs] )) && {                                      #     and forward references enabled ...
         ((compiling)) && {                                          # still not successfully dealt with word. last resolve: in case of compiling ...
            forwardref "$word"  "$lastword"                          #     create a forward reference.
            code "${unresolved["$word"]}"                            #     compile dangling call to unresolved name. (tag as forward ref call for optimiser?)
            continue                                                 # hope that it will eventually get resolved
         }
      }
      (( m[instantresolve] && ! compiling)) && {                     # interpret time forward references enables?
         satisfy1 "$word" && {                                       # attempt to load word
            ${current["$word"]}                                      # successful: execute
            continue
         }
      }
      ((m[shell])) && {                                              # done unless shell flag was set
         stateless "${word} ${line}" ||                              # in which case execution as shell command is attempted (cmd not found returns 127)
         shellerror "$?"                                             # non-zero exit values of shell commands will be passed on to yoda error handler
         line=""                                                     # assignment sets return value to 0
         continue
      }
      notfound "$word"                                               # nothing helped. get grouchy.
      line=""                                                        # stop evaluation: nothing left
   done
   ((sp<0))&&stackunderflow
}

# evaluate block of hi-level source code
include()  {
   while read -r lineofsource; do
      evaluate "$lineofsource"
   done
}


# ----- load source files -------------------------------- #fold00

# return filehandle pointing to matching file in array files,
# or to end of array where new file will be added if no
# matching file was found. Also return a return values (1)
# if not loaded, return 0 when loaded.
# (seems twisted but allows condition  "if loaded; then ..."

# return filehandle as result, and return value
# indicating first time load or reload
# arg1: file name (fully qualified)
loaded()  {
   local file="$1"
   for ((filehandle=1; filehandle<${#files[@]}; filehandle++)); do   # while multiple inclusion is allowed, those files won't be recorded multiple times
      [[ "${files[filehandle]}" == "$file" ]] && break               # so when already recorded, break out
   done
   return $(( filehandle >= ${#files[@]}))
}


# arg1: wid
# arg2: any for alternative set of options
set-current()  {
   currentwid="$1"
   declare -gn current="wordlist_$currentwid"
   declare -gn flags="flags_$currentwid"
}


# trashed name as argument
# expects word in current
# ( -- )
trash()  {
   local current flags
# seems that by using local current, option -g with
# declare will not address the proper set of arrays,
# but can't use set-current without -g
   declare -n current="wordlist_$currentwid"
   declare -n flags="flags_$currentwid"
#   set-current "$currentwid" "n"

   tmp="${flags[$1]}"
#   trace "$1 flags:$tmp"
   (((tmp&inline) && (!(tmp&protected)))) && {
#      trace "trashing code of $1"
      unset -f "${current[$1]}"
   }
#   trace "trashing flag&header of $1 in wid $currentwid"
   unset -v "current[$1]"
   unset -v "flags[$1]"
}


# trash transient headers
notransients()  {
   ((${#transients[@]})) && {                                        # only if any transients exist at all
      local current flags currentwid wid transient word
      currentwid="-1"                                                # make sure current will be declared, because local variables
      for transient in "${transients[@]}"; do
         wid="${transient%% *}"                                      # wid of transient
         word="${transient##* }"                                     # transient word
         ((currentwid == wid)) || set-current "$wid"                 # must change wids
         trash "$word"                                               # remove header
      done                                                           # repeat for all headers in list of transients
   }
}

# nestable source include
# this from differs from the colon word, as it doesn't
# try the different ${libdirs[@}} directories.
# file, possible with path, must exist, or no go.
# Callers did a check prior to calling.
from()  {
   [[ -z "$1" ]] && return 2                                         # no file
   local line lines linenr file filehandle word                      # must protect for nested includes.
   local stackeffect="$sp"                                           # included files must have net stack effect of 0
   file=""
   if [[ "$1" == */* ]]; then                                        # file contains slash(es): don't search
      file="$1"
   else
      for dir in "${libdirs[@]}"; do
         [[ -f "$dir/$1" ]] && { file="$dir/$1"; break; }            # search through lib dirs, break when/if found
      done
   fi
   [[ -f "$file" ]] || return 1                                      # file not found
   file="$(realpath "$file")"                                        # canonical or original name of file
   loaded "$file" || files[filehandle]="$file"                       # first time inclusion: add to files array
   readarray -t lines < "$file"                                      # read whole file into lines array
   local transients=()                                               # list of headers marked transient
   for ((linenr=0; linenr<${#lines[@]};)); do                        # looping through line number, not through lines so that
      line="${lines[linenr++]}"                                      #   source can change line numbers for jumping
      evaluate "$line"                                               # process next line
      ((error | (linenr < 0)))&&break                                # source can flag "stop loading" with negative linenr
   done                                                              #   (warm and done do so)
   notransients                                                      # trash transient headers
   ((compiling)) && stillcompiling "$1"                              # can't have that, files leaving a dangling compiler
   ((stackeffect == sp)) || unbalancedstack "$1"                     # demanding stack clean files with net effect zero.
   ((loaded[filehandle]++))                                          # increment load counter, mark as loaded
   return 0
}


# ----- populating detokeniser --------------------------- #fold00
# for testing, a handful of inlined single operation primitives
# and atomic operations are added. no optimising take place now.
# atoms are only substituted against corresponding code.
# atoms are tagged as such in the source, some correspond to
# names of primitives. This is meant for having the optimiser
# hooked into code generation, for doing some more substantial
# work later on. chosing these operations allows tracking of
# recent use of stack items and registers, for static elimination
# of redundant operations.

atom["dup"]='((s[++sp]=s[sp]))'
atom["over"]='((s[++sp]=s[sp-1]))'
atom["pluck"]='((s[++sp]=s[sp-2]))'
atom["drop"]='((sp--))'
atom["@"]='((s[sp]=m[s[sp]]))'
atom["1+"]='((s[sp]=(s[sp]+1)&true))'
atom["1-"]='((s[sp]=(s[sp]-1)&true))'
atom["2*"]='((s[sp]=(s[sp]<<1)&true))'

atom["negate"]='((s[sp]=(-s[sp]&true)))'
atom["invert"]='((s[sp]^=maxuint))'

atom["s1"]='((s1=s[sp]))'
atom["s2"]='((s2=s[sp-1]))'
atom["s3"]='((s3=s[sp-2]))'
atom["s4"]='((s4=s[sp-3]))'

atom["s1=tmp"]='((s[sp]=tmp))'
atom["s2=tmp"]='((s[sp-1]=tmp))'
atom["s3=tmp"]='((s[sp-2]=tmp))'
atom["s4=tmp"]='((s[sp-3]=tmp))'
atom["tmp=s1"]='((tmp=s[sp-0]))'
atom["tmp=s2"]='((tmp=s[sp-1]))'
atom["tmp=s3"]='((tmp=s[sp-2]))'
atom["tmp=s4"]='((tmp=s[sp-3]))'

atom["s1=s2"]='((s[sp]=s[sp-1]))'
atom["s1=s3"]='((s[sp]=s[sp-2]))'
atom["s2=s1"]='((s[sp-1]=s[sp]))'
atom["s2=s3"]='((s[sp-1]=s[sp-2]))'
atom["s3=s1"]='((s[sp-2]=s[sp]))'
atom["s3=s2"]='((s[sp-2]=s[sp-1]))'
atom["s4=s1"]='((s[sp-3]=s[sp]))'
atom["s4=s2"]='((s[sp-3]=s[sp-1]))'
atom["s4=s3"]='((s[sp-3]=s[sp-2]))'

atom["r@"]='((s[++sp]=r[rp]))'
atom['>r']='((r[++rp]=s[sp--]))'
atom['r>']='((s[++sp]=r[rp--]))'
atom['rdrop']='((r--))'

atom["allot"]='((dp+=s[sp--]))'
atom["here"]='((s[++sp]=dp))'



# ----- primitives --------------------------------------- #fold00
# ----- colon/semicolon ---------------------------------- #fold01

colon ';'
   code "(( s[sp--] == $magic )) || { unstructured ':'; return; }"   # check the magic left by :
   code '(( ${s[sp--]} == ${#body[@]} )) && code "(())"'             # insert a noop into empty function bodies
   code 'semicolon'                                                  # compile $lastword from $body[@], resume interpreting
semicolon
compiled


colon ':'
   code 'word'                                                       # parse space delimited word from input stream
   code 'colon "$word"'                                              # generate synthetic name, associate with word
   push '${#body[@]}'                                                # allow check of empty function
   push "$magic"                                                     # allow check of proper nesting
   code '((compiling=true))'
semicolon
# ----------------------------------------------

primitive 'interpreted' 'interpreted'                                # move header to interpreter context vocabulary.
primitive 'compiled'    'compiled'                                   # move header to compiler context vocabulary.

colon 'transient'
   code 'transients+=("$currentwid $lastword")'                      # copy header to transients for later trashing.
semicolon

colon 'inline'
   code 'inline'                                                     # don't compile call, instead compile body code.
semicolon

primitive 'protect'  'protect'                                       # protect code body against trashing.

colon 'vocs'
   code 'echo "currentwid=$currentwid, ${strings[currentwid]}"'
   code 'echo "${flags[@]}"'
   code 'echo "${!flags[@]}"'
   code 'echo "${current[@]}"'
   code 'echo "${!current[@]}"'
semicolon

# ----- diagnostics -------------------------------------- #fold01

words() {
   local context
   declare -n context="wordlist_${order[0]}"
   (( ${#context[@]} )) && {
      printf  "%s  " "${!context[@]}"
      printf "\n"
   }
}

wordsplus() {
   local context wid
   for wid in "${order[@]}" "$interpretonlywid" "$compileonlywid" "$unresolvedwid"; do
      wordlist="wordlist_$wid"
      declare -n context="$wordlist"
      (( ${#context[@]} )) && {
         printf '%s\n' "--- ${strings[$wid]} ---"
         printf  "%s  " "${!context[@]}"
         printf "\n\n"
      }
   done
}



see()  {
   local context wid
   word
   for wid in "${order[@]}" "$interpretonlywid" "$compileonlywid"; do
      wordlist="wordlist_$wid"
      declare -n context="$wordlist"
      [[ -z "${context["$word"]}" ]] || {
         printf "found in %s:\n" "${strings[wid]}"
         tmp="${context["$word"]}"
         [[ -z "$tmp" ]] && notfound
         type "$tmp"
      }
   done
}

# see word  "decompiles" and shows word.
primitive 'see' 'see'


# ----- does> -------------------------------------------- #fold01

# compiled to the end of a defining word,
# is therefore called by create part, and
# will consequently know who its caller is
# (function name).  Will also know, by virtue
# of $lastword, what function to add code to.
# (or rather, instruct detokeniser to add code
# to). Appends all defining word associated code
# portion of does> to the original address push
# compiled by create.
dodoes()  {                                                          # append does> part to original address pushing create semantics
   ${current[$lastword]}
   use  "s[++sp]=\"${s[sp--]}\"
         ${doescode[${FUNCNAME[1]}]}"
}

# detokeniser detects and reacts to this "$does" tagged code:
# code after does> is removed from defining word and written to
# an array item associated with it.
# dodoes then uses that code to rewrite run time semantics of
# defined word.
# Though somewhat Rube-Goldbergish, it's simpler than the other
# approaches I was thinking of.
primitive 'does>'  'code "dodoes" "$does"';   compiled




# ----- defining words ----------------------------------- #fold01

# essentially a constant with yet to be specified source for its
# value and overwritable run time semantics (push value by default)
definess()  {
   code "constant \"\${ss[-1]}\" \"$1\""                             # not using single quotes because want $1 to expand
   code 'unset "ss[-1]"'
}

define()  {
   code 'word'
   code "constant \"\$word\" \"$1\""                                 # not using single quotes because want $1 to expand
}


colon 'create$'
    definess '$dp'
semicolon

colon 'create'
    define '$dp'
semicolon

colon 'constant'
   define '${s[sp--]}'
semicolon

colon 'constant$'
   definess '${s[sp--]}'
semicolon

colon 'variable'
   define '$((dp))'
   code '((m[dp++]=0))'                                              # allocate and initialise
semicolon

colon 'variable$'
   definess '$((dp))'
   code '((m[dp++]=0))'                                              # allocate and initialise
semicolon

colon "array"
   define ''                                                         # value irrelevant, use will replace code anyway
   code 'use "((s[sp]+=$dp))"'                                       # set run time semantics
   code "((dp+=s[sp--]))"                                            # allocate
semicolon

colon "array$"
   definess ''                                                       # value irrelevant
   code 'use "((s[sp]+=$dp))"'                                       # set run time semantics
   code "((dp+=s[sp--]))"                                            # allocate
semicolon



# NOTE: factor code common with header
# ' foo alias bar
colon 'alias'
   define ''                                                         # value irrelevant, will point to different function anyway
   code 'name "${s[sp--]}"'                                          # convert xt to function name
   code 'current["$word"]="$name"'
   code 'where["$lastword"]="${filehandle}:${linenr:-${BASH_LINENO[2]}}"'
semicolon


# ----- deferred words ----------------------------------- #fold01

# new deferred words are initialised to noop
primitive 'noop' '(())'

# example:  defer foo      ' bar is foo
colon "defer"                                                        # use in yoda program
   code 'word'
   code 'defer "$word" "noop"'
semicolon


# here's another Rube Goldberg. This works around the fact that
# there's no easy way for yoda to determine the memory address
# where a deferred word stores the xt of the word it executes.
# therefore, is decompiles the deferred word, then extracts the
# address from the line where the deferred word fetches the xt
# from memory. sed could do that more easily, but isn't currently
# an already existing dependency, contrary to grep, which is why
# grep is used here.
colon 'is'
   code 'word'
   code 'tmp="$(type "${current[$word]}"|grep "${nameprefix}_.*m\[")"'
   code 'm["${tmp//[!0-9]/}"]="${s[sp--]}"'
semicolon


# ----- commenting --------------------------------------- #fold01

primitive "\\"   'line=""';   compiled                               # single quoted single backslash because
primitive "\\"   'line=""';   interpreted                            # double quoted escaped backslash rather than
                                                                     # efte syntax highlighting gets confused
primitive '('    "parse ')'"; compiled
primitive '('    "parse ')'"; interpreted


# ----- parameter stack ---------------------------------- #fold01


colon 'dup'
   atom 'dup'
semicolon
inline

colon 'drop'
   atom 'drop'
semicolon
inline

colon 'over'
   atom 'over'
semicolon
inline

colon 'pluck'
   atom 'pluck'
semicolon
inline

colon '2dup'
   atom 'over'
   atom 'over'
semicolon
inline

primitive '2drop' '((sp-=2))';

colon '2over'
   push 's[sp-3]'
   push 's[sp-3]'
semicolon
inline

colon 'swap'
   atom 'tmp=s2'
   atom 's2=s1'
   atom 's1=tmp'
semicolon
inline

colon '2swap'
   atom 'tmp=s4'
   atom 's4=s2'
   atom 's2=tmp'
   atom 'tmp=s3'
   atom 's3=s1'
   atom 's1=tmp'
semicolon

colon 'nip'
   atom 's2=s1'
   atom 'drop'
semicolon
inline

colon 'tuck'
   atom 'dup'
   atom 's2=s3'
   atom 's3=s1'
semicolon
inline

colon 'rot'
   atom 'tmp=s1'
   atom 's1=s3'
   atom 's3=s2'
   atom 's2=tmp'
semicolon
inline

colon '-rot'
   atom 'tmp=s1'
   atom 's1=s2'
   atom 's2=s3'
   atom 's3=tmp'
semicolon
inline

colon '?dup'
   code '((s[sp])) &&'
   atom 'dup'
semicolon
inline

# ----- return stack ------------------------------------- #fold01

colon 'r@'
   atom 'r@'
semicolon
inline

colon 'rdrop'
   atom 'rdrop'
semicolon
inline

colon '>r'
   atom '>r'
semicolon
inline

colon 'r>'
   atom 'r>'
semicolon
inline

# ( x1 x2 -- )  ( return: -- x1 x2 )
colon '2>r'
   code '((r[++rp]=s[sp-1]))'
   code '((r[++rp]=s[sp--]))'
   atom 'drop'
semicolon
inline

# ( -- x1 x2 )  ( return: x1 x2 -- )
colon '2r>'
   push 'r[rp-1]'
   push 'r[rp--]'
   code '((rp--))'
semicolon
inline


# ----- numeric comparison ------------------------------- #fold01

primitive '0='   '((s[sp]=s[sp]?false:true))'                        # 0->true  x->false
primitive '0<>'  '((s[sp]=s[sp]?true:false))'                        # 0->0   x->true
primitive '0<'   '((s[sp]=s[sp]&msb?true:false))'                    # &msb: 0->0   msb->true

colon '='
   code '((s1=s[sp--]))'
   code '((s[sp]=(s[sp])==(s1)?true:false))'
semicolon
inline

colon '<>'
   code '((s1=s[sp--]))'
   code '((s[sp]=(s[sp])==(s1)?false:true))'
semicolon
inline

colon 'u<'
   code '((s1=s[sp--]&true))'
   code '((s[sp]=(s[sp]&true)<(s1)?true:false))'
semicolon
inline

colon 'u>'
   code '((s1=s[sp--]&true))'
   code '((s[sp]=(s[sp]&true)>(s1)?true:false))'
semicolon
inline

colon '<'
   code '((s1=s[sp--]&true))'
   code '((sign=((s1^s[sp])&msb)?1:0))'                              # set bit 0 if signs differ
   code '((s[sp]=((s1>s[sp]&true)^sign)?true:false))'
semicolon
inline

colon '>'
   code '((s1=s[sp--]&true))'
   code '((sign=((s1^s[sp])&msb)?1:0))'                              # set bit 0 if signs differ
   code '((s[sp]=((s1<s[sp]&true)^sign)?true:false))'
semicolon
inline

#    flag
#   s2 < s1        sign           result
#   0 (true)       0   (same)     true
#   1 (false)      0   (same)     false
#   0 (true)       msb (diff)     false
#   1 (false)      msb (diff)     true

#  flag  sign      result
#  0     0         true
#  1     0         false
#  0     $xxx1     false
#  1     $xxx1     true

# ( x1 x2 x3 x4 -- 0 | -1 )
colon 'd='
   code '((s1=s[sp--]))'
   code '((s2=s[sp--]))'
   code '((s3=s[sp--]))'
   code '((s[sp]=(s1==s3&s2==s[sp])?true:false))'
semicolon
inline


# ----- line i/o ----------------------------------------- #fold01


# parse input for string delimited by character specified by ASCII value on stack
colon 'parse$'
   code 'parse "${char[s[sp--]]}"'
   code 'ss+=("$word")'
semicolon


# read line, push to string stack
# TODO: configurable attributes
keybuf=""

colon 'simplequery$'
   code 'ss+=("")'
   code 'IFS="" read -er -i "$keybuf" "ss[-1]"'                      # key? may have put chars into keybuf
   code 'keybuf=""'
semicolon


colon 'evaluate$'
   code 'local tib="${ss[-1]}"'
   code 'unset "ss[-1]"'
   code 'evaluate "$tib"'
semicolon
inline


# ----- compiler, dictionary search related -------------- #fold01

primitive '[' '((compiling=false))'; compiled
primitive ']' '((compiling=true))'

# ( -- ) ( $1 -- )
colon 'push$'
   code 'code "((s[++sp]=${ss[-1]}))"'
   code 'unset "ss[-1]"'
semicolon
compiled

primitive 'compile,' "code \"code \${s[sp--]}\" \"$call\""           # ( xt -- )
primitive 'literal,' "push \"\${s[sp--]}\""                          # ( x -- )


# ( compile: $1 -- ) ( run: -- $1 )
colon 'literal$'
   code 'code "ss+=(\"${ss[-1]}\")"'
   code 'unset "ss[-1]"'
semicolon
compiled


colon "'"                                                            # ( -- xt ) ( stream: word )
   code 'word'
   code 'exists "$word" "${order[@]}" "$interpretonlywid" "$compileonlywid" || notfound "$word"'
   push 'exists[0]'
semicolon

                                                                     # similar to find, but name from string stack rather than input stream
colon 'have$'                                                        # ( -- 0|xt ) ( $1 -- )
   code 'exists "${ss[-1]}" "${order[@]}" "$interpretonlywid" "$compileonlywid"'
   code 'unset "ss[-1]"'
   push 'exists[0]'
semicolon

# ' word  "signalname"  trap
colon 'trap'
    code 'name "${s[sp--]}"'                                         # convert xt to function name
    code 'trap "$name" "${ss[-1]}"'
    code 'unset "ss[-1]"'
semicolon

primitive 'execute' "${nameprefix}_\${s[sp--]}"                      # ( xt -- )
primitive 'name$'   'ss+=("${names[s[sp--]]}")'                      # ( xt -- ) ( string: -- $1 )
primitive '.name'   'printf "%s" "${names[s[sp--]]}"'                # ( xt -- )

primitive 'resolve' 'resolve'                                        # ( -- )    attempt to resolve forward references
primitive '.unresolved'  '((${#unresolved[@]}))&&printf "%s " "${!unresolved[@]}"'   # print unresolved
primitive 'recurse' 'code "$xt" "$call"'; compiled                   # ( -- )


# apply run time semantic from string stack
colon 'use$'
   code 'use "${ss[-1]}"'
   code 'unset "ss[-1]"'
semicolon

# trashed name from input stream
# ( -- )
colon 'trash'
   code 'word'
   code 'trash "$word"'
semicolon

# trashed name from string stack
# word expected in current vocabulary
# ( -- )  ( $1 -- )
colon 'trash$'
   code 'trash "${ss[-1]}"'
   code 'unset "ss[-1]"'
semicolon

# name of last word to string stack
# ( -- $1 )
primitive 'last$'   'ss+=("$lastword")'


#find$
#( -- 0 | xt 1 | xt -1 )   ( $1 -- $1 | )

#FIND
#( c-addr -- c-addr 0 | xt 1 | xt -1 )

#Find the definition named in the counted string at c-addr.
#If the definition is not found, return c-addr and zero.
#If the definition is found, return its execution token xt.
#If the definition is immediate, also return one (1),
#otherwise also return minus-one (-1).
#For a given string, the values returned by FIND while compiling
#may differ from those returned while not compiling.




# ----- bit logic ---------------------------------------- #fold01

colon    'invert';  atom 'invert'; semicolon; inline
primitive 'and'     '((s[sp-1]&=s[sp--]))'
primitive 'or'      '((s[sp-1]|=s[sp--]))'
primitive 'xor'     '((s[sp-1]^=s[sp--]))'
primitive 'lshift'  '((s[sp]=(s[sp-1]<<s[sp--])&true))'
primitive 'rshift'  '((s[sp]=(s[sp-1]&true)>>s[sp--]))'


# ----- flow control ------------------------------------- #fold01

remagic

colon 'if'
   code 'code "if ((s[sp--])); then"'
   push '${#body[@]}'                                                # allow check of empty function
   push "$magic"                                                     # allow check of structure
semicolon
compiled

colon 'else'
   code "(( s[sp]++ == \"$magic\" )) || { unstructured 'if'; return; }"
   code '(( s[sp-1] == ${#body[@]} )) && code "(())"'
   code 'code "else"'
   code '((s[sp-1]=${#body[@]}))'
semicolon
compiled

colon 'then'
   code "(( s[sp] == $magic ||  s[sp] == $((magic+1)) )) || { unstructured 'if or else'; return; }"
   atom 'drop'
   code '(( s[sp--] == ${#body[@]} )) && code "(())"'
   code 'code "fi"'
semicolon
compiled


remagic

colon 'begin'
   code 'code "while :; do"'
   push '${#body[@]}'                                                # allow check of empty function
   push "$magic"                                                     # allow check of structure
semicolon
compiled


colon 'again'
   code "(( s[sp--] == \"$magic\" )) || { unstructured 'begin'; return; }"
   code '(( s[sp--] == ${#body[@]} )) && code "(())"'
   code 'code "done"'
semicolon
compiled

colon 'until'
   code "(( s[sp--] == \"$magic\" )) || { unstructured 'begin'; return; }"
   code 'code "((s[sp--]))&&break"'
   atom 'drop'
   code 'code "done"'
semicolon
compiled

colon 'while'
   code "(( s[sp]++ == $magic )) || { unstructured 'begin'; return; }"
   code 'code "((s[sp--]))||break"'
semicolon
compiled

colon 'repeat'
   code "(( s[sp--] == $((magic+1)) )) || { unstructured 'while'; return; }"
   atom 'drop'
   code 'code "done"'
semicolon
compiled


remagic
colon 'for'
   code 'code "((r[++rp]=i))"'
   code 'code "((i=s[sp--]))"'
   code 'code "for ((; i--; )); do"'
   push '${#body[@]}'                                                # allow check of empty function
   push "$magic"                                                     # allow check of structure and empty function
semicolon
compiled

colon 'next'
   code "((s[sp--] == $magic))|| { unstructured 'for'; return; }"
   code '((s[sp--] == ${#body[@]})) && code "(())"'
   code 'code "done"'
   code "code '((i=r[rp--]))'"
semicolon
compiled


# x1 x2 -- x1+x2 x1
# : bounds   over + swap ;
colon 'bounds'
   atom 's1'
   atom 's2'
   code '((s[sp-1]=(s1+s2)&true))'
   code '((s[sp]=s2))'
semicolon
inline

remagic
dodo()  {
   ((r[++rp]=ibar))
   ((r[++rp]=i))
   ((i=s[sp--]))
   ((ibar=s[sp--]))
}

colon 'do'
   code 'code "dodo"'
   code 'code "while :;do"'
   push "$magic"                                                     # allow check of structure and empty function
semicolon
compiled

colon '?do'
   code 'code "dodo"'
   code 'code "while :;do"'
   code 'code "((i==ibar))&&break"'
   push "$magic"                                                     # allow check of structure and empty function
semicolon
compiled

colon 'loop'
   code "((s[sp--] == $magic))|| { unstructured 'do'; return; }"
   code 'code "((i=(i+1)&true))"'
   code 'code "((i == ibar))&&break"'
   code 'code "done"'
   code "code '((i=r[rp--]))'"
   code "code '((ibar=r[rp--]))'"
semicolon
compiled

colon '+loop'
   code "((s[sp--] == $magic))|| { unstructured 'do'; return; }"
   code 'code "((s1=s[sp--]))"'
   code 'code "((i+=s1))"'
   code 'code "((((ibar-(s1<msb)-i)^s1)&msb))&&break"'
   code 'code "done"'
   code "code '((i=r[rp--]))'"
   code "code '((ibar=r[rp--]))'"
semicolon
compiled

primitive 'leave'  'code "break"'              ; compiled            # break out of loop
primitive '?leave' 'code "((s[sp--]))&&break"' ; compiled            # break out of loop when false
primitive 'lest'   'code "((s[sp--]))||return"'; compiled            # interpreting version: skip rest of line when false
primitive 'lest'   '((s[sp--]))||line=""'      ; interpreted         # compiling version: skip until end of word (i.e. return) when true
primitive 'unless' 'code "((s[sp--]))&&return"'; compiled            # interpreting version: skip rest of line when true
primitive 'unless' '((s[sp--]))&&line=""'      ; interpreted         # compiling version: skip rest of word when false

# interpreting version: u times repeat evaluation of input line remainder
colon 'times'
   code '((r[++rp]=i))'                                              # by using i, and pushing previous i to rstack,
   code '((i=s[sp--]))'                                              # we make times, and nested times, compatible with i and j
   code 'while ((i--)); do evaluate "$line"; done'                   # evaluate line i times
   code '((i=r[rp--]))'                                              # restore old i
   code 'line=""'                                                    # prevent re-evaluation of line when times has completed
semicolon
interpreted

colon 'times'
   code 'code "((r[++rp]=i))"'                                       # by using i, and pushing previous i to rstack,
   code 'code "for ((i=s[sp--];i--;)); do"'
   code 'conclude "code \"done\""'
   code 'conclude "code \"((i=r[rp--]))\""'
semicolon
compiled

# this is the prefered version, repeating the line upon encountering many
# prefered because its use is more symmetrical with times, both specified
# before the repeated sequence.  times is harder to put at the end.
colon 'many'
   code 'until read -rsn1 -t 0.01; do evaluate "$line"; done'
   code 'line=""'
semicolon

colon 'boot'
   code 'word'
   code 'satisfy1 "$word"'
   code 'exists "$word" "currentwid" "${order[@]}"'                    # search current first because satisfy may have compiled it there
   code 'name "${exists[0]}"'                                          # convert xt to function name
   code 'coldvector="$name"'
semicolon

primitive 'warm'  'warm'
primitive 'bye'  'exit 0'
primitive 'exit'  'code "return"'; compiled
primitive 'return'  'code "return \${s[sp--]}"'; compiled



# ----- arithmetics -------------------------------------- #fold01

colon '1+'
   atom '1+'
semicolon
inline

colon '1-'
   atom '1-'
semicolon
inline

colon '2*'
   atom '2*'
semicolon
inline


primitive '+'   '((s[sp]=(s[sp-1]+s[sp--])&true))'
primitive '-'   '((s[sp]=(s[sp-1]-s[sp--])&true))'

# floored 2/
#primitive '2/'   '((s[sp]=(s[sp]>>1)|(s[sp]&msb)))'

colon  '2/'
   atom 's1'
#   code '((s[sp]=s1&msb?(s1>>1)|msb:s1>>1))'                        # floored
   code '((s[sp]=s1&msb?-((-s1&maxint)>>1)&true:s1>>1))'             # symmetric
semicolon


#                     msb&    msb&
#  s3 s2 s1 -- r q  s1^s2^s3  s2^s3
# ---------------------------------
#  +  +  +     + +     0        0
#  +  +  -     + -     1        0
#  +  -  +     - -     1        1
#  +  -  -     - +     0        1
#  -  +  +     - -     1        1
#  -  +  -     - +     0        1
#  -  -  +     + +     0        0
#  -  -  -     + -     1        0
# ( s3 s2 s1  -- s3*s2%s1 s3*s2/s1 )
colon '*/mod'
   atom 's1'
   atom 's2'
   atom 's3'
   atom 'drop'
   code '((signr=(s2^s3)))'                                          # 0:+   x:-
   code '((signq=(signr^s1)))'                                       # 0:+   x:-
   code '((s1&msb&&(s1=-s1&true)))'                                  # abs s1
   code '((s2*=s3))'
   code '((s2&msb&&(s2=-s2&true)))'
   code '((s[sp-1]=(signr&msb?(-s2%s1)&true:s2%s1)))'
   code '((s[sp]=(signq&msb?-(s2/s1)&true:s2/s1)))'
semicolon

colon 'negate'
   atom 'negate'
semicolon
inline

colon '?negate'
   code '((s[sp--]))&&'
   atom 'negate'
semicolon
inline

colon 'abs'
   code '((s[sp]&msb))&&'
   atom 'negate'
semicolon
inline



# ----- string stack operators---------------------------- #fold01

primitive 'empty$'   'ss=()'
primitive 'dup$'     'ss+=("${ss[-1]}")'
primitive '?dup$'    '[[ -z ${ss[-1]} ]] || ss+=("${ss[-1]}")'
primitive 'drop$'    'unset "ss[-1]"'
primitive 'over$'    'ss+=("${ss[-2]}")'
primitive 'pluck$'   'ss+=("${ss[-3]}")'
primitive 'pick$'    'ss+=("${ss[-s[sp--]-1]}")'

colon '2dup$'
   code 'ss+=("${ss[-2]}")'
   code 'ss+=("${ss[-2]}")'
semicolon
inline

colon '2drop$'
   code 'unset "ss[-1]"'
   code 'unset "ss[-1]"'
semicolon
inline

colon '2swap$'
   code 'tmp="${ss[-4]}"; ss[-4]="${ss[-2]}"; ss[-2]="$tmp"'
   code 'tmp="${ss[-3]}"; ss[-3]="${ss[-1]}"; ss[-1]="$tmp"'
semicolon
inline

colon 'swap$'
   code 'tmp="${ss[-2]}"; ss[-2]="${ss[-1]}"; ss[-1]="$tmp"'
semicolon
inline

colon 'nip$'
   code 'ss[-2]="${ss[-1]}"'
   code 'unset "ss[-1]"'
semicolon
inline

colon 'tuck$'
   code 'ss+=("${ss[-1]}"); ss[-2]="${ss[-3]}"; ss[-3]="${ss[-1]}"'
semicolon
inline

colon 'rot$'
   code 'tmp="${ss[-1]}"; ss[-1]="${ss[-3]}"; ss[-3]="${ss[-2]}"; ss[-2]="$tmp"'
semicolon
inline

colon '-rot$'
   code 'tmp="${ss[-1]}"; ss[-1]="${ss[-2]}"; ss[-2]="${ss[-3]}"; ss[-3]="$tmp"'
semicolon
inline

# results may not be what is expected: this removes *all* white space,
# not just leading and trailing white space. Actually a mistake, which
# I'll now try to sell as feature.
# or not. too specific, I better add some more general replace$ function
# ( string: $1 -- $2 )
#primitive 'trim$'  'ss[-1]="${ss[-1]//[[:space:]]/}"'

#primitive '-leading$'  'ss[-1]="${ss[-1]//^[[:space:]]*/}"'
#primitive '-trailing$'  'ss[-1]="${ss[-1]//[[:space:]]*$/}"'
#evaluate ': trim$  -leading$ -trailing$ ;'

# ( -- u )  string: ( $1 $2 -- $3 )     remove  $2* from $1, return removed chars count
colon 'cut$'
   push '${#ss[-2]}'
   code 'ss[-2]="${ss[-2]%${ss[-1]}*}"'
   code '((s[sp]-=${#ss[-2]}))'
   code 'unset "ss[-1]"'
semicolon

# count substring occurances
# : #substrings  swap$ 0 begin over$ cut$ while 1+ repeat 2drop$ ;
# -leading$:  ${myVar##*( )}
# -trailing$: ${myVar%%*( )}

colon '.ss'
   code '((${#ss[@]})) &&'
   code 'printf "\"%s\" " "${ss[@]}"'
semicolon

colon 'type$'
   code 'printf "%s" "${ss[-1]}"'
   code 'unset "ss[-1]"'
semicolon
inline


# ( $1 -- $2 )
primitive 'uppercase1$'   'ss[-1]="${ss[-1]^}"'                      # foobar -> Foobar
primitive 'lowercase1$'   'ss[-1]="${ss[-1],}"'                      # FooBar -> fooBar
primitive 'othercase1$'   'ss[-1]="${ss[-1]~}"'                      # fooBar -> FooBar
primitive 'uppercase$'    'ss[-1]="${ss[-1]^^}"'                     # FooBar -> FOOBAR
primitive 'lowercase$'    'ss[-1]="${ss[-1],,}"'                     # FooBar -> foobar
primitive 'othercase$'    'ss[-1]="${ss[-1]~~}"'                     # FooBar -> fOObAR

# split string into single words at white space, return count of resulting single word strings.
# ( -- u )   ss: ( $ -- $1 $2 $3 .. $u )
colon 'chop$'
   code 'tmp="${ss[-1]}"'
   code 'unset "ss[-1]"'
   code '((s1=${#ss[@]}))'
   code 'ss+=($tmp)'
   push '${#ss[@]}-s1'
semicolon

# ( $1 -- $2 )
primitive 'quote$' 'ss[-1]="\"${ss[-1]}\""'

# ---------- command ---------      - output -        ----- mnemonic -----
# "abcdefgh"   2  left$   type$      ab                "keep 2 left"
# "abcdefgh"  -2  left$   type$      abcdef            "keep left all but last 2"
# "abcdefgh"   2  right$  type$      gh                "keep 2 right"
# "abcdefgh"  -2  right$  type$      cdefgh            "keep right all but first 2"
# "abcdefgh"   2  split$  type$      ab cdefgh         "split at left"
# "abcdefgh"  -2  split$  type$      abcdef gh         "split at right"
# "abcdefgh"   3  2 mid$  type$      de                "abcdefgh" -> "defgh" -> "de"
# "abcdefgh"  -3  2 mid$  type$      fg                "abcdefgh" -> "fgh"   -> "fg"
# "abcdefgh"   3 -2 mid$  type$      def               "abcdefgh" -> "defgh" -> "def"
# "abcdefgh"  -3 -2 mid$  type$      f                 "abcdefgh" -> "fgh"   -> "f"


colon 'left$'
   code '((tmp=s[sp--]))'
   code '((tmp&msb))&&((tmp|=~maxuint))'
   code 'ss[-1]=${ss[-1]:0:tmp}'
semicolon

colon 'right$'
   code '((tmp=s[sp--]))'
   code '((tmp&msb))&&((tmp|=~maxuint))'
   code 'ss[-1]=${ss[-1]:0-tmp}'
semicolon

# ( u -- ) ( $1 -- $2 $3 )
colon 'split$'
   code '((tmp=s[sp--]))'
   code '((tmp&msb))&&((tmp|=~maxuint))'
   code 'ss+=("${ss[-1]:tmp}")'
   code 'ss[-2]="${ss[-2]:0:tmp}"'
semicolon

colon 'join$'
   code 'ss[-2]+="${ss[-1]}"'
   code 'unset "ss[-1]"'
semicolon
inline

colon '$='
   code '[[ ${ss[-1]} != ${ss[-2]} ]]'
   push '(-$?)&true'
   code 'unset "ss[-1]"'
   code 'unset "ss[-1]"'
semicolon

colon '$<'
   code '[[ ${ss[-1]} > ${ss[-2]} ]]'
   push '($?-1)&true'
   code 'unset "ss[-1]"'
   code 'unset "ss[-1]"'
semicolon

colon '$>'
   code '[[ ${ss[-1]} < ${ss[-2]} ]]'
   push '($?-1)&true'
   code 'unset "ss[-1]"'
   code 'unset "ss[-1]"'
semicolon

# "nice"    "this is a very *** foo"   "***" replace$    ->   "this is a very nice foo"
# "nope"    "this is a very *** foo"   "?" replace$      ->   "this is a very *** foo"
# "123"     "abcd" 1 insert$  -> "a123bcd"

primitive 'allot$' '((sdp+=s[sp--]))'

colon '$,'
   code 'strings[sdp++]="${ss[s-1]}"'
   code 'unset "ss[-1]"'
semicolon


# push string array item u to string stack
# ( u -- ) ( -- $1 )
primitive '$@'  'ss+=("${strings[s[sp--]]}")';  inline

# store string stack item in string array
# ( u -- )  ( $1 -- )
colon '$!'
   code 'strings[s[sp--]]="${ss[-1]}"'
   code 'unset "ss[-1]"'
semicolon


# --- mixed mode operations, exchanges between stack and string stack ---
# remove first character from top of string stack, push its ASCII value
# on stack, or 0 if no char, empty string.
# ( -- c )  ( $1 -- $2 )
asc()  {
   if [[ -z "${ss[-1]}" ]]; then
      ((s[++sp]=0))
   else
      ((s[++sp]=${asc[${ss[-1]:0:1}]}))
      ss[-1]="${ss[-1]:1}"
   fi
}

primitive  'asc'    'asc'
primitive  'char$'  'ss+=("${char[s[sp--]]}")'


# $ -> a -- n
unpackstring()  {
   string="${ss[-1]}"
   unset "ss[-1]"
   ((tmp="${#string}", s1=s[sp]))
   for ((len=0; tmp--;)); do
      ((m[s1++]="asc[${string:len++:1}]"))
   done
   ((s[sp]="$len"))
}

primitive 'unpack$' 'unpackstring'

# ( a n -- ) ( string: -- $ )
colon 'pack$'
   atom 's1'
   atom 's2'
   code '((sp-=2))'
   code 'tmp=""'
   code 'for ((; s1--; )); do tmp+="${char[m[s2++]]}"; done'
   code 'ss+=("$tmp")'
semicolon

primitive 'append$' 'ss[-1]+="${char[s[sp--]]}"'                     # ( c -- ) ( string: $1 -- $2 )
primitive 'prepend$' 'ss[-1]="${char[s[sp--]]}${ss[s-1]}"'           # ( c -- ) ( string: $1 -- $2 )


# ----- environment--------------------------------------- #fold01

# read number from environment variable with name on string stack
#evaluate ': env  [ "${!ss[-1]}&true" ] push$ drop$ ;'                # ( -- x )  ( string:  $1 -- )

# store $1 in bash environment variable with name $2
# ( x -- ) ( string:  $1 -- )
colon '>env'
   code 'eval "${ss[-1]}=$((s[sp--]))"'
   code 'unset "ss[-1]"'
semicolon

# read string from environment variable with name on string stack
# ( string:  $1 -- $2 )
primitive 'env$' 'ss[-1]="${!ss[-1]}"'

# store string $1 in bash environment variable with name $2
# ( string:  $1 $2 -- )
colon '>env$'
   code 'eval "${ss[-1]}=${ss[-2]}"'
   code 'unset "ss[-1]"'
   code 'unset "ss[-1]"'
semicolon


# ----- memory ------------------------------------------- #fold01

colon '@'
   atom '@'
semicolon
inline

colon '!'
   code '((m[s[sp--]]=s[sp-1]))'
   atom 'drop'
semicolon
inline

primitive 'c@'  '((s[sp]=m[s[sp]]&255))'

colon 'c!'
   code '((m[s[sp--]]=s[sp-1]&255))'
   atom 'drop'
semicolon
inline


# ( a -- [a+cell] [a] )
colon '2@'
   atom 's1'
   code '((s[sp++]=m[s1+1]))'
   code '((s[sp]=m[s1]))'
semicolon
inline


# ( [a+cell] [a] a -- )
colon '2!'
   code 's1=s[sp--]'
   code '((m[s1++]=s[sp--]))'
   code '((m[s1]=s[sp--]))'
semicolon
inline

colon '<-'                                                           # ( a x -- )   swap !
   code '((m[s[sp]]="s[sp--]"))'
   atom 'drop'
semicolon

colon '+!'
   code '((m[s[sp--]]=(s[sp-1]+m[s[sp]])&true))'
   atom 'drop'
semicolon
inline

primitive 'on'   '((m[s[sp--]]=true))'
primitive 'off'  '((m[s[sp--]]=false))'
primitive 'inc'  '((m[s[sp--]]=(m[s[sp]]+1)&true))'
primitive 'dec'  '((m[s[sp--]]=(m[s[sp]]-1)&true))'

# replace contents of a against x1,
# while returning former contents as x2
# ( x1 a -- x2 )
colon 'exchange'
   code '((tmp=m[s[sp]]))'
   code '((m[s[sp]]=s[sp-1]))'
   code '((s[--sp]=tmp))'
semicolon

# replace contents of a and a+cell against x1 x2,
# while returning former contents as x3 x4
# ( x1 x2 a -- x3 x4 )
colon '2exchange'
  code '((s1=s[sp--]))'
  code '((s2=s[sp]))'
  code '((s3=s[sp-1]))'
  code '((s[sp]=m[s1]))'
  code '((s[sp-1]=m[s1+1]))'
  code '((m[s1]=s2))'
  code '((m[s1+1]=s3))'
semicolon

colon 'allot'
   atom 'allot'
semicolon
inline

primitive ',' '((m[dp++]=s[sp--]))'

# c -> m[a++],  u times
# ( a u c -- )
colon 'fill'
   code '((s1=s[sp--], s2=s[sp--], s3=s[sp--]))'
   code 'for ((;s2--;)); do ((m[s3++]=s1)); done'                    # c -> m[a++],  u times
semicolon


# ( a1 a2 u -- )
move()  {                                                            # deals with destination overlapping source
   ((s1=s[sp--], s2=s[sp--], s3=s[sp--]))
   if ((s3 < s2)); then                                              # copy highest to lowest:
      ((s2+=s1, s3+=s1))                                             # m[--a1+u} -> m[--a2+u],  u times
      for ((;s1--;)); do
         ((m[--s2] = m[--s3]))
      done
   else                                                              # copy lowest tio highest
      for ((;s1--;)); do                                             # m[a1++} -> m[a2++],  u times
         ((m[s2++] = m[s3++]))
      done
   fi
}

# ( a1 a2 u -- )
primitive 'move'   'move'




# ----- character i/o ------------------------------------ #fold01

# given an ASCII, print the character
primitive 'emit'  'printf "%c" "${char[s[sp--]&255]}"'
# duplicating 'char functionality because quoting in evaluate
# becomes sometimes hard when using ' ' for characters' ASCIIs
colon '[char]'
   code 'word'
   code 'push "${asc[${word:0:1}]}"'
semicolon
compiled


colon 'key'
   code 'if [[ -z "$keybuf" ]]; then'                                # key? may have put chars into keybuf
   code 'IFS="" read -rsn1 tmp'                                      # keybuf empty: read from console
   code 'keybuf+="${tmp}"'                                           # consider space if -z $tmp
   code 'fi'
   code 'tmp="${keybuf:0:1}"'                                        # read key from keybuf
   code 'tmp=$(printf "%d" '"\"'""\${tmp}\")"                        # treat ctrls as spaces, convert to ASCII
   push 'tmp'                                                        # push ASCII
   code 'keybuf="${keybuf:1}"'                                       # strip key from keybuf
semicolon

colon 'key?'
   code '[[ -z "$keybuf" ]] || { s+=("$true"); return; }'            # key in keybuf: yes, flag "key ready"
   code 'IFS=""'                                                     # no key in keybuf: poll console
   code 'if read -rsn1 -t0.01 tmp; then'
   code 'keybuf+="$tmp"'                                             # add key to buffer. maybe add space if -z $tmp
   push 'true'
   code 'return'
   code 'fi'
   push 'false'
semicolon


colon 'spaces'
   code '((s1=s[sp--]))'
   code '((s1&msb))||printf "%${s1}s" ""'
semicolon


primitive  'cr'      'printf "\n"'
primitive  'space'   'printf " "'
primitive  'page'    'clear'
primitive 'simpleprompt' '((compiling)) || printf " %s\n" "ok"'
defer     'prompt'       'simpleprompt'


# ----- file i/o ----------------------------------------- #fold01


# load file whose name is given on string stack
# ( -- ) ( string: $1 -- )
colon 'from$'
   code 'file="${ss[-1]}"'
   code 'unset "ss[-1]"'
   code 'from "$file"||filenotfound "$file"'
semicolon


# NOTE: test with tabs and spaces instead of empty lines
# omit block of source lines up to next empty line
colon 'omit'
   code 'until (( linenr > ${#lines[@]} )); do'
   code 'line="${lines[linenr++]}"'
   code '[[ -z "$line" ]] && break'
   code 'done'
semicolon


# ----- pictured number conversion ----------------------- #fold01

# NOTE: consider to let # expect a double, but process lower
# half only, so its stack complies with standard # while its
# not actually able to work on doubles.
# change would also apply to #s, #>, uconvert: doubles on
# stack but singles only processed.
# ( x1 -- x2 ) ( string: $1 -- $2 )
colon '#'                                                            # : #
   code '((radix=m[base]))'                                          # base @
   code '((s1=s[sp]&true, s[sp]=s1/radix, tmp=s1%radix+48))'         # /mod swap '0 +
   code '((tmp>57))&&((tmp+=39))'                                    # dup '9 > 39 and +
   code 'ss[-1]="${char[tmp]}${ss[-1]}"'                             # hold
semicolon                                                            # ;


# ----- vocabularies and wordlists ----------------------- #fold01

# NOTE: consider use of generated word list names, like wordlist_$wid
# use anychar names on yoda side, generated names on bash side.
colon 'initwordlist'                                                 # ( wid -- )
   code '((tmp=s[sp--]))'
   code 'declare -gA "flags_$tmp=()"'                                  # word to function name and header flags
   code 'declare -gA "wordlist_$tmp=()"'                               # word to function name and header flags
semicolon

colon 'get-context'
   push 'order[0]'
semicolon
inline


colon 'set-current'
   code 'set-current "${s[sp--]}"'
semicolon
inline

primitive 'set-context'  'order[0]="${s[sp--]}"'


# --- populate only voc ---
set-current "$onlywid"

primitive 'also'      'order=("${order[0]}" "${order[@]}")'
colon 'order'
   code 'printf "context:"'
   code 'for wid in "${order[@]}"; do'
   code 'printf " %s" "${strings[wid]}"'
   code 'done'
   code 'printf "\ncurrent: %s\n" "${strings[currentwid]}"'
semicolon

primitive 'previous' '((${#order[@]}>1))&&{ order=("${order[@]:1}"); }'
primitive 'words'    'words'
primitive 'words+'   'wordsplus'
primitive 'onlyonly' 'order=("$onlywid")'

include << 'end'
: forth        [ "forthwid" ] push$ set-context ;
: definitions  get-context set-current ;
: only         onlyonly also definitions ;
end

trash onlyonly
set-current "$forthwid"


# ----- foward referencing support words ----------------- #fold01

# forward referencing scheme using dependencies files, which maps
# word names to file names, allowing to locate source of required
# code quickly for inclusion:
#
#  provides:
#     like \ treating rest of line as comment.
#     purpose is to allow grepping libraries for file names
#     providing the words listed there, to generate a simple
#     form of dependency files.
#     Insert it into library files, listing the words which can
#     be resolved by library. Idea is to have very short library
#     files, often just containing a single word.
#
#  dependencies
#     run through library directories and their subdirectories, and
#     look for lines starting with provides:
#     extract the list of names, and write names, one per line, followed
#     by file name, into the "dependencies" file.
#     This build the dependencies "database", and needs only done when
#     dependencies are outdated, stale or missing.
#
#  satisfy
#  needs:
#     these are merely different names for the same function. needs:
#     pairs more nicely with provides: when written into library fragments.
#     These turn forward refs on, parse space delimited strings from input
#     line (the name of needed words). For each word is the library
#     file containing word's source located by searching the dependencies
#     file, the source is included from file, thereby satisfying the
#     forward reference. When done is old forward refs state restored.
#     When a word can't be resolved, due to not having an entry in the
#     dependencies fiel, or the file not existing, a vocabulary based
#     forward reference is created through need. This renders the not
#     included word compilable. When source becomes available (file
#     suddenly existing, or word defined by other means) will the forward
#     reference be cleared, and compiled calls to it associated with the
#     then created word.
#
#  Purpose is to allow library inclusion with much finer granulation than
#  what is possible with including library files which unconditionally
#  include heaps of words, without the need to restructure the libraries
#  towards conditional compilation.
#
#  Above words are more concerned with locating and including source. They
#  don't address the case when a word source doesn't exist (yet). To deal
#  with these words, a supporting word set working on vocabularies exists:

# need can create forward ref even though forward refs are turned off.
# resolving will still be done, that way can specific words (and their
# dependencies) be picked from forward lib.
# arg1: name of needed word,  arg2; referer

# needed is used to test forward reference status of a word. A non-false
# result indicates a forwards referenced word.
# Interpret time flow control words such as lest or unless can be used
# to respond to the result of needed.

# words  have, lack and needed, all returning false or "some" value
# (which could be true, but also an execution token), deliver results
# according to this table:
#
#                         have    lack    needed
# existing word            xt     false   false
# non-existing non-forw   false   true    false
# forward ref word        false   true    true

# reason for this apparent redundancy of having both need/resolve and satisfy
# for resolving yet unresolved words is that satisfy can't be used in some
# situations, when need can. satisfy is unsuited for use while compiling a
# word - most likely will execution of satisfy result in compiling words, and
# we can't do that while already compiling a word, because compilation isn't
# nestable. This disqualifies the use of satisfy for creating forward references
# which arise during compilation - and that's probably the most common case
# where forwards references are created. "Need" OTOH will do nicely there, by
# only registering the need, but leaving it to "resolve" to include code at
# a more appropriate time.


need()  {
   exists "$1" "${order[@]}" "$interpretonlywid" "$compileonlywid" ||
   forwardref "$1"  "$2"                                             # forwardref protects itself against already forwardref'd words
}

colon 'need'                                                         # ( -- )  ( stream: bl delimited string )
   code 'word'
   code 'need "$word" ""'                                            # empty arg indicates explicit need, no referer
semicolon

colon 'needed$'                                                      # ( -- f ) ( $1 -- )
   code '[[ -z "${unresolved[${ss[-1]}]}" ]]'                        # check unresolved status of word
   push '$??true:false'                                              # return result
   code 'unset "ss[-1]"'
semicolon



colon 'neededanyof'                                                  # ( -- f ) ( stream: bl delimited strings, whole input line )
   push "$false"
   code 'while [[ -n "$line" ]]; do'
   code 'word'
   code '[[ -z "${unresolved["$word"]}" ]] || {'                     # check unresolved status of word
   code '((s[sp]=true))'                                             # unresolved -> needed
   code 'line=""'                                                    # "wired or" - one needed is enough, skip rest
   code '}'
   code 'done'
semicolon



generate_dependencies()  {                                           # library inclusion dependency file builder
   local provided
   { echo "$v version"
     grep -r "^provides: " "${libdirs[0]}"
   } | while read -r file words; do
      read -ra provided <<< "$words"
      file="${file%:provides:}"
      file="${file#"${libdirs[0]}"/}"
      printf "%-31s $file\n" "${provided[@]}"
   done > "$dependencies"
}

cache_dependencies()  {
   while read -r word file _; do
   lib["$word"]="$file"
   done < "$dependencies"
}

dependencies()  {                                                    # library inclusion dependency file builder
   generate_dependencies
   cache_dependencies
}

# try to resolve all words given on input line.
# args:  names of words
satisfy()  {
   local line
# SC2068 (error): Double quote array expansions to avoid re-splitting elements:
# I don't want to avoid re-splitting, I want re-splitting to happen.
#shellcheck disable=2068
   for word in $@; do
      satisfy1 "$word" || notfound "$word"
   done
}

primitive 'dependencies' 'dependencies'                              # generate, then cache
primitive "provides:"   'line=""'        ;   interpreted             # double quoted escaped backslash rather than

colon 'satisfy'
   code  'satisfy "$line"'
   code  'line=""'
semicolon


#
# satisfy references from top string stack item
# ( $1 -- )
colon 'satisfy$'
   code 'satisfy "${ss[-1]}"'
   code 'unset "ss[-1]"'
semicolon


# ----- documentation ------------------------------------ #fold01

# NOTE: whole undoc section is library candidate
# arg1: word name
# arg2: headerlist
undoc_template()  {
cat << EOF
created:             auto     (remove line after having checked and revised description)
name:                $1
stack:               ( -- )
return stack:        ( -- )
string stack:        ( -- )
contexts:            ${2#"headers"}
category:
input stream:

decription:          none

example:             none
notes:               none
standard:            no
deviation:           ?
url:                 https://forth-standard.org/standard/core/${1^^}
EOF
}

# changes problematic chars in arg1.
# sanitised string is returned in variable file
declare -A sanitise=(
   ['/']="slash"
   ["\\"]="backslash"
   [';']="semi"
   ['$']="dollar"
   ['>']="gt"
   ['<']="ls"
   ['!']="excl"
   ['#']="hash"
   ["'"]="tick"
   ['?']="qmrk"
   ['*']="star")
sanitise()  {
   file="$1"
   for tmp in "${!sanitise[@]}"; do
      file="${file//"$tmp"/"[${sanitise[$tmp]}]"}"
   done
}

undoc()  {
   local wid wordlist context
   for wid in "$forthwid" "$onlywid" "$interpretonlywid" "$compileonlywid"; do
      wordlist="${strings[wid]}"
      [[ "$wordlist" == "forth" ]] && wordlist="stateless"
      declare -n context="$wordlist"
      for word in "${!context[@]}"; do                               # run through all headers
         sanitise "$word"
         [[ -f "$worddoc:$file" ]] || {                              # found one for which no doc file exists
            undoc_template "$word" "${!context}" >> "$worddoc:$file"
            editor "$worddoc:$file"
            return
         }
      done
   done
}
primitive 'undoc' 'undoc'

# candidates for $command further down
doc()  {
   sanitise "$1"
   editor "$worddoc:$file"
}

about()  {
   sanitise "$1"
   cat "$worddoc:$file"
}

colon 'doc'
   code 'word'
   code 'doc "$word"'
semicolon

colon 'about'
   code 'word'
   code 'about "$word"'
semicolon


# ----- shell ---------------------------------------------
# TODO: optimiser: invalidate all stack register contents
# execute shell command "$2" with args "$1"
colon 'shell$'
   code '${ss[-1]}'
   code 'unset "ss[-1]"'
semicolon

colon 'command$'
   code '${ss[-2]} "${ss[-1]}"'
   code 'unset "ss[-1]"'
   code 'unset "ss[-1]"'
semicolon



# ----- files -------------------------------------------- #fold01



# push name of file u (from output of files) to string stack
# ( u -- ) ( string: -- $1 )
colon 'filename$'
   code 'ss+=("${files[s[sp--]]}")'
semicolon
inline

# return handle of source. 0=console, >0 correspond files handle
# allows words to determine whether they're executed while loaded
# from file or console, as well as the path/name of the file they're
# loaded from.
# ( -- u )
colon 'origin'
   push '${filehandle:-"0"}'
semicolon
inline


# copy remainder of input line to string stack without affecting it.
# ( -- )  ( -- $1 )
primitive 'source$'  'ss+=("$line")'

# stop loading file
colon 'done'
   code 'line=""'                                                    # nothing more to process on current line
   code 'linenr="-1"'                                                # signal "all done" to from
semicolon


# ----- high level --------------------------------------- #fold01

include << 'end'

only forth definitions

\ ----- flow control ------------------------------------- #fold02

( -- x )
: i            [ "i" ] push$ ;                                 inline

( -- x )
' r@ alias j

\ ----- stack -------------------------------------------- #fold02

( ?? -- ?? u )
: depth        [ "sp" ] push$ ;                                inline

( ... x2 x1 x0 u -- ... x2 x1 x0 xu )
: pick         [ "s[sp-s[sp--]-1]" ] push$ ;                   inline

( -- u )
: rdepth       [ "rp" ] push$ ;                                inline

( -- u )
: depth$       [ "${#ss[@]}" ] push$ ;                         inline

\ ----- arithmetics -------------------------------------- #fold02

\ truncated, symmetric
( n1 n2 n3 -- n4 )
: */           */mod nip ;                                     inline

\ truncated, symmetric
( n1 n2 -- n3 n4 )
: /mod         1 -rot  */mod ;

( n1 n2 -- n3 )
: *            1 */   ;                                        inline

\ truncated, symmetric
( n1 n2 -- n3 )
: /            /mod nip  ;                                     inline

\ sign according  n1 == n2*(n1/n2)+remainder
( n1 n2 -- n3 )
: mod          /mod drop  ;                                    inline

\ percentage rounded, not truncated
( n1 n2 -- n3 )
: %             50 */ dup 0< 1 or + 2/ ;  inline

( n1 n2 -- n1|n2 )
: min          2dup >  if nip exit then drop ;

( n1 n2 -- n1|n2 )
: max          2dup <  if nip exit then drop ;

( u1 u2 -- u1|u2 )
: umin         2dup u> if nip exit then drop ;

( u1 u2 -- u1|u2 )
: umax         2dup u< if nip exit then drop ;

( x1 -- x2 )
: cells        ;                                               compiled

( x1 -- x2 )
: cells        ;                                               interpreted

( x1 -- x2 )
: cell+        1+ ;                                            inline

( n -- d )
: s>d          dup 0<  ;                                       inline

( x1 u -- x2 )
' lshift alias <<

( x1 u -- x2 )
' rshift alias >>

\ ----- memory ------------------------------------------- #fold02

( a -- a+1 c )
: count        [ "m[s[sp]++]&255" ] push$ ;                    inline

( a -- a+cell x )
: skim         [ "m[s[sp]++]"     ] push$ ;                    inline

\ 0 -> m[a++],  u times
( a u -- )
: erase        0 fill ;                                        inline

( -- a )
: here         [ "dp" ] push$ ;                                inline

( -- u )
( $1 -- )
: count$       [ "${#ss[-1]}" ] push$ drop$ ;                  inline

( -- u )
: here$        [ "sdp" ] push$ ;                               inline

( -- x )
( string:  $1 -- )
: env          [ "${!ss[-1]}+0&true" ] push$ drop$ ;           inline

\ ----- i/o ---------------------------------------------- #fold02
( a u -- )
: type         pack$ type$ ;                                   inline

( u -- )
( $1 -- )
: ltype$       dup$ type$ count$ - spaces ;

( u -- )
( $1 -- )
: rtype$       dup$ count$ - spaces type$ ;

( -- )
( -- $1 )
: word$        bl parse$ ;                                     inline

defer query$
' simplequery$ is query$


\ ----- pictured number conversion ----------------------- #fold02
( c -- )
( $1 -- $2 )
' prepend$ alias hold                                          inline

( -- )
(  -- $2 )
: <#           ""  ;                                           inline

( x1 -- x2 )
( $1 -- $2 )
: #s           begin # dup 0= until ;

( f -- )
( $1 -- $2 )
: sign         0< lest '-' hold ;

( x -- )
' drop alias #>$                                               inline

( x -- )
( $1 -- )
: #>type       #>$ type$ ;                                     inline

( x -- a n )
( $1 -- )
: #>           #>$ here here unpack$ ;

( u -- )
( -- $1 )
: uconvert     <# #s #>$ ;

( u -- )
( -- $1 )
: convert      dup abs uconvert sign ;

( n -- )
: .            convert type$ space ;

( u -- )
: u.           uconvert type$ space ;

( n u -- )
: .r           >r  convert r> rtype$ ;

( u1 u2 -- )
: u.r          >r uconvert r> rtype$ ;

\ ----- dictionary and compiling ------------------------- #fold02

( -- wid )
: get-current  [ "currentwid" ] push$  ;                       inline

( -- u )
: #unresolved  [ "${#unresolved[@]}" ] push$ ;                 inline

' have$ alias xt

\ produces execution token and removes header of last word
\ : foo ... ; noname
( -- xt )
: noname       last$ dup$ xt trash$ ;

( -- )         \ compile time
( -- x )       \ run time
: me           [ "xt" ] push$  literal, ;                      compiled

( -- f )
( stream: word )
: needed       word$ needed$ ;                                 inline

' satisfy alias needs:

( x -- )
: literal      literal, ;                                      compiled

( -- flag )
: compiling    [ "compiling" ] push$ ;                         inline

\ word exists?
( -- 0|xt )
( stream: word )
: have         word$ have$ ;                                   inline

\  word missing?
( -- flag )
( stream: word )
: lack         have  0=    ;                                   inline

( -- )
( stream: word )
: [']          ' literal,   ;                                  compiled

\ ----- unsorted ----------------------------------------- #fold02

( ??? -- )
: quit         warm
               begin
                  query$ evaluate$
                  resolve
                  prompt
               again ;

( ??? -- )
' quit alias abort

( f -- )
: ?abort       lest abort ;


\ ----- files and loading -------------------------------- #fold02

( -- u )
: #files       [ "${#files[@]}" ] push$ ;                      inline

( -- )
( stream: filename )
: from         word$ from$ ;

\ better symmetry with thisfile$
( -- u )
' origin alias thisfile

\ check whether current source had already been compiled from before.
\ most useful when used interpretatively in a file, for testing whether
\ it will be or has been reloaded, such as with "loaded lest done"
\ returned u is the count the file has been loaded.
( -- u )
: loaded       [ "loaded[filehandle]" ] push$ ;                inline

\ true: loading from file?,  false: interactive (console).
\ pipe or redirection is indicated as loading from file.
( -- flag )
: loading      [ "linenr<0?false:true" ] push$ ;               inline

\ produce name of currently loaded file
( -- )
( -- $1 )
: thisfile$    thisfile filename$ ;                            inline

\ prevent reloading file
( -- )
: once         loaded lest done ;

end

# ----- convenience -------------------------------------- #fold01

primitive 'decimal'  "m[$base]=10"
primitive 'hex'      "m[$base]=16"
primitive 'binary'   "m[$base]=2"


colon 'where$'
    code 'tmp="${ss[-1]}"'                                           # name of word to look up
    code 'unset "ss[-1]"'
    code '[[ -z "$tmp" ]]&&emptyname'                                # no name given
    code 'tmp1="${where[$tmp]}"'                                     # "file:line"
    code '((${tmp1%%:*}))||nosource "$tmp"'                          # file handle empty or 0: no source available
    push '${tmp1%%:*}'                                               # push file handle
    push '${tmp1##*:}'                                               # push line number
semicolon


primitive empty  's=() sp=0'
primitive rempty 'r=() rp=0'

# empty stack and string stack
# since warm doesn't empty them any longer, a convenient
# way to do so manually was needed.
primitive 'random'   '((s[++sp]=SRANDOM&true))'                      # ( -- u )        32 bits random number
primitive 'realtime' '((s[++sp]=${EPOCHREALTIME//[,.]/}&true))'      # a microseconds epoch, used for benchmarking
primitive 'secs'     'sleep "${s[sp--]}"'

colon 'version'
   push '${version[0]}'
   push '${version[1]}'
   push '${version[2]}'
semicolon


# ----- launch ------------------------------------------- #fold00

# shellcheck source=./yoda.conf                                      # try to load custom configuration
config()  {
   [[ -f "$HOME/$config" ]]  && { source "$HOME/$config"; return; }  # config in $HOME has priority over config in yoda dir
   [[ -f "$mydir/$config" ]] && source "$mydir/$config"
}
config
[[ -f "$dependencies" ]] || generate_dependencies                    # no dependencies -> generate
read -r _ tmp < <(grep '^version ' "$dependencies")                  # check version
[[ "$tmp" == "$v" ]] || generate_dependencies                        # new yoda -> generate
cache_dependencies                                                   # read dependencies into memory
args=("$@")                                                          # read command line
(( ${#args[@]} )) || read -rst 0.01 "args"                           # no command line specified: check whether commands are piped
[[ -z ${args[0]} ]] && args[0]="$default"                            # neither pipe nor command line: load default launch commands
files[1]="$(realpath "$0")"                                          # handles: 0=tty, 1=yoda, others added as they're loaded
evaluate "${args[*]}"                                                # evaluate piped command, command line or default initial commands
if [[ -n "$coldvector" ]]; then                                      # if cold launch point was specified, try to run.
   resolve                                                           # still unresolved words? try to resolve those.
   if (( ${#unresolved[@]} )); then                                  # still unresolved words
      printf "%s\n" "unresolved forward references:"
      printf "%s\n" "${!unresolved[@]}"
      printf "%s\n" "Run this not I will."
   else
      cold
   fi
fi
