>set-current "$forthwid"

\ ----- defining words -----------------------------------

: create
   here constant  ;

: create$
   here constant$  ;

: variable
   create cell allot  ;

: primitive   ( -- )  ( $1 -- )
      code
      postpone code,
      ;code  >inline
 ;

            ( a -- ) ( s: word )   \ creation
: buffer:   ( -- a )             \ execution
      create allot  ;

\ ----- system constants ---------------------------------

' noop alias chars                                                                                 immediate
' noop alias cells                                                                                 immediate
' noop alias aligned                                                                               immediate
' noop alias align                                                                                 immediate

' 1+ alias char+  inline
' 1+ alias cell+  inline

\ ----- manage wordlists ---------------------------------

: literal         ( x -- )                literal,                            ;                    compiled
: env             ( -- x ) ( $1 -- )      [ "${!ss[-1]}+0&true" ]    push,    drop$ ;              inline

>set-current      "$onlywid"
"words"                                   primitive words            ( -- )                        inline
: definitions     ( -- )                  get-context set-current             ;                    inline
: only            ( -- )                  >order=("$onlywid"); also definitions ;                  inline
: forth           ( -- )                  [ "forthwid" env ] literal set-context  ;                inline
only forth definitions

\ by making compiler wordlist visible, it can be added to order,
\ providing the means to control searching it, as compiler voc is
\ otherwise searched during compilation only.
: compiler        ( -- )                  [ "compilerwid" env ] literal set-context  ;             inline

\ ----- stack --------------------------------------------

\ code sp!       ( ??? u -- [u items] )               "sp"                          pop,  ;code    inline
: nip          ( x1 x2 -- x2 )                        [ "s[sp-1]=s[sp]" ]  code,    drop  ;        inline
: ?dup         ( x -- 0 | x x )                       [ "((s[sp])) &&" ]   code,    dup   ;        inline
: 2dup         ( x1 x2 -- x1 x2 x1 x2 )               over over                           ;        inline

\ ----- flow control -------------------------------------

code i         ( -- x )                               "i"                           push, ;code    inline
code unloop    ( -- x )                               "((i=r[rp--]))"               code,
                                                      "((ibar=r[rp--]))"            code, ;code    inline
' r@ alias j                                                                                       inline
code ?leave    ( flag -- )                            "code '((s[sp--]))&&'"        code,
                                                      "code 'break'"                code, ;code    compiled

\ ----- arithmetics --------------------------------------

' lshift alias <<                                                                                  inline
' rshift alias >>                                                                                  inline

: ?negate      ( n flag -- n | -n )                   [ "((s[sp--]))&&" ]   code, negate  ;        inline
: abs          ( n -- u )                             [ "((s[sp]&msb))&&" ] code, negate  ;        inline
: /mod         ( n1 n2 -- n3 n4 )                     1 -rot  */mod                       ;                 \ divisions are truncated, symmetric
: */           ( n1 n2 n3 -- n4 )                     */mod nip                           ;        inline
: /            ( n1 n2 -- n3 )                        /mod nip                            ;        inline
: *            ( n1 n2 -- n3 )                        1 */                                ;        inline
: mod          ( n1 n2 -- n3 )                        /mod drop                           ;        inline
: %            ( n1 n2 -- n3 )                        #50 */ dup 0< 1 or + 2/             ;                 \ percentage rounded, not truncated
: min          ( n1 n2 -- n1|n2 )                     2dup >  if nip exit then drop       ;
: max          ( n1 n2 -- n1|n2 )                     2dup <  if nip exit then drop       ;
: umin         ( u1 u2 -- u1|u2 )                     2dup u> if nip exit then drop       ;
: umax         ( u1 u2 -- u1|u2 )                     2dup u< if nip exit then drop       ;
: s>d          ( n -- d )                             dup 0<                              ;        inline
: within       ( x low high -- flag )                 over - >r - r> u<                   ;
: um/mod       ( d u1 -- u2 u3 )                      ud/mod drop                         ;        inline   \ d / u1 -> quotient u3 remainder u2
: dabs         ( d1 -- d2 )                           dup 0< lest dnegate                 ;

\ ----- memory -------------------------------------------

: erase        ( a u -- )                             0 fill ;                                     inline      \ 0 -> m[a++],  u times
: <-           ( a x -- )                             [ "m[s[sp]]" ]          pop, drop   ;        inline      \ same as:  swap !
: pad          ( -- a )                               here #256 +                         ;        inline
: count$       ( -- u ) ( $1 -- )                     [ "${#ss[-1]}" ]        push, drop$ ;        inline

\ ----- i/o ----------------------------------------------

defer query$                                          ' simplequery$ is query$
: type         ( c-addr u -- )                        pack$ type$                         ;        inline
: ltype$       ( u -- ) ( $1 -- )                     dup$ type$ count$ - spaces          ;
: rtype$       ( u -- ) ( $1 -- )                     dup$ count$ - spaces type$          ;
: parse        ( c -- c-addr u )                      parse$ here dup unpack$             ;
: parse-name   ( -- c-addr u )                        word$  here dup unpack$             ;
: source       ( -- c-addr u )                        "tib" env$ here dup unpack$         ;
: compile$     ( -- )                                 '"' parse$  postpone literal$       ; transient
: compile\$    ( -- )                                 '"' parse\$  postpone literal$      ; transient
: (c")         ( -- c-addr )  ( $1 -- )               here dup 1+ unpack$ over c!         ; transient protect
: c"           ( -- c-addr )                          compile$ postpone (c")              ; compiled
: (s")         ( -- addr u )  ( $1 -- )               here dup unpack$                    ; transient protect
: s"           ( -- c-addr u )                        compile$ postpone (s")              ; compiled
: s\"          ( -- c-addr u )                        compile\$ postpone (s")             ; compiled
: ."           ( -- )                                 compile$ postpone type$             ; compiled
: .(           ( -- ) ( s: delim )                    ')' parse$ type$                    ;
: word         ( c -- c-addr u )                      -whitespace parse$
                                                      here dup 1+ unpack$
                                                      over c!                             ;

\ ----- pictured number conversion -----------------------

' prepend$ alias hold                                                                              inline
: holds$       ( -- ) ( $1 $2 -- $3 )                 swap$ join$                         ;        inline
: holds        ( c-addr u -- )                        pack$ holds$                        ;        inline
: sign         ( f -- ) ( $1 -- $2 )                  0< lest '-' hold                    ;
: #            ( d1 -- d2 )  ( string: $1 -- $2 )     base @  ud/mod
                                                      rot '0 +
                                                      dup '9 u> #39 and +
                                                      hold                                ;
' 2drop alias #>$                                                                                  inline
: <#           ( -- $1 )                              ""                                  ;        inline
: #s           ( d1 -- d2 )                           begin # 2dup or 0= until            ;
: #>type       ( d -- ) ( $1 -- )                     #>$ type$                           ;        inline
: #>           ( d -- )                               #>$ here here unpack$               ;
: udconvert    ( ud -- ) ( -- $1 )                    <# #s #>$                           ;
: dconvert     ( d -- ) ( -- $1 )                     tuck dabs udconvert sign            ;
: d.           ( d -- )                               dconvert type$ space                ;
: ud.          ( ud -- )                              udconvert type$ space               ;
: d.r          ( d u -- )                             >r  dconvert r> rtype$              ;
: ud.r         ( ud u -- )                            >r udconvert r> rtype$              ;

' drop alias x>$                                                                                   inline transient
' <# alias <x                                                                                      inline transient
: xs           ( d -- d )                             begin x dup 0= until                ;        transient
: x>type       ( x -- ) ( $1 -- )                     x>$ type$                           ;        inline transient
: x>           ( x -- a n )( $1 -- )                  x>$ here here unpack$               ;        transient
trash x

: uconvert     ( u -- ) ( -- $1 )                     <x xs x>$                           ;
: convert      ( n -- ) ( -- $1 )                     dup abs uconvert sign               ;
: .            ( n -- )                               convert type$ space                 ;
: u.           ( u -- )                               uconvert type$ space                ;
: .r           ( n u -- )                             >r  convert r> rtype$               ;
: u.r          ( u1 u2 -- )                           >r uconvert r> rtype$               ;

' have$ alias xt                                                                                   inline
' satisfy alias needs:                                                                             inline

\ produces execution token and removes header of last word:  : foo ... ; noname
: noname       ( -- xt )                              last$ dup$ xt   protect trash$      ;
: me           ( compile: -- )   ( run: -- x )        [ "xt" ] push,          literal,    ;        compiled
: needed       ( -- f ) ( stream: word )              word$ needed$                       ;        inline
: have         ( -- 0|xt ) ( stream: word )           word$ have$                         ;        inline      \ word exists?
: lack         ( -- flag ) ( stream: word )           have  0=                            ;        inline      \ word missing?
: [']          ( -- )   ( stream: word )              ' literal,                          ;        compiled



\ ----- unsorted -----------------------------------------

code random    ( -- u )                               "SRANDOM&true"             push,    ;code    inline      \  32 bits random number
code realtime  ( -- u )                               "${EPOCHREALTIME//[,.]/}&true" push, ;code   inline      \ a 51 bit microseconds epoch

: evaluate     ( c-addr u -- )                        pack$ evaluate$                     ;        inline
: quit         ( ??? -- )                             warm
                                                      begin
                                                         query$ evaluate$
                                                         resolve
                                                         prompt
                                                      again                               ;

"cold" primitive cold
' cold alias abort
: (abort")     ( ??? flag -- ??? | empty )            if type$ cr abort then drop$        ;
: abort"       ( -- ) ( s: string deliited by " )     '" parse$
                                                      postpone literal$
                                                      ['] (abort") compile,               ;        compiled
: ?abort       ( f -- )                               lest abort                          ;

\ ----- files and loading --------------------------------

' origin alias thisfile                                                                                        \ better symmetry with thisfile$

\ check whether current source had already been
\ compiled from before. most useful when used
\ interpretatively in a file, for testing whether
\ it will be or has been reloaded, such as with
\ "loaded lest done" returned u is the count
\ the file has been loaded.
code loaded    ( -- u )                               "loaded[filehandle]"       push,    ;code    inline

\ true: loading from file?,  false: interactive
\ (console). pipe or redirection is indicated as
\ loading from file.
code loading   ( -- flag )                            "linenr<0?false:true"      push,    ;code    inline
code #files    ( -- u )                               "${#files[@]}"             push,    ;code    inline

: once         ( -- )                                 loaded lest done                    ;                    \ prevent reloading file
: from         ( -- ) ( stream: filename )            word$ from$                         ;        inline
: thisfile$    ( -- )   ( -- $1 )                     thisfile filename$                  ;        inline      \ produce name of currently loaded file

\ ----- experiments --------------------------------------

done
omit
\ modify word name prior to header creation
\ background: let a word with "compiled" properties change header flags (issue 17)
: rather ( $1 -- )
       >body[0]="${ss[-1]}"
      drop$  ;
: foo  [ "bar" rather ]   me .name cr  ;
