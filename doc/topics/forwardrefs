TOPIC: forward references

By default will yoda not create forward references on its own, and behave
like any conventional Forth interpreter: You can execute or compile only
what is already present in the dictionary.

Still, forward references can be used without actually enabling them.
"Enabling" in this context means, allowing yoda to create forward references
to unresolved words itself.

Creating forward references manually used the word "need". Example:

   need hello

You'll notice now a new number in the "ok" prompt, between parenthesise.
That's the count of yet unresolved forward references.
Executing "words" shows a new category at the end, listing the still needed
words. "hello" should show there.  For showing only the names of unresolved
words, execute:

   .unresolved

While "hello" has still not been resolved, attempting to execute it still
produces an error.

A straightforward way to resolve "hello" now manually is to execute
"resolve":

   resolve

After pressing the Enter key, the number between parenthesises disappears,
indicating that all forward references have been resolved. Executing

   hello

confirms this.

Resolving also happens automatically sometimes. For example, after including
a file, using "from", will resolve get executed if any unresolved forward
references exist, in case the included files created any.

Another way to resolve a forward reference is to simply define it:

  need bar
: foo  bar  ;                 \ notice that bar can be compiled, though it doesn't exist yet.
                              \ that's because the compiler notices that it is a needed word.
: bar "this is bar" type$  ;  \ by defining "bar", the forward reference will be resolved.



The compiler can be instructed to accept unknown words as forward references
automatically, without us needing to mark those with "need".
To enable automatic forward references, set the variable "forwardrefs" to
a non-zero value:

   forwardrefs on

To turn automatic forward referencing off again, execute:

   forwardrefs off



Forward references can be created and resolved even while they're typed,
interactively. This needs enabling to. The variable for doing this is
called  "instantresolve":

   instantresolve on

Note that "forwardrefs" must be turned on too for instantresolve to have
any effect.

A forward referencable word from the library is "dump" ("hello" is now a
poor example because already present - you'd need to exit and restart
yoda in order to forget it again). With "instantresolve" on, create a
hex dump of a memory portion:

   $1000 $100 dump

While the memory contents, presumably all zeroes, aren't that interesting,
the fact that we were now able to run a definition which still needed loading
and compiling before being executed is. You possibly noticed a small delay
between pressing "Enter" and the hex dump showing - that's the time yoda
needed to find dump, then read and compile it prior to executing it.


A library meant for containing potentially unresolved words exists. It is
named "postlib" and included at the end. Definitions in there should all be
of conditional nature to avoid redefinitions, as postlib may get read
several times. Two kind of conditional compilation can be found in there:

- source compiling to code in case they're needed
- inclusion of other library files if they contain needed source.

For managing conditional compilation, these words exist:

      u:
      need
      needed
      resolve
      exists


u:       is almost identical with : but compiles the following word only if it's
         an unresolved forward reference (i.e. only when needed)

needed   can be used to test existence of a specific forward reference. A flag
         is produced, reflecting the result of the test.
         This flag can be conditionally responded to with flow control constructs
         like "lest" and "unless"

need     creates a forward reference explicitely. Rather than forward references,
         created by unknown words in code, these may have better use for signalling
         to postlib.

exists   check whether a word exists, return a flag reflecting this.

resolve  resolve against postlib. Don't wait for implicite resolving at the
         end of program loading, but do it now. This may be done multiple times,
         and in fact, it often is. For example, conditionally compiled words in
         postlib may create additional forward references, which are then resolved
         in an extra resolve pass.

         Therefore is this case legal:

main program:
               : foo fwd1 ;
               resolve
               foo

postlib:
               u: fwd3  "Hello, world!" type$  ;
               u: fwd2  fwd3  ;
               u: fwd1  fwd2  ;

Compilation may be slowed down slightly with this order of forward references, because
of the need of multiple inclusions of postlib:  when executing "resolve" in main program,
postlib will be included first time to resolve "fwd1". By conditionally compiling "fwd1",
the new forward reference "fwd2" will be created, causing a second inclusion run of
postlib, which now resolves "fwd2" - and thereby creating "fwd3" forward refernce.
Consequently will the need of yet another inclusion run be detected, and only after
this third inclusion will headers count have stabilized.
Changing the sequence to  fwd1, fwd2, fwd3 results in a single inclusion resolving
all forward references.


Yet another place where forward reference may be created automatically, regardless
whether enabled or not, is when setting a cold start vector at the end of a source
file, using the word "boot". The specified word to boot may be forward referenced
too, and resolving attempt will take place upon completion of file loading.
