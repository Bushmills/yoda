
: .byte ( c -- )  <# # # #>type space ;

\ output u hex bytes at a
: .bytes ( a u -- )
        for
           count .byte
        next drop ;

\ output single char. replace non-printables against dot
: emitsave ( c -- )
        dup
        bl < if
           drop '.'
        then emit ;

\ output u chars at a. could have used "type" if it was control char safe.
: .chars ( a u -- )
        for
           count emitsave
        next drop ;

\ single line hexdump of u bytes at a. returns next yet undumped address
: dumpline ( a1 u -- a2 )
        over u. 2 spaces
        2dup .bytes space
        2dup .chars +  ;

: dump  ( a n -- )
        base @ >r hex                \ save current number base, change to hex
        >r dup $f invert and         \ let address begin at 16 byte boundary
        tuck - r> +                  \ correct count of bytes to output accordingly
        #15 + #16 /                  \ determine number of lines to output
        for
           #16 dumpline cr           \ loop through lines
        next drop
        r> base !  ;                 \ restore former number base




: .cell     ( u -- )
         <#  bits 3 + 2 >>
         for # next
         #>type space ;

: .cells    ( a u -- )
         for
            skim .cell
         next drop ;

\ single line hexdump of u cells at a. returns next yet undumped address
: wdumpline ( a1 u -- a2 )
         over u. 2 spaces
         2dup .cells space +  ;

: wdump  ( a n -- )
         base @ >r hex                 \ save current number base, change to hex
         #72 bits 3 + 2 >> 1+ /    \ number of cells per line
         -rot pluck 1- +
         pluck /                       \ determine number of lines to output
         for
            over wdumpline cr          \ loop through lines
         next 2drop
         r> base !  ;                  \ restore former number base

