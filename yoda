#!/bin/bash

# ----- about -------------------------------------------- #fold00
# yoda is an acronym of Yet Onather Delirious Application, and does
# naturally not refer to any greenish midget with pointy ears, albeit
# it had been said that reading yoda source aloud sounds like the very
# same midget talking.
# yoda implements a compiler which converts a close resemblance of Forth
# source code to bash functions, an interpreter which runs them, and
# a base vocabulary of useful functions, strongly orientated towards
# what a common Forth interpreter offers.
# What learned you have, unlearn you must!

# editor used is efte, folds in source files are therefore efte compatible.

# ----- versions ----------------------------------------- #fold00
# invoke shellcheck with:    shellcheck -x yoda.
# shellcheck disable=SC2016 disable=SC2034 disable=SC2154
# SC2016: "expressions don't expand between single quotes"
#         right, that's the reason for using single quotes there.
# SC2034  "... appears unused. Verify use (or export if used externally)"
#         in most cases is "appears" the correct term.
# SC2154 "(warning): base is referenced but not assigned."
#        is assigned, but shellcheck can't see how


# times in UTC
# dates in post-gregorian Sol3
# numbers in decimal. Mostly.
v="0.6.4"   # 2022feb12,00:02    : is stateless, therefore compilable. Preparing for vocabularies.
# v="0.6.3"  # 2022feb10,02:35   combined two arrays sourcefile and sourceline into single source
#                                renamed former misnamed analyser flag "literalnumber" to push. added 2exchange, removed 2+, 2-
#                                abort and ?abort are now silent. j inlines. version stamped dependencies, new version of yoda will
#                                generate new dependencies file.
# v="0.6.2"  # 2022feb08,21:03   source locations are correct again: defining words inject a pseudo op with file handle, line number as
#                                parameters. postprocessing will use those after header creation to set proper source data.
#                                last is still updated during header creation, and contents will be wrong when read during compilation
#                                of a word, as it will still refer to previous word. probably. Wrong, anyway. Would need defining words
#                                to update last, rather than the postponed header word. Come to think of it, keeping update of last in
#                                postponed header, and then in additionally just in colon should do. Alternatively, move it from postponed
#                                header to code injecting the header creating pseudo op.
#                                Done so now:  last is updated in delayheader, the word which inject header creation pseudo op. header,
#                                which do so before, isn't involved in updating last any longer.
#                                returned[] removed again, in favour of functions returning results in variables of same name as functions.
#                                filehandle,line number in where pseudo op arg now seperated by : rather than by space.
# v="0.6.1"  # 2022feb06,20:23   late headers: headers aren't created by defining words like create, variable, constant, : but instead
#                                by semicolon. defining words merely place word name and analyser flag into code buffer, expecting
#                                detokeniser to do header creation. Consequence ist that for words failing compilation no headers are
#                                created at all, which eliminates a potentially needed hide/reveal scheme to exclude words from being
#                                found as long compilation hasn't finished successfully. On the down side is source location now
#                                recorded as the line containing the semicolon. There's a workaround possible, but hasn't been coded for
#                                this version.
# v="0.6.0"  # 2022feb01,21:11   create$ constant$ variable$ array$ like their non-$ counterparts, but taking names from string stack
#                                instead of from input stream. Removed crossref. realtime seperator can be . or ,
#                                config in home dir has priority over config in yoda dir, which may be overwritten by git pull
# v="0.5.9"  # 2022jan28,14:22   added transient, which marks header of last word as to dispose of after file was loaded. Changed
#                                moved experimental cleanup scheme to semicolon, renamed it "conclude"
#                                "from" accordingly. Transient headers are local to the file they were defined in.
#                                context words (compiled, interpreted) can't be transient.
#                                uppercase$, lowercase$, othercase$, uppercase1$, lowercase1$, othercase1$, added
#                                loading added
# v="0.5.8"  # 2022jan26,12:16   deferred query$, removed attributes from rename simplequery$. Hi-level .s outputs items as signed
#                                numbers. Fixed pick. Added literal$. needed takes whole line as argument list now.
#                                added have$ trash$, factored have, added word for emptying rstack, which was added to _
#                                removed hardcoded ANSI/VT100 terminal escape sequences, replaced against terminal specific
#                                sequences generated by tput.
# v="0.5.7"  # 2022jan24,02:01   satisfy adds word to forward references, allowing words operating with need to work with satisfy
#                                created forward references too. removed resolve from end of from, added resolve to quit, executed
#                                prior to prompt. satisfy doesn't turn on forward references any longer, which means that libraries
#                                may need improved discipline to indicate their dependencies.
# v="0.5.6"  # 2022jan22,20:15   added defer, is
#                                prompt is now a deferred words
#                                changed dependencies file format. paths are relative to libdirs[0] now
#                                moved code dealing with shell on to evaluate
#                                result producing functions return those in array ${returned[@]} rather than in arbitrary variables
#                                yoda internal prompt is now very minimal. A functional equivalent of the former full featured prompt
#                                has been created as library file.  execute  "satisfy newprompt" to compile and activate it.
#v="0.5.5"   # 2022jan21,13:36   made instantresolve independent from forwardrefs.
#                                instantly resolving utilises satisfy instead of need now, and has been turned on by default.
#                                consequence is that unknown words, entered while interpreting, will be loaded from library,
#                                compiled, then executed, behaving as they had been in the dictionary all along.
#                                unknown words during compilation fall now under jurisdiction of need/resolve while dealing with
#                                interpret time unknowns is delegated to satisfy (though resolve utilises satisfy too). Consider
#                                satisfy as an immediate response to requesting unknown words, while need produces a delayed response
#                                (delayed until execution of resolve, or until word was defined)
#v="0.5.4"   # 2022jan20,16:00   dependencies are cached, always. dependency file is
#                                generated if non-existent. strings got sdp, here$, allot$
#                                sanitising filenames helped removal of GLOBIGNORE
#v="0.5.3"   # 2022jan19,20:28   dependencies can be cached, therefore served from memory
#                                sanitising doc, undoc, about file names.
#v="0.5.2"   # 2022jan17,15:00   dropped logging, added shell$.
#v="0.5.1"   # 2022jan17,12:25   dependency base resolving. dropped postlib, topics
#v="0.4.2"   # 2022jan14,14:47   one based files with tty as 0
#v="0.4.1"   # 2022jan12,04:03   early version of automated testing.
#                                converted many colon to primitive. literal became push.
#v="0.4.0    # 2022jan10,04:13   pulled yoda and primitives together into a single file
#v="0.3.0    # 2022jan07,22:31   any data item can be ticked now, so can words created by defining word using create ... does>
#v="0.2.0    # 2021dec29,16:04   compiles Game of Life demo
#v="0.1.0    # 2021dec20,14:57   does what you can expect of a 0.1 version.

read -ra version <<< "${v//./ }"


# ----- declarations ------------------------------------- #fold00

shopt -s extglob
shopt -u nullglob

config="yoda.conf"                                                   # name of configuration file which may override any of the below settings
break=2                                                              # break will return (0), exit (1) or execute coldvector (2)
clean=1                                                              # empty stack on error/ctrl-c
codedump=0

read -r tmp _ < <(realpath "$0")
mydir="${tmp%/*}"
doc="$mydir/doc"                                                     # documentation base directory
worddoc_prefix="word"                                                # used as part of file names, prevents files to go hidden by leading period
worddoc="$doc/words/$worddoc_prefix"                                 # directory of words documentation, also first part of word doc file name
dependencies="$mydir/dependencies"                                   # dependency file, path and name

# only first added directory - and its subdirectories -
# contain forward referencable libs.
libdirs=()                                                           # array of possible library paths
for dir in                          \
   "$mydir/lib"                     \
   "$mydir"                         \
   "/usr/local/lib/yoda"
do                                                                   # loop through directory candidates
   [[ -d "$dir" ]] && libdirs+=("$dir")                              # add directory if existing
done

functionname_prefix="yoda"                                           # prefix to bash function names,  _${xt} will be appended upon header creation
xt="1000"                                                            # names enumeration, initially. Can be any positive integer

declare -ai r=() s=() m=()
declare -i sp=0 rp=0 dp=0 sdp=0
declare -a ss=()
declare -a strings=()                                                # an array for strings.
declare -i s1 s2 s3 s4                                               # temp variables to hold stack items s[-1] ... s[-4]
                                                                     # easier to read than "tmp, tmp2"
declare -Ai flags                                                    # header flags (only inline left for now)
declare -A doescode                                                  # items associated with defining word. Detokeniser extracted code

# built-in vocabularies
declare -A "only"
declare -A "forth"
declare -A "interpretonly"
declare -A "compileonly"

declare -a wordlists
wordlists=("only" "forth")                                           # last voc is context

declare -a names                                                     # function name -> word name lookup
declare -A unresolved                                                # forward referenced. Not searched.
declare -a transient                                                 # transient headers.
declare -A where                                                     # file:line of source
declare -A lib                                                       # cache dependencies

filehandle=1                                                         # 1=yoda. 0=tty.  >1=loaded source
declare -a files=("tty")                                             # list of included files
declare -a loaded                                                    # list of inclusion counters for included files

declare -a conclude=()                                               # compiler words can add actions to array conclude, which
                                                                     # will be executed when semicolon executes
declare -a lasterror
lasterror=("" "-1" "0")


# header flags:
flagscount="0"
newflag()  { (( $1 = 1<<flagscount++ )); }
newflag inline
newflag functionheader                                               # create header
newflag atomiccode                                                   # expand
newflag push                                                         # generate code pushing a cell
newflag flowcontrol                                                  # help recognise optimisation boundaries
newflag optimisationboundary
newflag literalstring                                                # probably unnecessary
newflag inlined                                                      # probably useless
newflag does                                                         # probably useless
newflag sourcelocation

# when stack effect of words is known to optimiser, it will have
# the possibility to determine whether stack items cached in
# variables can remain and passed in there, rather than pushing
# them out to stack, only to be retrieved again by next word.
declare -A stackin=()
declare -A stackout=()
declare -A atom=()                                                   # a table with token -> code mappings.

# what to execute when no command line args given
default='from defaults'                                              # load defaults from file

# number of bits per cell.
# one address increment is always a cell, this setting
# won't change that.
bits=63                                                              # Can't use 64 bit - bash doesn't know unsigned. 63 bit is best I can do for now.
#bits=48                                                              # 0...281,474,976,710,655
#bits=32                                                              # 0...4,294,967,295
#bits=21                                                              # covers 6 decimal digits signed numeric space
#bits=20                                                              # 20 bits, unusual but not impractical. 8086 address space
#bits=16                                                              # 16 bits, a tad retro
#bits=11                                                              # covers 3 decimal digits signed numeric space
#bits=8                                                               # 8 bits are nice for testing

msb="$((1<<(bits-1)))"
maxint="$((msb-1))"
maxuint="$((maxint|msb))"
true="$maxuint"
false=0

compiling="$false"                                                   # state flag: interpreting or compiling
line=""                                                              # source line being worked on. modified during parsing and processing
word=""                                                              # bl delimited string from line currently being processed
lastword=""                                                          # most recently created word, set by create.

# xeditor runs detached from yoda process and doesn't block input
# therefore an xeditor should open its own window
editor="vi"
#xeditor="efte"
[[ -n "$editor" ]]  && editor()  { $editor "$@"; }                   # used with doc, edit
[[ -n "$xeditor" ]] && {
   editor()  { $xeditor "$@" & }                                     # used with doc, edit
   editor="$xeditor"
}

magic=100000
remagic()  { ((magic+=RANDOM+10000)); }
remagic

declare -A asc=()                                                    # ascii table
declare -a char=()                                                   # character table
for i in {1..255}; do                                                # ascii->char LUT for emit, pack$, char$
   char[i]="$(echo -en "\\x$(printf "%x" "$i")")"
   ((i == 10)) || asc["${char[i]}"]="$i"                             # linefeed is invalid hash key
done

# ----- diagnostics  ------------------------------------- #fold00

comp=("" ":")

trace()  {
   printf "### %-1s %-20s %s\n" "${comp[compiling & 1]}" "[${FUNCNAME[1]}]" "$@"
#                                                  ^^^  convert any non-zero to 1, used as array index
}

pretend()         { echo "${FUNCNAME[1]} pretends to $*"; }          # placeholder for use in unfinished code


# ----- headers ------------------------------------------ #fold00

#setheaderflag()  { (( flags["$lastword"] |= "$1" )); }              # a bash glitch doesn't allow me to use this form, because it produces errors with
                                                                     # some array keys like "'".
setheaderflag()  {                                                   # where against this form has no problem with those,
   flags["$lastword"]="$(( ${flags["$lastword"]} | "$1" ))"
}

inline()     { setheaderflag "$inline" ; }

# move header to compiler context vocabulary
compiled()  {
   compileonly["$lastword"]="${forth["$lastword"]}"
   unset -v 'forth["$lastword"]'
}

# move header to interpreter context vocabulary
interpreted()   {
   interpretonly["$lastword"]="${forth["$lastword"]}"
   unset -v 'forth["$lastword"]'
}


compiler_init()  {
   body=()
   analyser=()                                                       # reinitialise code tags for analyser
   target=()
}

# create header, but don't compile, and don't generate function yet.
# compiling (that is, creating a bash function) is left to
# semicolon, calling compile won't detect redefinition if word was
# moved to context vocabulary
# arg1: word name
# arg2: function name
# not allowed to generate function names because some names want
# to be determined by caller
# NOTE: leave it to header to prepend $functionname_prefix.
header()  {
   lastword="$1"                                                     # global variable. setting header flags needs this one
   [[ -z "${forth["$1"]}" ]] || echo "redefining $1"
   forth["$1"]="$2"                                                  # associate word with name
   flags["$1"]="0"                                                   # default to no flags
}


# ----- detokeniser / pretend optimiser ------------------ #fold00
# currently only a detokeniser. Plugged preparing further use.
# The way it works:
#    when a word gets compiled to a function, it will first be
#    cached in an array "body". semicolon then calls compile,
#    which generates a bash function from body.
#    first thing compile does is calling optimise, which visits
#    all items in body, potentially modifies or substitutes them
#    while transferring to an array named target.
#    compile then creates the bash function from target, which
#    at that point is expected to contain literal code only.
#    Compiling words which add to body array can tag entries,
#    informing optimiser/detokeniser about their nature, so it
#    can respond in an appropriate way to body array entries.


# return a new function name in variable name
# arg1:word
name()  {
   names[xt]="$1"                                                    # keep word name for .name, name$
   name="${functionname_prefix}_$((xt++))"                           # grab new xt, make a function name from it
}


# arg1: code token, arg2: code token type (opt)
code()  {                                                            # instruction stream injector
   body+=("$1")
   analyser+=("${2:-0}")                                             # default to literal code
}


where()  {
   code "$1:$2" "$sourcelocation"
}

# doesn't actually do any optimizing.
# Function is limited to:
# - expanding atoms
# - generating code pushing literals
# - dealing with does>
# - postcompile creation headers
optimise()  {                                                        # run code generator on ${analyser[@]} data
   ((${#body[@]}==${#analyser[@]}))||echo "body/analyser<>1"
   target=()
   dodoes_at=0
#   corresponding=()                                                 # index array source line to target line.
   ((codedump))&& {
      echo ": $lastword"
      for ((tmp=0; tmp<${#body[@]}; tmp++)); do
         printf "%2d %-5s %s\n" "$tmp" "${analyser[tmp]}" "${body[tmp]}"
      done
      echo "------------------------------------------------"
   }
   for ((tmp=0; tmp<${#body[@]}; tmp++)); do
#      corresponding[tmp]="${#target[@]}"                            # allow optimiser to locate target code for any source line.
      bodyline="${body[tmp]}"
      bodyflag="${analyser[tmp]}"
      targetline="$bodyline"                                         # Default action: pass through
      if (( bodyflag )); then                                        # flags: examine
         if (( bodyflag & functionheader )); then                    # test attempting to delegate header creation to detokeniserr
# late headers: defining words don't create headers, but pass
# word name with analyser flag "dunctionheader" to optimise.
# It's upon detokeniser to create header, which it is doing here and now.
# NOTE: functional but ugly. Needs some taking care of here
            word="$bodyline"                                         # word name of new word
            name="${unresolved[$word]}"                              # if forward ref, reuse function name of forward ref
            if [[ -z "$name" ]]; then
               name "$word"                                          # not a forward ref: invent new name
            else
               unset -v "unresolved['$word']"                        # going to resolve word, remove from forward refs
            fi
            header "$word" "$name"                                   # create new header
            continue
         elif (( bodyflag & sourcelocation )); then                  # source location: set
            where["$lastword"]="$bodyline"                           # remember source location
            continue
         elif (( bodyflag & atomiccode )); then                      # atomic code: expand
            targetline="${atom[$bodyline]}"
         elif (( bodyflag & push )); then                            # generate code pushing the number
            targetline="((s[++sp]=$bodyline))"
         elif (( bodyflag & does )); then                            # does>
            dodoes_at="$((${#target[@]}+1))"                         # remember end of target for splitting code (but only when whole word
         fi                                                          # was compiled - we want to rip out all the run time code, after all.
      fi
      [[ -z "$targetline" ]] || target+=("$targetline")
   done
   ((dodoes_at)) && {
# in raw code was a does> encountered: split generated code in
# two parts. first part is compiled to defining word, second part
# is seperated to an array item associated with defining word.
# dodoes, when executed, knows how to retrieve and
# compile that code to defined word.
# a workaround is needed here too:  create ... does> ;   does without following code will let bash run into an empty function,
# which bash doesn't like, and complain about.  Therefore this condition is caught here and acted upon.
     if (( ${#target[@]} > dodoes_at )); then                        # everything ok: there was code between does> and ; - extract and store it.
        doescode[${forth[$lastword]}]=$(printf "%s\n" "${target[@]:$dodoes_at}")
        target=("${target[@]:0:$dodoes_at}")
     else                                                            # but does> without code ...
        unset "target[-1]"                                           # will cause to compile without any does run time action. no code behind does>
     fi                                                              # would result in no action at all, therefore the whole does> can be dropped too.
   }
}

# ----- line parser -------------------------------------- #fold00

# these need extglobs, set with "shopt -s extglob"

# read space delimited word from line without removing it.
peek_word()  {
   word="${line##+([[:space:]])}"                                    # remove all leading spaces (needs extglobs)
   word="${word%%[[:space:]]*}"                                      # bl lookahead
}

# read space delimited word from line, remove it,
# remove single leading space from remainder of line.
word()  {
   peek_word
   line="${line#*"$word"}"                                           # quotes around word are needed
   line="${line#+([[:space:]])}"                                     # remove single leading space (n
}

# read string from line and remove it, also remove delimiter.
# delimiter passed as arg1.
# leading spaces aren't removed from remainder of line.
parse()  {
   word="${line%%"${1}"*}"
   [[ -z "$1" ]] && word="$line"
   line="${line#"${word}"}"
   line="${line#"$1"}"
}

# ----- compiler ----------------------------------------- #fold00


# atoms may be:
#  - micro instructions
#  - single instructions
#  - primitives
# those can describe their effects more easily to the optimiser,
# enabling it to combine and remove them to target code.
# in addition are meta directives allowed:
#  - compile time instructions for word creation, such as header building

atom()  {
   [[ -z "${atom[$1]}" ]] && error "no atomic $1"
   code "$1" "$atomiccode"; }                                        # insert into code buffer, mark as atom


codebody()  {                                                        # inline compiler
   while read -r tmp; do
      [[ "${tmp:0:1}" == "{" ]] &&
      while read -r tmp; do
         [[ "${tmp:0:1}" == "}" ]] && break
         code "$tmp" "$inlined"
      done
   done < <(type "$1")
}

# rewrite run time semantics of most recently defined word
# arg1: new run time code.
use()  {
   name="${forth["$lastword"]}"                           # rewrites function "$name",
   eval "$name() { $(printf '%s\n' "$@"); }"                         # using instructions received as arguments
}

compile()  {
   optimise                                                          # rewrite ${body[@]} to ${target[@]}
   use "${target[@]}"                                                # generate function from $target[@] with name of $lastword
   compiler_init
}

# execute or compile args. Similar to invoke,
# maybe one of these can be eliminated.
stateless()   {
   if ((compiling)); then
      code "$@"
   else
      eval "$*"
   fi
}


# ----- defining words ----------------------------------- #fold00


# make stack effect of word known, aiding the optimiser
inout()  {
   stackin["$lastword"]="$1"
   stackout["$lastword"]="$2"
}


push()  {                                                            # leave it to detokeniser to generate code
   code "$1"   "$push"                                               # only insert value or expression, mark it.
}



# variable last doesn't exist yet, but is used in header, and
# can't be defined earlier, because defining it calls header.
# remedy: remember here, allot cell, define it as constant later.
((last=dp++))

# arg1: wordname
# arg2: filehandle
# arg3: line number
delayheader()  {
   [[ -z "$1" ]] && emptyname
   compiler_init
   code "$1" "$functionheader"
   m[last]="$xt"
   [[ -z "$2" ]] || where "$2" "$3"
}

nowheader()  {
   delayheader "$1" "$2" "$3"
   optimise
}


# primitive "wordname"  "functionname|code"
primitive()  {
   nowheader "$1" "$filehandle" "${BASH_LINENO[0]}"
   use "$2"
   inline
}

colon()  {
   tmp="${BASH_LINENO[0]}"                                           # assume not evaluate
   (( filehandle == 1 )) &&                                          # if defined in yoda
   [[ "${FUNCNAME[3]}" == "evaluate" ]] &&                           # by evaluate
   tmp="${BASH_LINENO[3]}"                                           # then take line number from different entry
   delayheader "$1" "$filehandle" "${linenr:-$tmp}"
}

# arg1: add action for semicolon to execute to conclude[@]
conclude()  { conclude+=("$@"); }

semicolon()  {
   for ((nextconclude=0; nextconclude<${#conclude[@]};nextconclude++)); do
      eval "${conclude[nextconclude]}"
   done
   conclude=()
   compile                                                           # compilation is gathered in an array body. Only
   compiling="$false"                                                # when semicolon completes compilation, is
}                                                                    # a function created from contents of array.


constant()  {
   delayheader "$1" "$filehandle" "${linenr:-${BASH_LINENO[0]}}"
   push "$2"
   semicolon
   inline
   inout 0 1
}


# initialized with 0 or optional arg2
variable()  {
   (( "$1"="$dp" ))
   m[dp]="${2:-0}"
   delayheader "$1" "$filehandle" "${linenr:-${BASH_LINENO[0]}}"
   push "$((dp++))"
   semicolon
   inline
   inout 0 1
}


variable 'shell'              "0"
variable 'forwardrefs'        "0"
variable 'instantresolve'     "1"
variable 'callstack'          "0"
variable 'base'               "10"

constant 'maxuint'            "$maxuint"
constant 'maxint'             "$maxint"
constant 'msb'                "$msb"
constant 'true'               "$true"
constant 'false'              "false"
constant '0'                  "0"
constant 'esc'                "27"
constant 'bl'                 "32"
constant 'bits'               "$bits"
constant 'last'               "$last"


# arg1: deferred word
# arg2: initially deferred to, word name
# example:  defer 'foo'  'bar'
defer()  {                                                           # use in yoda source
   delayheader "$1" "$filehandle" "${linenr:-${BASH_LINENO[0]}}"
   push "$((dp))"
   semicolon
# NOTE: instead of use, code could be compiled through "code", then leaving it to above semicolon to create whole word
   use "${functionname_prefix}_\${m[$dp]}"
   ((m[dp++]="${forth[$2]##*_}"))
   inline
   inout 0 1
}



# ----- errors, traps, entry points----------------------- #fold00

warm()  {
   filehandle=0                                                      # 1=yoda. 0=tty.  >1=loaded source
   line=""                                                           # signal to evaluate to stop evaluation of current line
   linenr="-1"                                                       # signal to from to stop sending more lines to evaluate
   compiling="$false"                                                # interpret
   error=0
   r=() rp=0
   ((sp<0)) &&s=() sp=0                                              # always clear stack underflow
   ((clean))&&s=() sp=0 ss=()                                        # empty stacks
   m[base]="10"                                                      # set decimal if base exists
   compiler_init
}

coldvector=""                                                        # colon word "boot" assigns coldvector. started when compilation completed.
cold()  {                                                            # also by running cold. error restarts interpreter at cold
   [[ -z "$coldvector" ]] && exit 1
   warm
   $coldvector
}

callstack()  {
   printf "%s: " "Call stack"
   printf "%s " "${FUNCNAME[@]:5:${m[callstack]}}"                   # remove callstack and error from output
   printf "\n"
}


read -r redbg  < <(tput setab 1)
read -r normal < <(tput sgr0)

error()  {
#           >--<                                             >----<      error word
   printf "%s%s %s\n" "${tib%"${word}"*"${line}"}" "${redbg}${word}${normal}" "$line"
   printf 'ERROR: %s\n' "$@"
   row=$((${#tib}-${#line}-${#word}))
# NOTE: passing file name in lasterror - could pass file handle instead
   lasterror=("$file" "$linenr" "$row")
   (( linenr < 0 )) || printf "at %s of %s\n" "$linenr,$row" "$file"
   ((m[callstack]))&&callstack
   cold
}

declare -a errortext
nexterror=0

errornr()   {
   error="$1"
   shift
   error "${errortext[error]} $*"
}

# a somewhat wild construct, sort of attempting
# to emulate Forth's create ... does> here. I'm
# surprised that shellcheck finds this acceptable
newerror() {
   (( "$1" = nexterror ))                                            # assign new error number to error name
   eval "$1()  { errornr \"$1\" "\"\$*"\"; }"                        # synthesise error function with error name
   shift
   errortext[nexterror++]="$*"                                       # associate error message with error number
}

newerror "noerror"         "no error"
newerror "emptyname"       "no or empty name"
newerror "stackunderflow"  "stack underflow"
newerror "notfound"        "not found:"
newerror "nosource"        "no source for"
newerror "stillcompiling"  "still compiling after"
newerror "unbalancedstack" "unbalanced stack in file"
newerror "unstructured"    "unstructured: missing"
# newerror "abort"           "abort"
newerror "shellerror"      "shell returned"
newerror "filenotfound"    "file not found:"


ctrl-c()  {                                                          # "break" is configurable item to control
   printf "%s\n" "break"                                             # how yoda responds to break signal.
   ((break == 1))  && exit 1                                         # This is due to not having a clean
   ((m[callstack]))&& callstack                                      # warm start procedure.
   ((break == 2))  && cold
}
trap ctrl-c SIGINT

#err()  { echo "error trap:  $word ${FUNCNAME[1]}"; }
# trap err ERR
# ----- patterns ----------------------------------------- #fold00

# wondering whether a case statement would make this look any better
declare -A bases=(['%']=2 ['#']=10 ['$']=16)
pattern()  {                                                         # pattern interpreted as
   ((radix=m[base]))
   tmp="0123456789abcdefghijklmnopqrstuvwxyz"                        # cut legal chars for base
   [[ $word =~ ^[${tmp:0:$radix}]+$ ]] && {                          # 1234      unsigned number
      stateless "((s[++sp]=$((${radix}#${word}&true))))"             # convert signless numbers without special treatment
      return 0; }
   [[ $word =~ ^-[${tmp:0:$radix}]+$ ]] && {                         # -1234     negative number
      stateless "((s[++sp]=$((-${radix}#${word:1}&true))))"
      return 0; }
   [[ ${word:0:1} == [%\$\#] ]] && {
      radix="${bases[${word:0:1}]}"                                  # yes: read radix associated with char
      [[ ${word:1} =~ ^[${tmp:0:$radix}]+$ ]] && {                   # remainder of number all legal chars?
         stateless "((s[++sp]=$((${radix}#${word:1}&true))))"        # yes: convert from base and deal with it
         return 0; }; }
   [[ ${word} == \'? || ${word} == \'?\' ]] && {                     # 'X bzw 'X' return ASCII - easier on editor syntax highlighting
      read -r tmp < <(printf "%d" "'${word:1:1}'")
      stateless "s[++sp]=\"$tmp\""; return 0; }
   [[ ${word} == ^[a-zA-Z\[] ]] && {                                 # ^X        return control char
      read -r tmp < <(printf "%d" "'${word:1:1}")
      stateless "s[++sp]=\"$((tmp&31))\""; return 0; }
   [[ "${word:0:1}${word:0-1}" == '""' ]] && {                       # quoted string, single word
      (( ${#word} > 1 )) &&  {                                       # prevent false matches with leading spaces where a single " is both 0:1 and 0-1
         ((compiling)) && {                                          # arg for compile differs with quoting, to make strings like $1 $2  literal
            code  "ss+=('${word:1:${#word}-2}')"                     # But variable expansion take place in interpreted branch.
            return 0; }                                              # Both requirements are hard to formulate in one common version.
         ss+=("${word:1:${#word}-2}")
         return 0; }; }
   [[ "${word:0:2}" == '#!' ]] && {                                  # #!        ignore hashbang
      line=""; return 0; }                                           # only relevant when loading hashbang file with from. OS doesn't pass hashbang line
   [[ "${word:0:1}" == \" ]] && {                                    # quoted string, multiple words (single words already dealt with)
      tmp="${word:1}"                                                # strip leading " from first word
      parse '"'                                                      # parse rest of line for closing quotes
         ((compiling)) && {
            code "ss+=('$tmp $word')"                                # compile: compile code to add string to string stack
            return 0; }
         ss+=("$tmp $word")                                          # interpret push string to string stack
         return 0; }
   [[ "${word:0:1}" == '>' ]] && {                                   # >foo...                   execute a shell command
      tmp="${word:1}"                                                # >foo... ->  foo...
      if [[ ${tmp:0-1} == ";" ]]; then                               # semicolon attached to command
         tmp="${tmp%;}"                                              # foo; -> foo
      elif [[ "$line" == *';'* ]]; then                              # semicolon space seperated from command
         parse ';'                                                   # parse input until ;
         tmp+=" $word"
      else                                                           # no semicolon at all
         tmp+=" $line"
         line=""                                                     # and removed from further evaluation
      fi
      stateless "$tmp"                                               # execute or compile the parsed shell command
      return 0; }
   return 1
}


# ----- resolve forward refs ----------------------------- #fold00

# total headers count is used to help determining if resolving
# forward refs create new forward refs, in which case resolving
# will be repeated.
totalheaders()  {
# NOTE: change to take account of all vocabularies
   (( totalheaders =
         ${#forth[@]}
       + ${#compileonly[@]}
       + ${#interpretonly[@]}
       + ${#unresolved[@]}
   ))
}


# create a forward ref by the name of arg1
forwardref()  {
   [[ -z ${unresolved["$word"]} ]] && {                              # don't re-forwardref and already forward ref'ed word
      name "$1"                                                      # generate new function name
      unresolved["$1"]="$name"                                       # keep in unresolved vocabulary
   }
}

# satisfy one single reference, passed as arg1.
# tries by loading source immediately if available.
# if source isn't available, a forward ref will be generated.
satisfy1()  {
   [[ -z ${forth[$1]} ]] || return 0                                 # word already defined, nothing to do
   local word="$1"
   [[ -z "${lib[$word]}" ]] || {                                     # library of needed word known?
      forwardref "$word"                                             # yes: create forward ref only
      tmp="${libdirs[0]}/${lib["$word"]}"                            #      path and name of lib file
      ((${#body[@]})) && return 1
      [[ -f "$tmp" ]] && from "$tmp"                                 #      load if file exists
      return 0
   }
   return 1
}

resolving=0
# looping resolve until header count stabilised.
# doing so because resolving forward references may create
# new forward references, which also need resolving.
resolve()  {
   (( ${#unresolved[@]} )) || return                                 # only run if unresolved words exist
   ((resolving)) && return                                           # nesting into resolve doesn't get any more work done -
   local file                                                        #   we'll resolve anything open, or we don't, no matter
   local resolving=1                                                 #   how often resolve calls itself. This would only slow down
   previousheaders="-1"
   totalheaders                                                      # total headers count before inclusion
   until (( totalheaders == previousheaders )); do                   # loop until header count stabilises
      previousheaders="$totalheaders"
      for word in "${!unresolved[@]}"; do                            # try to resolve all in unresolved vocabulary
         satisfy1 "$word"                                            # satisfying a word can create new forward references
      done
      ((${#unresolved[@]})) || break                                 # no forwardrefs left: done
      totalheaders                                                   # total headers count now, after inclusion
   done
}


# ----- line interpreter, evaluate------------------------ #fold00

# text compiler and interpreter, the so-called outer interpreter

# do a single word, which has already been found.
# must still figure out run- or compile time action,
# arg1: word
# arg2: name found
invoke() {
   ((compiling)) || { $2;  return; }                                 # not compiling: execute function
   ((${flags["$1"]}&inline)) && { codebody "$2"; return;  }          # inline:     compile function body
   code "$2"                                                         # not inline: compile call to function
}

# interpret/compile the line passed as argument
# in here most compiling and interpreting work is done.
# time to split this thing up.

evaluate()  {
   local line="$*"                                                   # line may get modified, and that must be. some words depend on being able to change it,
   local tib="$line"                                                 # tib remains unaffected unless explicitely modified (query et al), For nesting evaluate
   until [[ -z "$line" ]]; do                                        # still more to process on line (parsing removes strings from line)
      ((error | (sp<0)))&&break
      word                                                           # parse white space delimited word
      [[ -z "$word" ]] && continue                                   # empty: tabs, line end, nothing of substance

# preparing for vocabularies
# already searching through all vocabularies in wordlists
      for ((wordlist=${#wordlists[@]}; wordlist;)); do
         declare -n headerscontext="${wordlists[--wordlist]}"
         [[ -z "${headerscontext["$word"]}" ]] || {                  # word found in next vocabulary  of voclist
            invoke "$word" "${headerscontext["$word"]}"              # compile or execute
            continue 2
         }
      done

      if ((compiling)); then                                         # word wasn't found. search state specific vocabularies
         [[ -z "${compileonly["$word"]}" ]] || {                     # found in in compileonly while compiling
            ${compileonly["$word"]}                                  # word in there are inherently "immediate", therefore they're executed here
            continue                                                 #     because that also deals with inline compilation.
         }
         [[ -z "${unresolved["$word"]}" ]] || {                      # found in unresolved while compiling
            code "${unresolved[$word]}"                              # compile it
            continue
         }
      else                                                           # interpreting
         [[ -z "${interpretonly["$word"]}" ]] || {                   # word found in interpretonly
            ${interpretonly["$word"]}
            continue
         }
      fi
      pattern "$word" && continue                                    # not found yet: try patterns (numbers, strings, chars, hashbang, shell commands)
      (( m[forwardrefs] )) && {                                      #     and forward references enabled ...
         ((compiling)) && {                                          # still not successfully dealt with word. last resolve: in case of compiling ...
            forwardref "$word"  "$lastword"                          #     create a forward reference.
            code "${unresolved["$word"]}"                            #     compile dangling call to unresolved name. (tag as forward ref call for optimiser?)
            continue                                                 # hope that it will eventually get resolved
         }
      }
      (( m[instantresolve] && ! compiling)) && {                     # interpret time forward references enables?
         satisfy1 "$word" && {                                       # attempt to load word
# NOTE: must run from current voc (or voc satisfy1 has
#       compiled into. This may be another voc than forth
            ${forth["$word"]}                                        # successful: execute
            continue
         }
      }
      ((m[shell])) && {                                              # done unless shell flag was set
         stateless "${word} ${line}" ||                              # in which case execution as shell command is attempted (cmd not found returns 127)
         shellerror "$?"                                             # non-zero exit values of shell commands will be passed on to yoda error handler
         line=""                                                     # assignment sets return value to 0
         continue
      }
      notfound "$word"                                               # nothing helped. get grouchy.
      line=""                                                        # stop evaluation: nothing left
   done
   ((sp<0))&&stackunderflow
}





# ----- load source files -------------------------------- #fold00

# return filehandle pointing to matching file in array files,
# or to end of array where new file will be added if no
# matching file was found. Also return a return values (1)
# if not loaded, return 0 when loaded.
# (seems twisted but allows condition  "if loaded; then ..."

# return filehandle as result, and return value
# indicating first time load or reload
# arg1: file name (fully qualified)
loaded()  {
   local file="$1"
   for ((filehandle=1; filehandle<${#files[@]}; filehandle++)); do   # while multiple inclusion is allowed, those files won't be recorded multiple times
      [[ "${files[filehandle]}" == "$file" ]] && break               # so when already recorded, break out
   done
   return $(( filehandle >= ${#files[@]}))
}

# nestable source include
# this from differs from the colon word, as it doesn't
# try the different ${libdirs[@}} directories.
# file, possible with path, must exist, or no go.
# Callers did a check prior to calling.
from()  {
   [[ -z "$1" ]] && return 2                                         # no file
   local line lines linenr file filehandle word                      # must protect for nested includes.
   local stackeffect="$sp"                                           # included files must have net stack effect of 0
   file=""
   if [[ "$1" == */* ]]; then                                        # file contains slash(es): don't search
      file="$1"
   else
      for dir in "${libdirs[@]}"; do
         [[ -f "$dir/$1" ]] && { file="$dir/$1"; break; }            # search through lib dirs, break when/if found
      done
   fi
   [[ -f "$file" ]] || return 1                                      # file not found
   file="$(realpath "$file")"                                        # canonical or original name of file
   loaded "$file" || files[filehandle]="$file"                       # first time inclusion: add to files array
   readarray -t lines < "$file"                                      # read whole source into lines array
   local transient=()                                                # list of headers marked transient
   for ((linenr=0; linenr<${#lines[@]};)); do                        # looping through line number, not through lines so that
      line="${lines[linenr++]}"                                      #   source can change line numbers for jumping
      evaluate "$line"                                               # process next line
      ((error | (linenr < 0)))&&break                                # source can flag "stop loading" with negative linenr
   done                                                              #   (warm and done do so)
   for ((tmp=0; tmp<${#transient[@]}; tmp++)); do                    # trash transient headers
      unset -v "forth[${transient[tmp]}]"
   done
   ((compiling)) && stillcompiling "$1"                              # can't have that, files leaving a dangling compiler
   ((stackeffect == sp)) || unbalancedstack "$1"                     # demanding stack clean files with net effect zero.
   ((loaded[filehandle]++))                                          # increment load counter, mark as loaded
   return 0
}



# ----- primitives --------------------------------------- #fold00
# ----- populating detokeniser --------------------------- #fold01
# for testing, a handful of inlined single operation primitives
# and atomic operations are added. no optimising take place now.
# atoms are only substituted against corresponding code.
# atoms are tagged as such in the source, some correspond to
# names of primitives. This is meant for having the optimiser
# hooked into code generation, for doing some more substantial
# work later on. chosing these operations allows tracking of
# recent use of stack items and registers, for static elimination
# of redundant operations.

atom["dup"]='((s[++sp]=s[sp]))'
atom["over"]='((s[++sp]=s[sp-1]))'
atom["pluck"]='((s[++sp]=s[sp-2]))'
atom["drop"]='((sp--))'
atom["@"]='((s[sp]=m[s[sp]]))'
atom["1+"]='((s[sp]=(s[sp]+1)&true))'
atom["1-"]='((s[sp]=(s[sp]-1)&true))'
atom["2*"]='((s[sp]=(s[sp]<<1)&true))'

atom["negate"]='((s[sp]=(-s[sp]&true)))'
atom["invert"]='((s[sp]^=maxuint))'

atom["s1"]='((s1=s[sp]))'
atom["s2"]='((s2=s[sp-1]))'
atom["s3"]='((s3=s[sp-2]))'
atom["s4"]='((s4=s[sp-3]))'

atom["s1=tmp"]='((s[sp]=tmp))'
atom["s2=tmp"]='((s[sp-1]=tmp))'
atom["s3=tmp"]='((s[sp-2]=tmp))'
atom["s4=tmp"]='((s[sp-3]=tmp))'
atom["tmp=s1"]='((tmp=s[sp-0]))'
atom["tmp=s2"]='((tmp=s[sp-1]))'
atom["tmp=s3"]='((tmp=s[sp-2]))'
atom["tmp=s4"]='((tmp=s[sp-3]))'

atom["s1=s2"]='((s[sp]=s[sp-1]))'
atom["s1=s3"]='((s[sp]=s[sp-2]))'
atom["s2=s1"]='((s[sp-1]=s[sp]))'
atom["s2=s3"]='((s[sp-1]=s[sp-2]))'
atom["s3=s1"]='((s[sp-2]=s[sp]))'
atom["s3=s2"]='((s[sp-2]=s[sp-1]))'
atom["s4=s1"]='((s[sp-3]=s[sp]))'
atom["s4=s2"]='((s[sp-3]=s[sp-1]))'
atom["s4=s3"]='((s[sp-3]=s[sp-2]))'

atom["r@"]='((s[++sp]=r[rp]))'
atom['>r']='((r[++rp]=s[sp--]))'
atom['r>']='((s[++sp]=r[rp--]))'
atom['rdrop']='((r--))'

atom["allot"]='((dp+=s[sp--]))'
atom["here"]='((s[++sp]=dp))'

# ----- colon/semicolon ---------------------------------- #fold01


colon ';'
   code "(( s[sp--] == $magic )) || { unstructured ':'; return; }"   # check the magic left by :
   code '(( ${s[sp--]} == ${#body[@]} )) && code "(())"'             # insert a noop into empty function bodies
   code 'semicolon'                                                  # compile $lastword from $body[@], resume interpreting
semicolon
compiled

colon ':'
   code 'word'                                                       # parse space delimited word from input stream
   code 'colon "$word"'                                              # generate synthetic name, associate with word
   code "((s[++sp]=\${#body[@]}))"                                   # allow check of empty function
   code "((s[++sp]=$magic))"                                         # allow check of structure
   code '((compiling=true))'
semicolon
# ----------------------------------------------

primitive 'interpreted' 'interpreted'                                # move header to interpreter context vocabulary
primitive 'compiled'    'compiled'                                   # move header to compiler context vocabulary
primitive 'transient'   'transient+=("$lastword")'                   # copy header to transient for later trashing

# ----- diagnostics -------------------------

words() {
   local headers
#   for tmp in "${headerslistlist[@]}" "unresolved"; do
   for tmp in "${wordlists[@]}" "interpretonly" "compileonly" "unresolved"; do
      declare -n headers="$tmp"
      (( ${#headers[@]} )) && {
         printf '%s\n' "--- $tmp ---"
         printf  "%s  " "${!headers[@]}"
         printf '\n\n'
      }
   done
}


# TODO: factor context voc search.  see also  tick, undoc, forward refs
see()  {
   local headers
   word
   for tmp in "${wordlists[@]}" "interpretonly" "compileonly"; do
      declare -n headers="$tmp"
      [[ -z "${headers["$word"]}" ]] || {
         printf "found in %s:\n" "${tmp#"headers"}"
         tmp="${headers["$word"]}"
         [[ -z "$tmp" ]] && notfound
         type "$tmp"
      }
   done
}

# see word  "decompiles" and shows word.
primitive 'see' 'see'


# ----- does> -------------------------------------------- #fold01

# compiled to the end of a defining word,
# is therefore called by create part, and
# will consequently know who its caller is
# (function name).  Will also know, by virtue
# of $lastword, what function to add code to.
# (or rather, instruct detokeniser to add code
# to). Appends all defining word associated code
# portion of does> to the original address push
# compiled by create.
dodoes()  {                                                          # append does> part to original address pushing create semantics
   ${forth[$lastword]}
   use  "s[++sp]=\"${s[sp--]}\"
         ${doescode[${FUNCNAME[1]}]}"
}

# detokeniser detects and reacts to this "$does" tagged code:
# code after does> is removed from defining word and written to
# an array item associated with it.
# dodoes then uses that code to rewrite run time semantics of
# defined word.
# Though somewhat Rube-Goldbergish, it's simpler than the other
# approaches I was thinking of.
primitive 'does>'  'code "dodoes" "$does"';   compiled

# ----- defining words ----------------------------------- #fold01

# essentially a constant with yet to be specified source for its
# value and overwritable run time semantics (push value by default)
definess()  {
   code "constant \"\${ss[-1]}\" \"$1\""                             # not using single quotes because want $1 to expand
   code 'unset "ss[-1]"'
}

define()  {
   code 'word'
   code "constant \"\$word\" \"$1\""                                 # not using single quotes because want $1 to expand
}


colon 'create$'
    definess '$dp'
semicolon

colon 'create'
    define '$dp'
semicolon


colon 'constant'
   define '${s[sp--]}'
semicolon

colon 'constant$'
   definess '${s[sp--]}'
semicolon

colon 'variable'
   define '$((dp))'
   code '((m[dp++]=0))'                                              # allocate and initialise
semicolon

colon 'variable$'
   definess '$((dp))'
   code '((m[dp++]=0))'                                              # allocate and initialise
semicolon

colon "array"
   define ''                                                         # value irrelevant, use will replace code anyway
   code 'use "((s[sp]+=$dp))"'                                       # set run time semantics
   code "((dp+=s[sp--]))"                                            # allocate
semicolon

colon "array$"
   definess ''                                                       # value irrelevant
   code 'use "((s[sp]+=$dp))"'                                       # set run time semantics
   code "((dp+=s[sp--]))"                                            # allocate
semicolon



# NOTE: factor code common with header
# ' foo alias bar
colon 'alias'
   define ''                                                         # value irrelevant, will point to different function anyway
   code 'forth["$word"]="${functionname_prefix}_${s[sp--]}"'
   code 'where["$lastword"]="${filehandle}:${linenr:-${BASH_LINENO[2]}}"'
semicolon


# -> library
#colon 'vocabulary'
# ...
#semicolon

# vocabulary 'only'
# vocabulary 'forth'

#colon 'only'
#colon 'forth'



# -------------- deferred words ------------------

# new deferred words are initialised to noop
primitive 'noop' '(())'

# example:  defer foo      ' bar is foo
colon "defer"                                                        # use in yoda program
   code 'word'
   code 'defer "$word" "noop"'
semicolon


# here's another Rube Goldberg. This works around the fact that
# there's no easy way for yoda to determine the memory address
# where a deferred word stores the xt of the word it executes.
# therefore, is decompiles the deferred word, then extracts the
# address from the line where the deferred word fetches the xt
# from memory. sed could do that more easily, but isn't currently
# an already existing dependency, contrary to grep, which is why
# grep is used here.
colon 'is'
   code 'word'
   code 'tmp="$(type "${forth[$word]}"|grep "${functionname_prefix}_.*m\[")"'
   code 'm["${tmp//[!0-9]/}"]="${s[sp--]}"'
semicolon

# ----- environment--------------------------------------- #fold01
# read number from environment variable with name on string stack
# ( -- x )  ( string:  $1 -- )
colon 'env'
   push '${!ss[-1]}'
   code 'unset "ss[-1]"'
semicolon
inline
inout 0 1

# store $1 in bash environment variable with name $2
# ( x -- ) ( string:  $1 -- )
colon '>env'
   code 'eval "${ss[-1]}=$((s[sp--]))"'
   code 'unset "ss[-1]"'
semicolon
inout 1 0


# read string from environment variable with name on string stack
# ( string:  $1 -- $2 )
primitive 'env$' 'ss[-1]="${!ss[-1]}"'; inout 0 0

# store string $1 in bash environment variable with name $2
# ( string:  $1 $2 -- )
colon '>env$'
   code 'eval "${ss[-1]}=${ss[-2]}"'
   code 'unset "ss[-1]"'
   code 'unset "ss[-1]"'
semicolon
inout 0 0



# ----- misc --------------------------------------------- #fold01

primitive "\\"   'line=""';   compiled                               # single quoted single backslash because
primitive "\\"   'line=""';   interpreted                            # double quoted escaped backslash rather than
                                                                     # efte syntax highlighting gets confused
primitive '('    "parse ')'"; compiled
primitive '('    "parse ')'"; interpreted


# ----- parameter stack ---------------------------------- #fold01


colon 'dup'
   atom 'dup'
semicolon
inline
inout 1 2

colon 'drop'
   atom 'drop'
semicolon
inline
inout 1 0

colon 'over'
   atom 'over'
semicolon
inline
inout 2 3

colon 'pluck'
   atom 'pluck'
semicolon
inline
inout 3 4

colon '2dup'
   atom 'over'
   atom 'over'
semicolon
inline
inout 2 4

primitive '2drop' '((sp-=2))'; inout 2 0

colon '2over'
   push 's[sp-3]'
   push 's[sp-3]'
semicolon
inline
inout 4 6

colon 'swap'
   atom 'tmp=s2'
   atom 's2=s1'
   atom 's1=tmp'
semicolon
inline
inout 2 2

colon '2swap'
   atom 'tmp=s4'
   atom 's4=s2'
   atom 's2=tmp'
   atom 'tmp=s3'
   atom 's3=s1'
   atom 's1=tmp'
semicolon
inout 4 4

colon 'nip'
   atom 's2=s1'
   atom 'drop'
semicolon
inline
inout 2 1

colon 'tuck'
   atom 'dup'
   atom 's2=s3'
   atom 's3=s1'
semicolon
inline
inout 2 3

colon 'rot'
   atom 'tmp=s1'
   atom 's1=s3'
   atom 's3=s2'
   atom 's2=tmp'
semicolon
inline
inout 3 3

colon '-rot'
   atom 'tmp=s1'
   atom 's1=s2'
   atom 's2=s3'
   atom 's3=tmp'
semicolon
inline
inout 3 3

colon '?dup'
   code '((s[sp])) &&'
   atom 'dup'
semicolon
inline

primitive 'depth'  '((s[++sp]=$sp))'
primitive 'pick'   '((s[sp]=s[sp-s[sp]-1]))'

# ----- return stack ------------------------------------- #fold01

colon 'r@'
   atom 'r@'
semicolon
inline
inout 0 1

colon 'rdrop'
   atom 'rdrop'
semicolon
inline
inout 0 0

colon '>r'
   atom '>r'
semicolon
inline
inout 1 0

colon 'r>'
   atom 'r>'
semicolon
inline
inout 0 1

# ( x1 x2 -- )  ( return: -- x1 x2 )
colon '2>r'
   code '((r[++rp]=s[sp-1]))'
   code '((r[++rp]=s[sp--]))'
   atom 'drop'
semicolon
inline
inout 1 0

# ( -- x1 x2 )  ( return: x1 x2 -- )
colon '2r>'
   push 'r[rp-1]'
   push 'r[rp--]'
   code '((rp--))'
semicolon
inline
inout 0 1


primitive 'rdepth'  '((s[++sp]=rp))'; inout 0 1

# ----- string stack ------------------------------------- #fold01

primitive 'depth$'   's[++sp]="${#ss[@]}"'
primitive 'empty$'   'ss=()'
primitive 'dup$'     'ss+=("${ss[-1]}")'
primitive '?dup$'    '[[ -z ${ss[-1]} ]] || ss+=("${ss[-1]}")'
primitive 'drop$'    'unset "ss[-1]"'
primitive 'over$'    'ss+=("${ss[-2]}")'
primitive 'pluck$'   'ss+=("${ss[-3]}")'
primitive 'pick$'    'ss+=("${ss[-s[sp--]-1]}")'

colon '2dup$'
   code 'ss+=("${ss[-2]}")'
   code 'ss+=("${ss[-2]}")'
semicolon
inline

colon '2drop$'
   code 'unset "ss[-1]"'
   code 'unset "ss[-1]"'
semicolon
inline

colon '2swap$'
   code 'tmp="${ss[-4]}"; ss[-4]="${ss[-2]}"; ss[-2]="$tmp"'
   code 'tmp="${ss[-3]}"; ss[-3]="${ss[-1]}"; ss[-1]="$tmp"'
semicolon
inline

colon 'swap$'
   code 'tmp="${ss[-2]}"; ss[-2]="${ss[-1]}"; ss[-1]="$tmp"'
semicolon
inline

colon 'nip$'
   code 'ss[-2]="${ss[-1]}"'
   code 'unset "ss[-1]"'
semicolon
inline

colon 'tuck$'
   code 'ss+=("${ss[-1]}"); ss[-2]="${ss[-3]}"; ss[-3]="${ss[-1]}"'
semicolon
inline

colon 'rot$'
   code 'tmp="${ss[-1]}"; ss[-1]="${ss[-3]}"; ss[-3]="${ss[-2]}"; ss[-2]="$tmp"'
semicolon
inline

colon '-rot$'
   code 'tmp="${ss[-1]}"; ss[-1]="${ss[-2]}"; ss[-2]="${ss[-3]}"; ss[-3]="$tmp"'
semicolon
inline

# results may not be what is expected: this removes *all* white space,
# not just leading and trailing white space. Actually a mistake, which
# I'll now try to sell as feature.
# or not. too specific, I better add some more general replace$ function
# ( string: $1 -- $2 )
#primitive 'trim$'  'ss[-1]="${ss[-1]//[[:space:]]/}"'

#primitive '-leading$'  'ss[-1]="${ss[-1]//^[[:space:]]*/}"'
#primitive '-trailing$'  'ss[-1]="${ss[-1]//[[:space:]]*$/}"'
#evaluate ': trim$  -leading$ -trailing$ ;'

# ( -- u )  string: ( $1 $2 -- $3 )     remove  $2* from $1, return removed chars count
colon 'cut$'
   push '${#ss[-2]}'
   code 'ss[-2]="${ss[-2]%${ss[-1]}*}"'
   code '((s[sp]-=${#ss[-2]}))'
   code 'unset "ss[-1]"'
semicolon

# count substring occurances
# : #substrings  swap$ 0 begin over$ cut$ while 1+ repeat 2drop$ ;
# -leading$:  ${myVar##*( )}
# -trailing$: ${myVar%%*( )}

colon '.ss'
   code '((${#ss[@]})) &&'
   code 'printf "\"%s\" " "${ss[@]}"'
semicolon

colon 'type$'
   code 'printf "%s" "${ss[-1]}"'
   code 'unset "ss[-1]"'
semicolon
inline

colon 'count$'
   push '${#ss[-1]}'
   code 'unset "ss[-1]"'
semicolon
inline


# ( $1 -- $2 )
primitive 'uppercase1$'   'ss[-1]="${ss[-1]^}"'                      # foobar -> Foobar
primitive 'lowercase1$'   'ss[-1]="${ss[-1],}"'                      # FooBar -> fooBar
primitive 'othercase1$'   'ss[-1]="${ss[-1]~}"'                      # fooBar -> FooBar
primitive 'uppercase$'    'ss[-1]="${ss[-1]^^}"'                     # FooBar -> FOOBAR
primitive 'lowercase$'    'ss[-1]="${ss[-1],,}"'                     # FooBar -> foobar
primitive 'othercase$'    'ss[-1]="${ss[-1]~~}"'                     # FooBar -> fOObAR

# split string into single words at white space, return count of resulting single word strings.
# ( -- u )   ss: ( $ -- $1 $2 $3 .. $u )
colon 'chop$'
   code 'tmp="${ss[-1]}"'
   code 'unset "ss[-1]"'
   code '((s1=${#ss[@]}))'
   code 'ss+=($tmp)'
   push '${#ss[@]}-s1'
semicolon

# ( $1 -- $2 )
primitive 'quote$' 'ss[-1]="\"${ss[-1]}\""'

# ---------- command ---------      - output -        ----- mnemonic -----
# "abcdefgh"   2 left$   type$      ab                "keep 2 left"
# "abcdefgh"  -2 left$   type$      abcdef            "keep left all but last 2"
# "abcdefgh"   2 right$  type$      gh                "keep 2 right"
# "abcdefgh"  -2 right$  type$      cdefgh            "keep right all but first 2"
# "abcdefgh"   2 split$  type$      ab cdefgh         "split at left"
# "abcdefgh"  -2 split$  type$      abcdef gh         "split at right"

primitive 'left$'  'ss[-1]=${ss[-1]:0:s[sp--]}'
primitive 'right$' 'ss[-1]=${ss[-1]:0-s[sp--]}'

# remove u1 chars from the left, return u2 chars from what remains
# ( u1 u2 -- ) ( $1 -- $2 )
colon 'mid$'
   code 'ss[-1]=${ss[-1]:s[sp-1]:s[sp--]}'
   atom 'drop'
semicolon

# ( u -- ) ( $1 -- $2 $3 )
colon 'split$'
   code 'ss+=("${ss[-1]:s[sp]}")'
   code 'ss[-2]="${ss[-2]:0:s[sp--]}"'
semicolon

colon 'join$'
   code 'ss[-2]+="${ss[-1]}"'
   code 'unset "ss[-1]"'
semicolon
inline

colon '$='
   code '[[ ${ss[-1]} != ${ss[-2]} ]]'
   push '(-$?)&true'
   code 'unset "ss[-1]"'
   code 'unset "ss[-1]"'
semicolon

colon '$<'
   code '[[ ${ss[-1]} > ${ss[-2]} ]]'
   push '($?-1)&true'
   code 'unset "ss[-1]"'
   code 'unset "ss[-1]"'
semicolon

colon '$>'
   code '[[ ${ss[-1]} < ${ss[-2]} ]]'
   push '($?-1)&true'
   code 'unset "ss[-1]"'
   code 'unset "ss[-1]"'
semicolon

# "nice"    "this is a very *** foo"   "***" replace$    ->   "this is a very nice foo"
# "nope"    "this is a very *** foo"   "?" replace$      ->   "this is a very *** foo"
# "123"     "abcd" 1 insert$  -> "a123bcd"

primitive 'allot$' '((sdp+=s[sp--]))'

colon 'here$'
   push 'sdp'
semicolon

colon '$,'
   code 'strings[sdp++]="${ss[s-1]}"'
   code 'unset "ss[-1]"'
semicolon


# push string array item u to string stack
# ( u -- ) ( -- $1 )
primitive '$@'  'ss+=("${strings[s[sp--]]}")';  inline

# store string stack item in string array
# ( u -- )  ( $1 -- )
colon '$!'
   code 'strings[s[sp--]]="${ss[-1]}"'
   code 'unset "ss[-1]"'
semicolon


# --- mixed mode operations, exchanges between stack and string stack ---
# remove first character from top of string stack, push its ASCII value
# on stack, or 0 if no char, empty string.
# ( -- c )  ( $1 -- $2 )
asc()  {
   if [[ -z "${ss[-1]}" ]]; then
      ((s[++sp]=0))
   else
      ((s[++sp]=${asc[${ss[-1]:0:1}]}))
      ss[-1]="${ss[-1]:1}"
   fi
}

primitive  'asc'    'asc'
primitive  'char$'  'ss+=("${char[s[sp--]]}")'


# $ -> a -- n
unpackstring()  {
   string="${ss[-1]}"
   unset "ss[-1]"
   ((tmp="${#string}", s1=s[sp]))
   for ((len=0; tmp--;)); do
      ((m[s1++]="asc[${string:len++:1}]"))
   done
   ((s[sp]="$len"))
}

primitive 'unpack$' 'unpackstring'

# ( a n -- ) ( string: -- $ )
colon 'pack$'
   atom 's1'
   atom 's2'
   code '((sp-=2))'
   code 'tmp=""'
   code 'for ((; s1--; )); do tmp+="${char[m[s2++]]}"; done'
   code 'ss+=("$tmp")'
semicolon
inout 2 0

primitive 'append$' 'ss[-1]+="${char[s[sp--]]}"'; inout 1 0          # ( c -- ) ( string: $1 -- $2 )
primitive 'prepend$' 'ss[-1]="${char[s[sp--]]}${ss[s-1]}"'           # ( c -- ) ( string: $1 -- $2 )
inout 1 0

# convert a string representation of a number
# or arithmetic expression to an integer.
# respects base
# ( -- x ) (string: $1 -- )
colon 'convert$'
   push '${m[base]}#${ss[-1]}'
   code 'unset "ss[-1]"'
semicolon
inline
inout 0 1




# ----- numeric comparison ------------------------------- #fold01

primitive '0='   '((s[sp]=s[sp]?false:true))'                        # 0->true  x->false
primitive '0<>'  '((s[sp]=s[sp]?true:false))'                        # 0->0   x->true
primitive '0<'   '((s[sp]=s[sp]&msb?true:false))'                    # &msb: 0->0   msb->true

colon '='
   code '((s1=s[sp--]))'
   code '((s[sp]=(s[sp])==(s1)?true:false))'
semicolon
inline

colon '<>'
   code '((s1=s[sp--]))'
   code '((s[sp]=(s[sp])==(s1)?false:true))'
semicolon
inline

colon 'u<'
   code '((s1=s[sp--]&true))'
   code '((s[sp]=(s[sp]&true)<(s1)?true:false))'
semicolon
inline

colon 'u>'
   code '((s1=s[sp--]&true))'
   code '((s[sp]=(s[sp]&true)>(s1)?true:false))'
semicolon
inline

colon '<'
   code '((s1=s[sp--]&true))'
   code '((sign=((s1^s[sp])&msb)?1:0))'                              # set bit 0 if signs differ
   code '((s[sp]=((s1>s[sp]&true)^sign)?true:false))'
semicolon
inline

colon '>'
   code '((s1=s[sp--]&true))'
   code '((sign=((s1^s[sp])&msb)?1:0))'                              # set bit 0 if signs differ
   code '((s[sp]=((s1<s[sp]&true)^sign)?true:false))'
semicolon
inline

#    flag
#   s2 < s1        sign           result
#   0 (true)       0   (same)     true
#   1 (false)      0   (same)     false
#   0 (true)       msb (diff)     false
#   1 (false)      msb (diff)     true

#  flag  sign      result
#  0     0         true
#  1     0         false
#  0     $xxx1     false
#  1     $xxx1     true

# ( x1 x2 x3 x4 -- 0 | -1 )
colon 'd='
   code '((s1=s[sp--]))'
   code '((s2=s[sp--]))'
   code '((s3=s[sp--]))'
   code '((s[sp]=(s1==s3&s2==s[sp])?true:false))'
semicolon
inline
inout 4 1


# ----- compiler and word search related ----------------- #fold01


#find$
#( -- 0 | xt 1 | xt -1 )   ( $1 -- $1 | )


#FIND
#( c-addr -- c-addr 0 | xt 1 | xt -1 )

#Find the definition named in the counted string at c-addr.
#If the definition is not found, return c-addr and zero.
#If the definition is found, return its execution token xt.
#If the definition is immediate, also return one (1),
#otherwise also return minus-one (-1).
#For a given string, the values returned by FIND while compiling
#may differ from those returned while not compiling.




# word name as argument
# arg1: word name
# ( -- 0 | a )
havearg() {
   local headers                                                     # meant to spare me from saving and restoring vectored headers variable
   word="$1"
   for tmp in "${wordlists[@]}" "interpretonly" "compileonly"; do
      declare -n headers="$tmp"                                      # vector headers to next vocabulary
      [[ -z "${headers["$word"]}" ]] || {                            # word in there?
         tmp="${headers["$word"]}"                                   #     yes: remember name
         [[ $tmp == ${functionname_prefix}* ]] || break              # can not tick data
         ((s[++sp]=${headers["$word"]##*_}))                         # convert name to "address" and push
         return                                                      # found word, stacked execution token
      }
   done                                                              # go on search next voc
   ((s[++sp]=0))
}

# word name from input stream
# ( -- 0 | a )
have() {
# NOTE: local necessary here?
#   local headers                                                     # meant to spare me from saving and restoring vectored headers variable
   word
   havearg "$word"
}

colon "'"
   code 'have'
   code '((s[sp])) || notfound "$word"'                              # none left -> all searched, but not found.
semicolon

colon "[']"
   code 'have'
   code '((s[sp])) || notfound "$word"'                              # none left -> all searched, but not found.
   code 'push "${s[sp--]}"'
semicolon
compiled


primitive '[' '((compiling=false))'; compiled
primitive ']' '((compiling=true))'

colon 'literal'
   code 'push "${s[sp--]}"'
semicolon
compiled

# ( compile: $1 -- ) ( run: -- $1 )
colon 'literal$'
   code 'code "ss+=(\"${ss[-1]}\")"'
   code 'unset "ss[-1]"'
semicolon
compiled

primitive 'execute' "${functionname_prefix}_\${s[sp--]}"             # ( xt -- )
primitive 'name$'   'ss+=("${names[s[sp--]]}")'                      # ( xt -- ) ( string: -- $1 )
primitive '.name'   'printf "%s" "${names[s[sp--]]}"'                # ( xt -- )

# can be used after a colon definition
primitive 'inline'  'inline'                                         # ( -- )    set header flag for inline compilation
primitive 'resolve' 'resolve'                                        # ( -- )    attempt to resolve forward references
primitive '.unresolved'  '((${#unresolved[@]}))&&printf "%s " "${!unresolved[@]}"'   # print unresolved
primitive '#unresolved' '((s[++sp]=${#unresolved[@]}))'              # ( -- u )
primitive 'recurse' 'code "${functionname_prefix}_$((xt))"'; compiled   # ( -- )

# apply run time semantic from string stack
colon 'use$'
   code 'use "${ss[-1]}"'
   code 'unset "ss[-1]"'
semicolon

# trashed name as argument
# ( -- )
trash()  {
   unset -v "forth[$1]"
}

# trashed name from input stream
# ( -- )
colon 'trash'
   code 'word'
   code 'trash "$word"'
semicolon

# trashed name from string stack
# ( -- )
colon 'trash$'
   code 'trash "${ss[-1]}"'
   code 'unset "ss[-1]"'
semicolon

# name of last word to string stack
# ( -- $1 )
primitive 'last$'   'ss+=("$lastword")'; inout 0 0

# similar to ' or find, but name from string stack rather than input stream
colon 'have$'
   code 'havearg "${ss[-1]}"'
   code 'unset "ss[-1]"'
semicolon

# : foo ... ; headerless
# ( -- xt )   # produces execution token and removes header of last word
evaluate ': headerless  last$ dup$ have$ trash$ ;'; inout 0 0

# ( xt -- )
colon 'compile,'
   code 'code "${functionname_prefix}_${s[sp--]}"'
semicolon
#compiled



# ----- bit logic ---------------------------------------- #fold01

primitive 'and'     '((s[sp-1]&=s[sp--]))'
primitive 'or'      '((s[sp-1]|=s[sp--]))'
primitive 'xor'     '((s[sp-1]^=s[sp--]))'
primitive 'lshift'  '((s[sp]=(s[sp-1]<<s[sp--])&true))'
primitive 'rshift'  '((s[sp]=(s[sp-1]&true)>>s[sp--]))'
evaluate "' lshift alias <<"
evaluate "' rshift alias >>"
colon    'invert';  atom 'invert'; semicolon; inline



# ----- flow control -------------------------------------

remagic

colon 'if'
   code 'code "if ((s[sp--])); then"'
   push "\${#body[@]}"                                               # allow check of empty function
   push "$magic"                                                     # allow check of structure and empty function
semicolon
compiled

colon 'else'
   code "(( s[sp]++ == \"$magic\" )) || { unstructured 'if'; return; }"
   code '(( s[sp-1] == ${#body[@]} )) && code "(())"'
   code 'code "else"'
   code '((s[sp-1]=${#body[@]}))'
semicolon
compiled

colon 'then'
   code "(( s[sp] == $magic ||  s[sp] == $((magic+1)) )) || { unstructured 'if or else'; return; }"
   atom 'drop'
   code '(( s[sp--] == ${#body[@]} )) && code "(())"'
   code 'code "fi"'
semicolon
compiled


remagic

colon 'begin'
   code 'code "while :; do"'
   push "\${#body[@]}"                                               # allow check of empty function
   push "$magic"                                                     # allow check of structure and empty function
semicolon
compiled


colon 'again'
   code "(( s[sp--] == \"$magic\" )) || { unstructured 'begin'; return; }"
   code '(( s[sp--] == ${#body[@]} )) && code "(())"'
   code 'code "done"'
semicolon
compiled

colon 'until'
   code "(( s[sp--] == \"$magic\" )) || { unstructured 'begin'; return; }"
   code 'code "((s[sp--]))&&break"'
   atom 'drop'
   code 'code "done"'
semicolon
compiled

colon 'while'
   code "(( s[sp]++ == $magic )) || { unstructured 'begin'; return; }"
   code 'code "((s[sp--]))||break"'
semicolon
compiled

colon 'repeat'
   code "(( s[sp--] == $((magic+1)) )) || { unstructured 'while'; return; }"
   atom 'drop'
   code 'code "done"'
semicolon
compiled


remagic
colon 'for'
   code 'code "((r[++rp]=i))"'
   code 'code "((i=s[sp--]))"'
   code 'code "for ((; i--; )); do"'
   push "\${#body[@]}"                                               # allow check of empty function
   push "$magic"                                                     # allow check of structure and empty function
semicolon
compiled

primitive 'i' '((s[++sp]=i))'; inout 0 1
evaluate " ' r@ alias j";      inout 0 1

colon 'next'
   code "((s[sp--] == $magic))|| { unstructured 'for'; return; }"
   code '((s[sp--] == ${#body[@]})) && code "(())"'
   code 'code "done"'
   code "code '((i=r[rp--]))'"
semicolon
compiled


# x1 x2 -- x1+x2 x1
# : bounds   over + swap ;
colon 'bounds'
   atom 's1'
   atom 's2'
   code '((s[sp-1]=(s1+s2)&true))'
   code '((s[sp]=s2))'
semicolon
inline
inout 2 2

remagic
dodo()  {
   ((r[++rp]=ibar))
   ((r[++rp]=i))
   ((i=s[sp--]))
   ((ibar=s[sp--]))
}

colon 'do'
   code 'code "dodo"'
   code 'code "while :;do"'
   push "$magic"                                                     # allow check of structure and empty function
semicolon
compiled

colon '?do'
   code 'code "dodo"'
   code 'code "while :;do"'
   code 'code "((i==ibar))&&break"'
   push "$magic"                                                     # allow check of structure and empty function
semicolon
compiled

colon 'loop'
   code "((s[sp--] == $magic))|| { unstructured 'do'; return; }"
   code 'code "((i=(i+1)&true))"'
   code 'code "((i == ibar))&&break"'
   code 'code "done"'
   code "code '((i=r[rp--]))'"
   code "code '((ibar=r[rp--]))'"
semicolon
compiled

colon '+loop'
   code "((s[sp--] == $magic))|| { unstructured 'do'; return; }"
   code 'code "((s1=s[sp--]))"'
   code 'code "((i+=s1))"'
   code 'code "((((ibar-(s1<msb)-i)^s1)&msb))&&break"'
   code 'code "done"'
   code "code '((i=r[rp--]))'"
   code "code '((ibar=r[rp--]))'"
semicolon
compiled

primitive 'leave'  'code "break"'              ; compiled            # break out of loop
primitive '?leave' 'code "((s[sp--]))&&break"' ; compiled            # break out of loop when false
primitive 'lest'   'code "((s[sp--]))||return"'; compiled            # interpreting version: skip rest of line when false
primitive 'lest'   '((s[sp--]))||line=""'      ; interpreted         # compiling version: skip until end of word (i.e. return) when true
primitive 'unless' 'code "((s[sp--]))&&return"'; compiled            # interpreting version: skip rest of line when true
primitive 'unless' '((s[sp--]))&&line=""'      ; interpreted         # compiling version: skip rest of word when false

# interpreting version: u times repeat evaluation of input line remainder
colon 'times'
   code '((r[++rp]=i))'                                              # by using i, and pushing previous i to rstack,
   code '((i=s[sp--]))'                                              # we make times, and nested times, compatible with i and j
   code 'while ((i--)); do evaluate "$line"; done'                   # evaluate line i times
   code '((i=r[rp--]))'                                              # restore old i
   code 'line=""'                                                    # prevent re-evaluation of line when times has completed
semicolon
interpreted

colon 'times'
   code 'code "((r[++rp]=i))"'                                       # by using i, and pushing previous i to rstack,
   code 'code "for ((i=s[sp--];i--;)); do"'
   code 'conclude "code \"done\""'
   code 'conclude "code \"((i=r[rp--]))\""'
semicolon
compiled

# this is the prefered version, repeating the line upon encountering many
# prefered because its use is more symmetrical with times, both specified
# before the repeated sequence.  times is harder to put at the end.
colon 'many'
   code 'until read -rsn1 -t 0.01; do evaluate "$line"; done'
   code 'line=""'
semicolon

colon 'boot'
   code 'word'
   code 'satisfy1 "$word"'
   code 'coldvector="${forth["$word"]}"'                  # because writing it to cold start vector
semicolon                                                            # this way cold start entry points can be forward referenced

primitive 'warm'  'warm'
primitive 'bye'  'exit 0'
primitive 'exit'  'code "return"'; compiled
primitive 'return'  'code "return \${s[sp--]}"'; compiled



# ----- arithmetics -------------------------------------- #fold01

colon '1+'
   atom '1+'
semicolon
inline
inout 1 1

colon '1-'
   atom '1-'
semicolon
inline
inout 1 1

colon '2*'
   atom '2*'
semicolon
inline
inout 1 1


primitive '+'   '((s[sp]=(s[sp-1]+s[sp--])&true))'; inout 2 1
primitive '-'   '((s[sp]=(s[sp-1]-s[sp--])&true))'; inout 2 1

# floored 2/
#primitive '2/'   '((s[sp]=(s[sp]>>1)|(s[sp]&msb)))'  ; inout 1 1

colon  '2/'
   atom 's1'
#   code '((s[sp]=s1&msb?(s1>>1)|msb:s1>>1))'                        # floored
   code '((s[sp]=s1&msb?-((-s1&maxint)>>1)&true:s1>>1))'             # symmetric
semicolon
inout 1 1

evaluate ': cells ;'      ; compiled  ; inout 1 1
evaluate ': cells ;'      ; interpreted; inout 1 1
evaluate ': cell+ 1+ ;'   ; inline;      inout 1 1



#                     msb&    msb&
#  s3 s2 s1 -- r q  s1^s2^s3  s2^s3
# ---------------------------------
#  +  +  +     + +     0        0
#  +  +  -     + -     1        0
#  +  -  +     - -     1        1
#  +  -  -     - +     0        1
#  -  +  +     - -     1        1
#  -  +  -     - +     0        1
#  -  -  +     + +     0        0
#  -  -  -     + -     1        0
# ( s3 s2 s1  -- s3*s2%s1 s3*s2/s1 )
colon '*/mod'
   atom 's1'
   atom 's2'
   atom 's3'
   atom 'drop'
   code '((signr=(s2^s3)))'                                          # 0:+   x:-
   code '((signq=(signr^s1)))'                                       # 0:+   x:-
   code '((s1&msb&&(s1=-s1&true)))'                                  # abs s1
   code '((s2*=s3))'
   code '((s2&msb&&(s2=-s2&true)))'
   code '((s[sp-1]=(signr&msb?(-s2%s1)&true:s2%s1)))'
   code '((s[sp]=(signq&msb?-(s2/s1)&true:s2/s1)))'
semicolon
inout 3 2

evaluate ': */     */mod nip ;'         ; inline; inout 3 1          # truncated, symmetric
evaluate ': /mod   1 -rot  */mod  ;'    ;         inout 2 2          # truncated, symmetric
evaluate ': *      1 */    ;'           ; inline; inout 2 1
evaluate ': /      /mod nip  ;'         ; inline; inout 2 1          # truncated, symmetric
evaluate ': mod    /mod drop  ;'        ; inline; inout 2 1          # sign according  n1 == n2*(n1/n2)+remainder
evaluate ': %      50 */ dup 0< 1 or + 2/ ;'  ; inline; inout 2 1    # percentage rounded, not truncated

colon 'negate'
   atom 'negate'
semicolon
inline
inout 1 1

colon '?negate'
   code '((s[sp--]))&&'
   atom 'negate'
semicolon
inline
inout 2 1

colon 'abs'
   code '((s[sp]&msb))&&'
   atom 'negate'
semicolon
inline
inout 1 1


evaluate ": min    2dup >  if swap then drop ;"
evaluate ": max    2dup <  if swap then drop ;"
evaluate ": umin   2dup u> if swap then drop ;"
evaluate ": umax   2dup u< if swap then drop ;"


# ----- memory ------------------------------------------- #fold01

colon '@'
   atom '@'
semicolon
inline
inout 1 1

colon '!'
   code '((m[s[sp--]]=s[sp-1]))'
   atom 'drop'
semicolon
inline
inout 2 0

primitive 'c@'  '((s[sp]=m[s[sp]]&255))'; inout 1 1

colon 'c!'
   code '((m[s[sp--]]=s[sp-1]&255))'
   atom 'drop'
semicolon
inline
inout 2 0


# ( a -- [a+cell] [a] )
colon '2@'
   atom 's1'
   code '((s[sp++]=m[s1+1]))'
   code '((s[sp]=m[s1]))'
semicolon
inline
inout 1 2


# ( [a+cell] [a] a -- )
colon '2!'
   code 's1=s[sp--]'
   code '((m[s1++]=s[sp--]))'
   code '((m[s1]=s[sp--]))'
semicolon
inline
inout 3 0


primitive 'skim'    '((s[++sp]=m[s[sp]++]))'; inout 1 2
primitive 'count'   '((s[++sp]=m[s[sp]++]&255))'; inout 1 2

colon '<-'                                                           # ( a x -- )   swap !
   code '((m[s[sp]]="s[sp--]"))'
   atom 'drop'
semicolon
inout 2 0

colon '+!'
   code '((m[s[sp--]]=(s[sp-1]+m[s[sp]])&true))'
   atom 'drop'
semicolon
inline
inout 2 0

primitive 'on'   '((m[s[sp--]]=true))';               inout 1 0
primitive 'off'  '((m[s[sp--]]=false))';                     inout 1 0
primitive 'inc'  '((m[s[sp--]]=(m[s[sp]]+1)&true))';  inout 1 0
primitive 'dec'  '((m[s[sp--]]=(m[s[sp]]-1)&true))';  inout 1 0

# replace contents of a against x1,
# while returning former contents as x2
# ( x1 a -- x2 )
colon 'exchange'
   code '((tmp=m[s[sp]]))'
   code '((m[s[sp]]=s[sp-1]))'
   code '((s[--sp]=tmp))'
semicolon
inout 2 1

# replace contents of a and a+cell against x1 x2,
# while returning former contents as x3 x4
# ( x1 x2 a -- x3 x4 )
colon '2exchange'
  code '((s1=s[sp--]))'
  code '((s2=s[sp]))'
  code '((s3=s[sp-1]))'
  code '((s[sp]=m[s1]))'
  code '((s[sp-1]=m[s1+1]))'
  code '((m[s1]=s2))'
  code '((m[s1+1]=s3))'
semicolon
inout 3 2





colon 'here'
   atom 'here'
semicolon
inline
inout 0 1

colon 'allot'
   atom 'allot'
semicolon
inline
inout 1 0

primitive ',' '((m[dp++]=s[sp--]))';  inout 1 0

# c -> m[a++],  u times
# ( a u c -- )
colon 'fill'
   code '((s1=s[sp--], s2=s[sp--], s3=s[sp--]))'
   code 'for ((;s2--;)); do ((m[s3++] = s1)); done'                  # c -> m[a++],  u times
semicolon
inout 3 0

# ( a u -- )
evaluate ': erase   0 fill ;'    ; inline; inout 2 0                 # 0 -> m[a++],  u times

# ( a1 a2 u -- )
move()  {                                                            # deals with destination overlapping source
   ((s1=s[sp--], s2=s[sp--], s3=s[sp--]))
   if ((s3 < s2)); then                                              # copy highest to lowest:
      ((s2+=s1, s3+=s1))                                             # m[--a1+u} -> m[--a2+u],  u times
      for ((;s1--;)); do
         ((m[--s2] = m[--s3]))
      done
   else                                                              # copy lowest tio highest
      for ((;s1--;)); do                                             # m[a1++} -> m[a2++],  u times
         ((m[s2++] = m[s3++]))
      done
   fi
}

# ( a1 a2 u -- )
primitive 'move'   'move'; inout 3 0




# ----- character i/o ------------------------------------ #fold01

# given an ASCII, print the character
primitive 'emit'  'printf "%c" "${char[s[sp--]&255]}"'; inout 1 0
evaluate ': type  pack$ type$ ;'  ; inline;  inout 2 0

# parse input for string delimited by character specified by ASCII value on stack
colon 'parse$'
   code 'parse "${char[s[sp--]]}"'
   code 'ss+=("$word")'
semicolon

evaluate ': word$  bl parse$ ;  inline'

# duplicating 'char functionality because quoting in evaluate
# becomes sometimes hard when using ' ' for characters' ASCIIs
colon '[char]'
   code 'word'
   code 'push "${asc[${word:0:1}]}"'
semicolon
compiled


keybuf=""
colon 'key'
   code 'if [[ -z "$keybuf" ]]; then'                                # key? may have put chars into keybuf
   code 'IFS="" read -rsn1 tmp'                                      # keybuf empty: read from console
   code 'keybuf+="${tmp}"'                                           # consider space if -z $tmp
   code 'fi'
   code 'tmp="${keybuf:0:1}"'                                        # read key from keybuf
   code 'tmp=$(printf "%d" '"\"'""\${tmp}\")"                        # treat ctrls as spaces, convert to ASCII
   push 'tmp'                                                        # push ASCII
   code 'keybuf="${keybuf:1}"'                                       # strip key from keybuf
semicolon
inout 0 1

colon 'key?'
   code '[[ -z "$keybuf" ]] || { s+=("$true"); return; }'            # key in keybuf: yes, flag "key ready"
   code 'IFS=""'                                                     # no key in keybuf: poll console
   code 'if read -rsn1 -t0.01 tmp; then'
   code 'keybuf+="$tmp"'                                             # add key to buffer. maybe add space if -z $tmp
   push 'true'
   code 'return'
   code 'fi'
   push 'false'
semicolon
inout 0 1


# read line, push to string stack
# TODO: configurable attributes
colon 'simplequery$'
   code 'ss+=("")'
   code 'IFS="" read -er -i "$keybuf" "ss[-1]"'                      # key? may have put chars into keybuf
   code 'keybuf=""'
semicolon
inout 0 0


colon 'evaluate$'
   code 'local tib="${ss[-1]}"'
   code 'unset "ss[-1]"'
   code 'evaluate "$tib"'
semicolon
inline

colon 'spaces'
   code '((s1=s[sp--]))'
   code '((s1&msb))||printf "%${s1}s" ""'
semicolon
inout 1 0


defer       'query$' 'simplequery$'
evaluate ': ltype$    dup$ type$ count$ - spaces ;'; inout 1 0       # ( u -- ) (string: $1 -- )
evaluate ': rtype$    dup$ count$ - spaces type$ ;'; inout 1 0       # ( u -- ) (string: $1 -- )
primitive  'cr'      'printf "\n"';                  inout 0 0
primitive  'space'   'printf " "' ;                  inout 0 0
primitive  'page'    'clear'      ;                  inout 0 0


colon 'compiling'
   push 'compiling'
semicolon

primitive 'simpleprompt' '((compiling)) || printf " %s\n" "ok"'
defer     'prompt'       'simpleprompt'


# ----- file i/o -----------------------------------------


# load file whose name is given on string stack
# ( -- ) ( string: $1 -- )
colon 'from$'
   code 'file="${ss[-1]}"'
   code 'unset "ss[-1]"'
   code 'from "$file"||filenotfound "$file"'
semicolon

# load file whose name is parsed from input
# ( -- ) ( input: parse word )
evaluate ': from word$ from$ ;'
primitive '#files' '((s[++sp]=${#files[@]}))'; inout 0 1

# ignore block of source lines up to next empty line
colon 'waive'
   code 'until (( linenr > ${#lines[@]} )); do'
   code 'line="${lines[linenr++]}"'
   code '[[ -z "$line" ]] && break'
   code 'done'
semicolon


# ----- pictured number conversion ----------------------- #fold01

# NOTE: consider to let # expect a double, but process lower
# half only, so its stack complies with standard # while its
# not actually able to work on doubles.
# change would also apply to #s, #>, uconvert: doubles on
# stack but singles only processed.
# ( x1 -- x2 ) ( string: $1 -- $2 )
colon '#'                                                            # : #
   code '((radix=m[base]))'                                          # base @
   code '((s1=s[sp]&true, s[sp]=s1/radix, tmp=s1%radix+48))'         # /mod swap '0 +
   code '((tmp>57))&&((tmp+=39))'                                    # dup '9 > 39 and +
   code 'ss[-1]="${char[tmp]}${ss[-1]}"'                             # hold
semicolon                                                            # ;
inout 1 1

evaluate "' prepend$ alias hold"             ; inline; inout 1 0     # ( c -- ) ( string: $1 -- $2 )
evaluate ': <#       ""  ;'                  ; inline; inout 0 0     # ( -- ) ( string: -- $2 )
evaluate ': #s       begin # dup 0= until ;' ; inout 1 1             # ( x1 -- x2 ) ( string: $1 -- $2 )
evaluate ": sign     0< lest '-' hold ;"     ; inout 1 0             # ( f -- ) ( string: $1 -- $2 )
evaluate "' drop alias #>$"                  ; inline; inout 1 0     # ( x -- )
evaluate ': #>type   #>$ type$ ;'            ; inline; inout 1 0     # ( x -- ) ( string:  $1 -- )
evaluate ': #>       #>$ here here unpack$ ;'; inout 1 2             # ( x -- a n ) ( string:  $1 -- )
evaluate ': uconvert <# #s #>$ ;'            ; inout 1 0             # ( u -- ) (string: -- $1 )
evaluate ': convert  dup abs uconvert sign ;'; inout 1 0             # ( u -- ) (string: -- $1 )
evaluate ': .         convert type$ space ;' ; inout 1 0             # ( n -- )
evaluate ': u.       uconvert type$ space ;' ; inout 1 0             # ( u -- )
evaluate ': .r       >r  convert r> rtype$ ;'; inout 2 0             # ( n u -- )
evaluate ': u.r      >r uconvert r> rtype$ ;'; inout 2 0             # ( u1 u2 -- )

primitive 'decimal'  "m[$base]=10"; inout 0 0
primitive 'hex'      "m[$base]=16"; inout 0 0
primitive 'binary'   "m[$base]=2";  inout 0 0

# ----- foward referencing support words ----------------- #fold01

# forward referencing scheme using dependencies files, which maps
# word names to file names, allowing to locate source of required
# code quickly for inclusion:
#
#  provides:
#     like \ treating rest of line as comment.
#     purpose is to allow grepping libraries for file names
#     providing the words listed there, to generate a simple
#     form of dependency files.
#     Insert it into library files, listing the words which can
#     be resolved by library. Idea is to have very short library
#     files, often just containing a single word.
#
#  dependencies
#     run through library directories and their subdirectories, and
#     look for lines starting with provides:
#     extract the list of names, and write names, one per line, followed
#     by file name, into the "dependencies" file.
#     This build the dependencies "database", and needs only done when
#     dependencies are outdated, stale or missing.
#
#  satisfy
#  needs:
#     these are merely different names for the same function. needs:
#     pairs more nicely with provides: when written into library fragments.
#     These turn forward refs on, parse space delimited strings from input
#     line (the name of needed words). For each word is the library
#     file containing word's source located by searching the dependencies
#     file, the source is included from file, thereby satisfying the
#     forward reference. When done is old forward refs state restored.
#     When a word can't be resolved, due to not having an entry in the
#     dependencies fiel, or the file not existing, a vocabulary based
#     forward reference is created through need. This renders the not
#     included word compilable. When source becomes available (file
#     suddenly existing, or word defined by other means) will the forward
#     reference be cleared, and compiled calls to it associated with the
#     then created word.
#
#  Purpose is to allow library inclusion with much finer granulation than
#  what is possible with including library files which unconditionally
#  include heaps of words, without the need to restructure the libraries
#  towards conditional compilation.
#
#  Above words are more concerned with locating and including source. They
#  don't address the case when a word source doesn't exist (yet). To deal
#  with these words, a supporting word set working on vocabularies exists:

# need can create forward ref even though forward refs are turned off.
# resolving will still be done, that way can specific words (and their
# dependencies) be picked from forward lib.
# arg1: name of needed word,  arg2; referer

# needed is used to test forward reference status of a word. A non-false
# result indicates a forwards referenced word.
# Interpret time flow control words such as lest or unless can be used
# to respond to the result of needed.

# words  have, lack and needed, all returning false or "some" value
# (which could be true, but also an execution token), deliver results
# according to this table:
#
#                         have    lack    needed
# existing word            xt     false   false
# non-existing non-forw   false   true    false
# forward ref word        false   true    true

# reason for this apparent redundancy of having both need/resolve and satisfy
# for resolving yet unresolved words is that satisfy can't be used in some
# situations, when need can. satisfy is unsuited for use while compiling a
# word - most likely will execution of satisfy result in compiling words, and
# we can't do that while already compiling a word, because compilation isn't
# nestable. This disqualifies the use of satisfy for creating forward references
# which arise during compilation - and that's probably the most common case
# where forwards references are created. "Need" OTOH will do nicely there, by
# only registering the need, but leaving it to "resolve" to include code at
# a more appropriate time.


need()  {
   [[ -z "${forth[$1]}" ]] || return                                 # only ask for forward if word isn't in any context voc
   [[ -z "${interpretonly[$1]}" ]] || return
   [[ -z "${compileonly[$1]}" ]] || return
   forwardref "$1"  "$2"                                             # forwardref protects itself against already forwardref'd words
}

colon 'need'                                                         # ( -- )  ( stream: bl delimited string )
   code 'word'
   code 'need "$word" ""'                                            # empty arg indicates explicit need, no referer
semicolon

colon 'needed'                                                       # ( -- f ) ( stream: bl delimited strings, whole input line )
   push "$false"
   code 'while [[ -n "$line" ]]; do'
   code 'word'
   code '[[ -z "${unresolved["$word"]}" ]] || {'                     # check unresolved status of word
   code '((s[sp]=true))'                                             # unresolved -> needed
   code 'line=""'                                                    # "wired or" - one needed is enough, skip rest
   code '}'
   code 'done'
semicolon

primitive 'have'   'have'                                            # ( -- f ) ( stream: bl delimited string )    word exists?
evaluate ': lack  have 0= ;'                                         # ( -- f ) ( stream: bl delimited string )    word missing?

generate_dependencies()  {                                           # library inclusion dependency file builder
   { echo "$v version"
     grep -r "^provides: " "${libdirs[0]}"
   } | while read -r file words; do
      file="${file%:provides:}"
      file="${file#"${libdirs[0]}"/}"
# "Double quote to prevent globbing and word splitting."
# I actually *want* word splitting here, for fprint to produce one line per space delimited word
# shellcheck disable=SC2086
      printf "%-31s $file\n" $words
   done > "$dependencies"
}

cache_dependencies()  {
   while read -r word file _; do
   lib["$word"]="$file"
   done < "$dependencies"
}

dependencies()  {                                                    # library inclusion dependency file builder
   generate_dependencies
   cache_dependencies
}

# try to resolve all words given on input line.
# args:  names of words
satisfy()  {
   local line
# SC2068 (error): Double quote array expansions to avoid re-splitting elements:
# I don't want to avoid re-splitting, I want re-splitting to happen.
#shellcheck disable=2068
   for word in $@; do
      satisfy1 "$word" || notfound "$word"
   done
}

primitive 'dependencies' 'dependencies'                              # generate, then cache
primitive "provides:"   'line=""'        ;   interpreted             # double quoted escaped backslash rather than

colon 'satisfy'
   code  'satisfy "$line"'
   code  'line=""'
semicolon

evaluate "' satisfy alias needs:"

# satisfy references from top string stack item
# ( $1 -- )
colon 'satisfy$'
   code 'satisfy "${ss[-1]}"'
   code 'unset "ss[-1]"'
semicolon


# ----- documentation ------------------------------------ #fold01

# arg1: word name
# arg2: headerlist
undoc_template()  {
cat << EOF
created:             auto     (remove line after having checked and revised description)
name:                $1
stack:               ( -- )
return stack:        ( -- )
string stack:        ( -- )
contexts:            ${2#"headers"}
category:
input stream:

decription:          none

example:             none
notes:               none
EOF
}

# changes problematic chars in arg1.
# sanitised string is returned in variable file
declare -A sanitise=(
   ['/']="slash"
   ["\\"]="backslash"
   [';']="semi"
   ['$']="dollar"
   ['>']="gt"
   ['<']="ls"
   ['!']="excl"
   ['#']="hash"
   ["'"]="tick"
   ['?']="qmrk"
   ['*']="star")
sanitise()  {
   file="$1"
   for tmp in "${!sanitise[@]}"; do
      file="${file//"$tmp"/"[${sanitise[$tmp]}]"}"
   done
}

undoc()  {
   for list in "${wordlists[@]}" "interpretonly" "compileonly"; do
      local headers
      declare -n headers="$list"
      for word in "${!headers[@]}"; do                               # run through all headers
         sanitise "$word"
         [[ -f "$worddoc:$file" ]] || {                              # found one for which no doc file exists
            undoc_template "$word" "${!headers}" >> "$worddoc:$file"
            editor "$worddoc:$file"
            return
         }
      done
   done
}
primitive 'undoc' 'undoc'

# candidates for $command further down
doc()  {
   sanitise "$1"
   editor "$worddoc:$file"
}

about()  {
   sanitise "$1"
   cat "$worddoc:$file"
}

colon 'doc'
   code 'word'
   code 'doc "$word"'
semicolon

colon 'about'
   code 'word'
   code 'about "$word"'
semicolon


# ----- interactive mode --------------------------------- #fold01

evaluate ': quit warm begin query$ evaluate$ resolve prompt again ;'
evaluate "' quit alias abort"
evaluate ': ?abort  if abort then ;'                                 # ( f -- )

# ----- shell ---------------------------------------------
# TODO: optimiser: invalidate all stack register contents
# execute shell command "$2" with args "$1"
colon 'shell$'
   code '${ss[-1]}'
   code 'unset "ss[-1]"'
semicolon

colon 'command$'
   code '${ss[-2]} "${ss[-1]}"'
   code 'unset "ss[-1]"'
   code 'unset "ss[-1]"'
semicolon



# ----- files -------------------------------------------- #fold01



# push name of file u (from output of files) to string stack
# ( u -- ) ( string: -- $1 )
colon 'filename$'
   code 'ss+=("${files[s[sp--]]}")'
semicolon
inline

evaluate ': edit  "editor" filename$  command$ ;'
evaluate ': list  "cat"    filename$  command$ ;'

# return handle of source. 0=console, >0 correspond files handle
# allows words to determine whether they're executed while loaded
# from file or console, as well as the path/name of the file they're
# loaded from.
# ( -- u )
colon 'origin'
   push '${filehandle:-"0"}'
semicolon
inline
inout 0 1

# better symmetry with thisfile$
evaluate "' origin alias thisfile"

# copy remainder of input line to string stack without affecting it.
# ( -- )  ( -- $1 )
primitive 'source$'  'ss+=("$line")'

# check whether current source had already been compiled from before.
# most useful when used interpretatively in a file, for testing whether
# it will be or has been reloaded, such as with "loaded lest done"
# ( -- f )
colon 'loaded'
   push 'loaded[filehandle]'
semicolon

colon 'loading'
   push 'linenr<0?false:true '
semicolon

# stop loading file
colon 'done'
   code 'line=""'                                                    # nothing more to process on current line
   code 'linenr="-1"'                                                # signal "all done" to from
semicolon

evaluate ': once   loaded lest done ;'

# produce name of currently loaded file
# ( string: -- $1 )
evaluate ': thisfile$  thisfile filename$ ;'

colon 'where$'
    code 'tmp="${ss[-1]}"'                                           # name of word to look up
    code 'unset "ss[-1]"'
    code '[[ -z "$tmp" ]]&&emptyname'                                # no name given
    code 'tmp1="${where[$tmp]}"'                                     # "file:line"
    code '((${tmp1%%:*}))||nosource "$tmp"'                          # file handle empty or 0: no source available
    push '${tmp1%%:*}'                                               # push file handle
    push '${tmp1##*:}'                                               # push line number
semicolon

# ( -- )  ( input: word )
evaluate ': where word$ where$ swap filename$ type$ [char] : emit u. ;'



# ----- convenience -------------------------------------- #fold01
primitive empty  's=() sp=0'
primitive rempty 'r=() rp=0'

# empty stack and string stack
# since warm doesn't empty them any longer, a convenient
# way to do so manually was needed.
evaluate ': _  empty rempty empty$  ;'                ; inline
primitive 'words'    'words'
primitive 'random'   '((s[++sp]=SRANDOM&true))'; inout 0 1           # ( -- u )        32 bits random number
primitive 'realtime' '((s[++sp]=${EPOCHREALTIME//[,.]/}&true))';     # a microseconds epoch, used for benchmarking
primitive 'secs'     'sleep "${s[sp--]}"'

colon 'version'
   push '${version[0]}'
   push '${version[1]}'
   push '${version[2]}'
semicolon

# ----- experimental ------------------------------------- #fold01


# ----- launch ------------------------------------------- #fold00

# shellcheck source=./yoda.conf                                      # try to load custom configuration
config()  {
   [[ -f "$HOME/$config" ]]  && { source "$HOME/$config"; return; }  # config in $HOME has priority over config in yoda dir
   [[ -f "$mydir/$config" ]] && source "$mydir/$config"
}
config
[[ -f "$dependencies" ]] || generate_dependencies                    # no dependencies -> generate
read -r _ tmp < <(grep '^version ' "$dependencies")                  # check version
[[ "$tmp" == "$v" ]] || generate_dependencies                        # new yoda -> generate
cache_dependencies                                                   # read dependencies into memory
args=("$@")                                                          # read command line
(( ${#args[@]} )) || read -rst 0.01 "args"                           # no command line specified: check whether commands are piped
[[ -z ${args[0]} ]] && args[0]="$default"                            # neither pipe nor command line: load default launch commands
files[1]="$(realpath "$0")"                                          # handles: 0=tty, 1=yoda, others added as they're loaded
evaluate "${args[*]}"                                                # evaluate piped command, command line or default initial commands
if [[ -n "$coldvector" ]]; then                                      # if cold launch point was specified, try to run.
   resolve                                                           # still unresolved words? try to resolve those.
   if (( ${#unresolved[@]} )); then                                  # still unresolved words
      printf "%s\n" "unresolved forward references:"
      printf "%s\n" "${!unresolved[@]}"
      printf "%s\n" "Run this not I will."
   else
      cold
   fi
fi
