hex


\ ------------------------------------------------------------------------
testing here , @ ! cell+ cells c, c@ c! chars 2@ 2! align aligned +! allot

here 1 allot
here
constant 2nda
constant 1sta
t{ 1sta 2nda u< -> <true> }t      \ here must grow with allot
t{ 1sta 1+ -> 2nda }t         \ ... by one address unit
( missing test: negative allot )

\ added by gwj so that align can be used before , (comma) is tested
1 aligned constant almnt   \ -- 1|2|4|8 for 8|16|32|64 bit alignment
align
t{ here 1 allot align here swap - almnt = -> <true> }t
\ end of extra test

t{ 1st 2nd u< -> <true> }t         \ here must grow with allot
t{ 1st cell+ -> 2nd }t         \ ... by one cell
t{ 1st 1 cells + -> 2nd }t
t{ 1st @ 2nd @ -> 1 2 }t
t{ 5 1st ! -> }t
t{ 1st @ 2nd @ -> 5 2 }t
t{ 6 2nd ! -> }t
t{ 1st @ 2nd @ -> 5 6 }t
t{ 1st 2@ -> 6 5 }t
t{ 2 1 1st 2! -> }t
t{ 1st 2@ -> 2 1 }t
t{ 1s 1st !  1st @ -> 1s }t      \ can store cell-wide value

t{ 1stc 2ndc u< -> <true> }t      \ here must grow with allot
t{ 1stc char+ -> 2ndc }t         \ ... by one char
t{ 1stc 1 chars + -> 2ndc }t
t{ 1stc c@ 2ndc c@ -> 1 2 }t
t{ 3 1stc c! -> }t
t{ 1stc c@ 2ndc c@ -> 3 2 }t
t{ 4 2ndc c! -> }t
t{ 1stc c@ 2ndc c@ -> 3 4 }t

t{ ua-addr aligned -> a-addr }t
t{    1 a-addr c!  a-addr c@ ->    1 }t
t{ 1234 a-addr  !  a-addr  @ -> 1234 }t
t{ 123 456 a-addr 2!  a-addr 2@ -> 123 456 }t
t{ 2 a-addr char+ c!  a-addr char+ c@ -> 2 }t
t{ 3 a-addr cell+ c!  a-addr cell+ c@ -> 3 }t
t{ 1234 a-addr cell+ !  a-addr cell+ @ -> 1234 }t
t{ 123 456 a-addr cell+ 2!  a-addr cell+ 2@ -> 123 456 }t

\ : bits ( x -- u )
\    0 swap begin dup while dup msb and if >r 1+ r> then 2* repeat drop ;
( characters >= 1 au, <= size of cell, >= 8 bits )
t{ 1 chars 1 < -> <false> }t
t{ 1 chars 1 cells > -> <false> }t
( tbd: how to find number of bits? )

( cells >= 1 au, integral multiple of char size, >= 16 bits )
t{ 1 cells 1 < -> <false> }t
t{ 1 cells 1 chars mod -> 0 }t


\ t{ 1s bits 10 < -> <false> }t
t{ bits 8 < -> <false> }t


t{ 0 1st ! -> }t
t{ 1 1st +! -> }t
t{ 1st @ -> 1 }t
t{ -1 1st +! 1st @ -> 0 }t

\ ------------------------------------------------------------------------
testing char [char] [ ] bl s"

t{ bl -> 20 }t
t{ char X -> 58 }t
t{ char HELLO -> 48 }t
t{ : gc1 [char] X ; -> }t
t{ : gc2 [char] HELLO ; -> }t
t{ gc1 -> 58 }t
t{ gc2 -> 48 }t
t{ : gc3 [ gc1 ] literal ; -> }t
t{ gc3 -> 58 }t
\ t{ : gc4 s" xy" ; -> }t
\ t{ gc4 swap drop -> 2 }t
\ t{ gc4 drop dup c@ swap char+ c@ -> 58 59 }t

\ ------------------------------------------------------------------------
testing ' ['] find execute immediate count literal postpone state

t{ : gt1 123 ; -> }t
t{ ' gt1 execute -> 123 }t
t{ : gt2 ['] gt1 ; immediate -> }t
t{ gt2 execute -> 123 }t
here 3 c, char g c, char t c, char 1 c, constant gt1string
here 3 c, char g c, char t c, char 2 c, constant gt2string

omit
t{ gt1string find -> ' gt1 -1 }t
t{ gt2string find -> ' gt2 1 }t

( how to search for non-existent word? )
t{ : gt3 gt2 literal ; -> }t
t{ gt3 -> ' gt1 }t
t{ gt1string count -> gt1string char+ 3 }t

t{ : gt4 postpone gt1 ; immediate -> }t
t{ : gt5 gt4 ; -> }t
t{ gt5 -> 123 }t
t{ : gt6 345 ; immediate -> }t
t{ : gt7 postpone gt6 ; -> }t
t{ gt7 -> 345 }t

t{ : gt8 state @ ; immediate -> }t
t{ gt8 -> 0 }t
t{ : gt9 gt8 literal ; -> }t
t{ gt9 0= -> <false> }t

\ ------------------------------------------------------------------------
testing if else then begin while repeat until recurse

t{ : gi1 if 123 then ; -> }t
t{ : gi2 if 123 else 234 then ; -> }t
t{ 0 gi1 -> }t
t{ 1 gi1 -> 123 }t
t{ -1 gi1 -> 123 }t
t{ 0 gi2 -> 234 }t
t{ 1 gi2 -> 123 }t
t{ -1 gi1 -> 123 }t

t{ : gi3 begin dup 5 < while dup 1+ repeat ; -> }t
t{ 0 gi3 -> 0 1 2 3 4 5 }t
t{ 4 gi3 -> 4 5 }t
t{ 5 gi3 -> 5 }t
t{ 6 gi3 -> 6 }t

t{ : gi4 begin dup 1+ dup 5 > until ; -> }t
t{ 3 gi4 -> 3 4 5 6 }t
t{ 5 gi4 -> 5 6 }t
t{ 6 gi4 -> 6 7 }t

omit
t{ : gi5 begin dup 2 >
         while dup 5 < while dup 1+ repeat 123 else 345 then ; -> }t
t{ 1 gi5 -> 1 345 }t
t{ 2 gi5 -> 2 345 }t
t{ 3 gi5 -> 3 4 5 123 }t
t{ 4 gi5 -> 4 5 123 }t
t{ 5 gi5 -> 5 123 }t

t{ : gi6 ( n -- 0,1,..n ) dup if dup >r 1- recurse r> then ; -> }t
t{ 0 gi6 -> 0 }t
t{ 1 gi6 -> 0 1 }t
t{ 2 gi6 -> 0 1 2 }t
t{ 3 gi6 -> 0 1 2 3 }t
t{ 4 gi6 -> 0 1 2 3 4 }t

\ ------------------------------------------------------------------------
testing do loop +loop i j unloop leave exit

t{ : gd1 do i loop ; -> }t
t{ 4 1 gd1 -> 1 2 3 }t
t{ 2 -1 gd1 -> -1 0 1 }t
t{ mid-uint+1 mid-uint gd1 -> mid-uint }t

t{ : gd2 do i -1 +loop ; -> }t
t{ 1 4 gd2 -> 4 3 2 1 }t
t{ -1 2 gd2 -> 2 1 0 -1 }t
t{ mid-uint mid-uint+1 gd2 -> mid-uint+1 mid-uint }t

t{ : gd3 do 1 0 do j loop loop ; -> }t
t{ 4 1 gd3 -> 1 2 3 }t
t{ 2 -1 gd3 -> -1 0 1 }t
t{ mid-uint+1 mid-uint gd3 -> mid-uint }t

t{ : gd4 do 1 0 do j loop -1 +loop ; -> }t
t{ 1 4 gd4 -> 4 3 2 1 }t
t{ -1 2 gd4 -> 2 1 0 -1 }t
t{ mid-uint mid-uint+1 gd4 -> mid-uint+1 mid-uint }t

t{ : gd5 123 swap 0 do i 4 > if drop 234 leave then loop ; -> }t
t{ 1 gd5 -> 123 }t
t{ 5 gd5 -> 123 }t
t{ 6 gd5 -> 234 }t

t{ : gd6  ( pat: t{0 0},{0 0}{1 0}{1 1},{0 0}{1 0}{1 1}{2 0}{2 1}{2 2} )
   0 swap 0 do
      i 1+ 0 do i j + 3 = if i unloop i unloop exit then 1+ loop
    loop ; -> }t
t{ 1 gd6 -> 1 }t
t{ 2 gd6 -> 3 }t
t{ 3 gd6 -> 4 1 2 }t

\ ------------------------------------------------------------------------
testing defining words: : ; constant variable create does> >body

t{ 123 constant x123 -> }t
t{ x123 -> 123 }t
t{ : equ constant ; -> }t
t{ x123 equ y123 -> }t
t{ y123 -> 123 }t

t{ variable v1 -> }t
t{ 123 v1 ! -> }t
t{ v1 @ -> 123 }t

t{ : nop : postpone ; ; -> }t
t{ nop nop1 nop nop2 -> }t
t{ nop1 -> }t
t{ nop2 -> }t

omit
t{ : does1 does> @ 1 + ; -> }t
t{ : does2 does> @ 2 + ; -> }t
t{ create cr1 -> }t
t{ cr1 -> here }t
t{ ' cr1 >body -> here }t
t{ 1 , -> }t
t{ cr1 @ -> 1 }t
t{ does1 -> }t
t{ cr1 -> 2 }t
t{ does2 -> }t
t{ cr1 -> 3 }t

omit
t{ : weird: create does> 1 + does> 2 + ; -> }t
t{ weird: w1 -> }t
t{ ' w1 >body -> here }t
t{ w1 -> here 1 + }t
t{ w1 -> here 2 + }t

\ ------------------------------------------------------------------------
testing evaluate

omit
: ge1 s" 123" ; immediate
: ge2 s" 123 1+" ; immediate
: ge3 s" : ge4 345 ;" ;
: ge5 evaluate ; immediate

: ge1 "123"         >pad ; immediate
: ge2 "123 1+"      >pad ; immediate
: ge3 ": ge4 345 ;" >pad ;
: ge5 evaluate ; immediate

t{ ge1 evaluate -> 123 }t         ( test evaluate in interp. state )
t{ ge2 evaluate -> 124 }t
t{ ge3 evaluate -> }t
t{ ge4 -> 345 }t

t{ : ge6 ge1 ge5 ; -> }t         ( test evaluate in compile state )
t{ ge6 -> 123 }t
t{ : ge7 ge2 ge5 ; -> }t
t{ ge7 -> 124 }t

\ ------------------------------------------------------------------------

omit
testing source >in word
: gs1 "source" >pad 2dup evaluate
       >r swap >r = r> r> = ;
t{ gs1 -> <true> <true> }t

omit
variable scans
: rescan?  -1 scans +! scans @ if 0 >in ! then ;
t{ 2 scans !
345 rescan?
-> 345 345 }t

omit
: gs2  5 scans ! s" 123 rescan?" evaluate ;
t{ gs2 -> 123 123 123 123 123 }t

omit
: gs3 word count swap c@ ;
t{ bl gs3 hello -> 5 char h }t
t{ char " gs3 goodbye" -> 7 char g }t
t{ bl gs3
drop -> 0 }t            \ blank line return zero-length string

omit
: gs4 source >in ! drop ;
t{ gs4 123 456
-> }t

\ ------------------------------------------------------------------------
testing <# # #s #> hold sign base >number hex decimal

: s=  \ ( addr1 c1 addr2 c2 -- t/f ) compare two strings.
   >r swap r@ = if         \ make sure strings have same length
      r> ?dup if         \ if non-empty strings
    0 do
       over c@ over c@ - if 2drop <false> unloop exit then
       swap char+ swap char+
         loop
      then
      2drop <true>         \ if we get here, strings match
   else
      r> drop 2drop <false>      \ lengths mismatch
   then ;

: gp1  <# 41 hold 42 hold 0 0 #> "BA" >pad s= ;
t{ gp1 -> <true> }t

: gp2  <# -1 sign 0 sign -1 sign 0 0 #> "--" >pad s= ;
t{ gp2 -> <true> }t

: gp3  <# 1 0 # # #> "01" >pad s= ;
t{ gp3 -> <true> }t

: gp4  <# 1 0 #s #> "1" >pad s= ;
t{ gp4 -> <true> }t

24 constant max-base         \ base 2 .. 36
\ : count-bits
\   0 0 invert begin dup while >r 1+ r> 2* repeat drop ;
\ count-bits 2* constant #bits-ud      \ number of bits in ud

: gp5
   base @ <true>
   max-base 1+ 2 do         \ for each possible base
      i base !            \ tbd: assumes base works
      i 0 <# #s #> "10" >pad s= and
   loop
   swap base ! ;
t{ gp5 -> <true> }t

: gp6
   base @ >r  2 base !
   max-uint max-uint <# #s #>      \ maximum ud to binary
   r> base !            \ s: c-addr u
   dup #bits-ud = swap
   0 do               \ s: c-addr flag
      over c@ [char] 1 = and      \ all ones
      >r char+ r>
   loop swap drop ;
t{ gp6 -> <true> }t

omit
: gp7
   base @ >r    max-base base !
   <true>
   a 0 do
      i 0 <# #s #>
      1 = swap c@ i 30 + = and and
   loop
   max-base a do
      i 0 <# #s #>
      1 = swap c@ 41 i a - + = and and
   loop
   r> base ! ;
t{ gp7 -> <true> }t

\ >number tests
create gn-buf 0 c,
: gn-string   gn-buf 1 ;
: gn-consumed   gn-buf char+ 0 ;
: gn'      [char] ' word$ >pad char+ c@ gn-buf c!  gn-string ;

omit
t{ 0 0 gn' 0' >number -> 0 0 gn-consumed }t
t{ 0 0 gn' 1' >number -> 1 0 gn-consumed }t
t{ 1 0 gn' 1' >number -> base @ 1+ 0 gn-consumed }t
t{ 0 0 gn' -' >number -> 0 0 gn-string }t   \ should fail to convert these
t{ 0 0 gn' +' >number -> 0 0 gn-string }t
t{ 0 0 gn' .' >number -> 0 0 gn-string }t

omit
: >number-based
   base @ >r base ! >number r> base ! ;

omit
t{ 0 0 gn' 2' 10 >number-based -> 2 0 gn-consumed }t
t{ 0 0 gn' 2'  2 >number-based -> 0 0 gn-string }t
t{ 0 0 gn' f' 10 >number-based -> f 0 gn-consumed }t
t{ 0 0 gn' g' 10 >number-based -> 0 0 gn-string }t
t{ 0 0 gn' g' max-base >number-based -> 10 0 gn-consumed }t
t{ 0 0 gn' z' max-base >number-based -> 23 0 gn-consumed }t

omit
: gn1   \ ( ud base -- ud' len ) ud should equal ud' and len should be zero.
   base @ >r base !
   <# #s #>
   0 0 2swap >number swap drop      \ return length only
   r> base ! ;
t{ 0 0 2 gn1 -> 0 0 0 }t
t{ max-uint 0 2 gn1 -> max-uint 0 0 }t
t{ max-uint dup 2 gn1 -> max-uint dup 0 }t
t{ 0 0 max-base gn1 -> 0 0 0 }t
t{ max-uint 0 max-base gn1 -> max-uint 0 0 }t
t{ max-uint dup max-base gn1 -> max-uint dup 0 }t

: gn2   \ ( -- 16 10 )
   base @ >r  hex base @  decimal base @  r> base ! ;
t{ gn2 -> 10 a }t

\ ------------------------------------------------------------------------
testing fill move

create fbuf 00 c, 00 c, 00 c,
create sbuf 12 c, 34 c, 56 c,
: seebuf fbuf c@  fbuf char+ c@  fbuf char+ char+ c@ ;

t{ fbuf 0 20 fill -> }t
t{ seebuf -> 00 00 00 }t

t{ fbuf 1 20 fill -> }t
t{ seebuf -> 20 00 00 }t

t{ fbuf 3 20 fill -> }t
t{ seebuf -> 20 20 20 }t

t{ fbuf fbuf 3 chars move -> }t      \ bizarre special case
t{ seebuf -> 20 20 20 }t

t{ sbuf fbuf 0 chars move -> }t
t{ seebuf -> 20 20 20 }t

t{ sbuf fbuf 1 chars move -> }t
t{ seebuf -> 12 20 20 }t

t{ sbuf fbuf 3 chars move -> }t
t{ seebuf -> 12 34 56 }t

t{ fbuf fbuf char+ 2 chars move -> }t
t{ seebuf -> 12 12 34 }t

t{ fbuf char+ fbuf 2 chars move -> }t
t{ seebuf -> 12 34 34 }t

\ ------------------------------------------------------------------------
testing output: . ." cr emit space spaces type u.

: output-test
   "you should see the standard graphic characters:" type$ cr
   41 bl do i emit loop cr
   61 41 do i emit loop cr
   7f 61 do i emit loop cr
   "you should see 0-9 separated by a space:" type$ cr
   9 1+ 0 do i . loop cr
   "you should see 0-9 (with no spaces):" type$ cr
   [char] 9 1+ [char] 0 do i 0 spaces emit loop cr
   "you should see a-g separated by a space:" type$ cr
   [char] g 1+ [char] a do i emit space loop cr
   "you should see 0-5 separated by two spaces:" type$ cr
   5 1+ 0 do i [char] 0 + emit 2 spaces loop cr
   "you should see two separate lines:" type$ cr
   "line 1" >pad type cr "line 2" >pad type cr
   "you should see the number ranges of signed and unsigned numbers:" type$ cr
   "signed: " type$  min-int . max-int . cr
   "unsigned: " type$  0 u. max-uint u. cr
;

t{ output-test -> }t


\ ------------------------------------------------------------------------

omit
testing input: accept
create abuf 50 chars allot
: accept-test
   cr "please type up to 80 characters:" type$ cr
   abuf 50 accept
   cr "received: " type$ [char] " emit
   abuf swap type [char] " emit cr
;
t{ accept-test -> }t

\ ------------------------------------------------------------------------
testing dictionary search rules

t{ : gdx   123 ; : gdx   gdx 234 ; -> }t

t{ gdx -> 123 234 }t

cr "end of core word set tests" type$ cr


