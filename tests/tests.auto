#!/usr/local/bin/yoda from

\ 512 bits good enough?  not using - or invert or bool stuff, as those haven't been tested yet. Well, neither has constant
\ (yoda silently removes allöextra bits above its preset cell width)
$00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 constant 0s
$ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff constant 1s

1s constant <true>
0s constant <false>
bits 2* constant #bits-ud

#36 constant max-base
0 invert constant max-uint
0 invert 1 rshift constant max-int
0 invert 1 rshift invert constant min-int
0 invert 1 rshift constant mid-uint
0 invert 1 rshift invert constant mid-uint+1

testsection test values
t{ max-uint   -> maxuint }t
t{ max-int    -> maxint  }t
t{ min-int    -> msb     }t
t{ mid-uint   -> maxint  }t
t{ mid-uint+1 -> msb     }t


decimal
testsection number input
t{ #1289       -> 1289        }t
t{ $12ef       -> 4847        }t
t{ %10010110   -> 150         }t
t{ 'z'         -> 122         }t

testsection postpone
t{ : gt1 123 ; -> }t
t{ : gt4 postpone gt1 ; immediate -> }t
t{ : gt5 gt4 ; -> }t
t{ gt5 -> 123 }t
t{ : gt6 345 ; immediate -> }t
t{ : gt7 postpone gt6 ; -> }t
t{ gt7 -> 345 }t

testsection abs
t{       0 abs ->          0 }t
t{       1 abs ->          1 }t
t{      -1 abs ->          1 }t
t{ min-int abs -> mid-uint+1 }t
: foo  abs ;  transient
t{       0 foo ->          0 }t
t{       1 foo ->          1 }t
t{      -1 foo ->          1 }t
t{ min-int foo -> mid-uint+1 }t

testsection allot
here 1 allot
here
constant 2nda  transient
constant 1sta  transient
t{ 1sta 2nda u< -> <true> }t    \ here must grow with allot
t{      1sta 1+ ->   2nda }t    \ ... by one address unit
( missing test: negative allot )



testsection pictured number conversion
: gp3 <# 1 0 # # #>  pack$ "01" $= ;   transient
t{ gp3 -> <true> }t

: gp4 <# 1 0 #s #>   pack$ "1"  $= ;   transient
t{ gp4 -> <true> }t

: gp5
   base @ <true>
   max-base 1+ 2 do        \ for each possible base
     i base !              \ tbd: assumes base works
       i 0 <# #s #>  pack$ "10" $= and
   loop
   swap base ! ;                       transient

t{ gp5 -> <true> }t

: gp6
   base @ >r 2 base !
   max-uint max-uint <# #s #>       \ maximum ud to binary
   r> base !                        \ s: c-addr u
   dup #bits-ud = swap
   0 do                             \ s: c-addr flag
     over c@ [char] 1 = and         \ all ones
     >r char+ r>
   loop swap drop ;                    transient
\ t{ gp6 -> <true> }t
done
: gp7
   base @ >r max-base base !
   <true>
   $a 0 do
     i 0 <# #s #>
     1 = swap c@ i '0' + = and and
   loop
   max-base a do
     i 0 <# #s #>
     1 = swap c@ 41 i a - + = and and
   loop
   r> base ! ;  transient
t{ gp7 -> <true> }t

