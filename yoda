#!/bin/bash

# ----- about -------------------------------------------- #fold00
# yoda is an acronym of Yet Onather Delirious Application, and does
# naturally not refer to any greenish midget with pointy ears, albeit
# it had been said that reading yoda source aloud sounds like the very
# same midget talking.
# yoda implements a compiler which converts a close resemblance of Forth
# source code to bash functions, an interpreter which runs them, and
# a base vocabulary of useful functions, strongly orientated towards
# what a common Forth interpreter offers.
# What learned you have, unlearn you must!

# editor used is efte, folds in source files are therefore efte compatible.

# ----- versions ----------------------------------------- #fold00
# I think we're about ready for approaching version 1.0, so lets start counting.
# date is post-gregorian Sol3, time is UTC
# invoke shellcheck with:    shellcheck -x yoda.
# shellcheck disable=SC2016 disable=SC2034 disable=SC2154
# SC2016: "expressions don't expand between single quotes"
#         right, that's the reason for using single quotes there.
# SC2034  # "appears unused. Verify use (or export if used externally)"
#         mostly, "appears" is the correct term
# SC2154 "(warning): base is referenced but not assigned."
#        is assigned, but shellcheck can't see how


version=0  subversion=4
subsubversion=2             # 2022jan14,14:47   one based files with tty as 0
subsubversion=1             # 2022jan12,04:03   early version of automated testing.
                            #                   converted many colon to primitive. literal became push.
#version=0  subversion=4    # 2022jan10,04:13   pulled yoda and primitives together into a single file
#version=0  subversion=3    # 2022jan07,22:31   any data item can be ticked now, so can words create by defining word using create ... does>
#version=0  subversion=2    # 2021dec29,16:04
#version=0  subversion=1    # 2021dec20,14:57

# ----- declarations ------------------------------------- #fold00

shopt -s extglob
shopt -u nullglob
GLOBIGNORE='*:?'

config="yoda.conf"                                                   # name of configuration file which may override any of the below settings
trace=0                                                              # turn chatty system on
log=0                                                                # turn logging on
break=2                                                              # break will return (0), exit (1) or execute coldvector (2)
clean=1                                                              # empty stack on error/ctrl-c
codedump=0

read -r tmp _ < <(realpath "$0")
mydir="${tmp%/*}"

doc="$mydir/doc"                                                     # documentation base directory
worddoc_prefix="word"                                                # used as part of file names, prevents files to go hidden by leading period
worddoc="$doc/words/$worddoc_prefix"                                 # directory of words documentation, also first part of word doc file name

# only first added directory - and its subdirectories - can
# contain forward referencable libs.
libdirs=()                                                           # array of possible library paths
for dir in "$mydir/lib" "$mydir" "/usr/local/lib/yoda"; do           # loop through directory candidates
   [[ -d "$dir" ]] && libdirs+=("$dir")                              # add directory if existing
done

logfile="$mydir/yoda.log"
rm -f "$logfile"                                                     # each run starts with a fresh log

header_code="yoda"                                                   # prefix to bash function names,  _${nextname} will be appended upon header creation
nextname="1000"                                                      # names enumeration, initially. Can be any positive integer

declare -ai r=() s=() m=()
declare -i sp=0 rp=0 dp=0
declare -a ss=()

declare -i s1 s2 s3 s4                                               # temp variables to hold stack items s[-1] ... s[-4]
                                                                     # easier to read than "tmp, tmp2"
declare -Ai flags                                                    # header flags (only inline left for now)
headerslistlist=(
         "headersstateless"                                          # searched during both interpreting and compiling
         "headersinterpretonly"                                      # searched during compiling only
         "headerscompileonly")                                       # searched during interpreting only

declare -n headers="headersstateless"                                # headers is a vector- or pointer variable.
for tmp in "${headerslistlist[@]}"; do
   declare -A "$tmp"
done

declare -a names                                                     # function name -> word name lookup
declare -A headersunresolved                                         # forward referenced. Not searched.
declare -A wherefile                                                 # source file
declare -A whereline                                                 # source line
declare -a files
declare -a loaded
files[0]="tty"
declare -A doescode                                                  # items associated with defining word. Detokeniser extracted code
                                                                     # following does> to make it more easily available to dodoes
declare -a lasterror
lasterror=("" "-1" "0")

# header flags:
flagscount="0"
inline=$((1<<flagscount++))                                          # compile function code rather than calls to function


# all 0: don't optimise, copy literal code
analyserflag="0"                                                     # shift by this number for next flag
functionheader="$((1<<analyserflag++))"                              # create header
atomiccode="$((1<<analyserflag++))"                                  # expand
literalnumber="$((1<<analyserflag++))"                               # generate code to push number
flowcontrol="$((1<<analyserflag++))"                                 # help recognise optimisation boundaries
optimisationboundary="$((1<<analyserflag++))"
literalstring="$((1<<analyserflag++))"                               # probably unnecessary
inlined="$((1<<analyserflag++))"                                     # probably useless
does="$((1<<analyserflag++))"                                        # probably useless

# when stack effect of words is known to optimiser, it will have
# the possibility to determine whether stack items cached in
# variables can remain and passed in there, rather than pushing
# them out to stack, only to be retrieved again by next word.
declare -A stackin=()
declare -A stackout=()

declare -A atom                                                      # a table with token -> code mappings.

default='boot quit "yoda shell" type$ cr prompt  satisfy fix'        # what to execute when no command line args given

# ----- state variables, switches, globals, static etc --- #fold00
bits=63                                                              # Can't use 64 bit - bash doesn't know unsigned. 63 bit is best I can do for now.
#bits=32
#bits=21                                                              # covers 6 decimal digits signed numeric space
#bits=20                                                              # 20 bits, unusual but not impractical. 8086 address space
#bits=16                                                              # 16 bits, a tad retro
#bits=11                                                              # covers 3 decimal digits signed numeric space
#bits=8                                                               # 8 bits are nice for testing

msb="$((1<<(bits-1)))"
maxint="$((msb-1))"
maxuint="$((maxint|msb))"

compiling=0                                                          # state flag: interpreting or compiling
line=""                                                              # source line being worked on. modified during parsing and processing
word=""                                                              # bl delimited string from line currently being processed
lastword=""                                                          # most recently created word, set by create.

editor="vi"
#xeditor="efte"
[[ -n "$editor" ]]  && editor()  { $editor "$@"; }                   # used with doc, edit
[[ -n "$xeditor" ]] && {
   editor()  { $xeditor "$@" & }                                     # used with doc, edit
   editor="$xeditor"
}

magic="$((RANDOM+100000))"                                           # flow control and : ;  use these to check structure
remagic()  { ((magic+=RANDOM+10000)); }


declare -A asc=()                                                    # ascii table
declare -a char=()                                                   # character table
for i in {1..255}; do                                                # ascii->char LUT for emit, pack$, char$
   char[i]="$(echo -en "\\x$(printf "%x" "$i")")"
   ((i == 10)) || asc["${char[i]}"]="$i"                             # linefeed is invalid hash key
done


# ----- diagnostics  ------------------------------------- #fold00

comp=("" ":")
trace()  {
   ((trace)) &&
   printf "### %-1s %-20s %s\n" "${comp[compiling & 1]}" "[${FUNCNAME[1]}]" "$@"
#                                                 ^^^  convert any non-zero to 1, used as array index
}

logindent=0
log()  {
   ((log)) && {
      tmp="$((${#headersunresolved[@]}))"
      ((tmp))&&tmp="[$tmp]"||tmp=""
      printf "%-26s-> %-16s %5s%${logindent}s %s\n" "${FUNCNAME[2]}" "${FUNCNAME[1]}" "$tmp" "" "$@" >> "$logfile"
   }
}

logplus()  { log "$@"; ((logindent+=2)) ; }
logminus() { ((logindent+=-2)); log "$@"; }


pretend()         { echo "${FUNCNAME[1]} pretends to $*"; }          # placeholder for use in unfinished code


# ----- compiler muting ---------------------------------- #fold00

derestricted=1                                                       # conditional compilation can turn off code generation
restrict()   { derestricted=0; }
derestrict() { derestricted=1; }
restricted() { return "$derestricted"; }                             # flag current state
derestrict

# ----- ANSI/VT100 attributes ---------------------------- #fold00

# use in error and prompt.
   redfg='31'
   redbg='41'
   greenfg='32'
   greenbg='42'
   normal='0'
#   italics='3'
#   underscore='4'
#   reverse='7'


# ----- headers ------------------------------------------ #fold00

#setheaderflag()  { (( flags["$lastword"] |= "$1" )); }              # a bash glitch doesn't allow me to use this form, because it produces errors with
                                                                     # some array keys like "'".
setheaderflag()  {                                                   # where against this form has no problem with those,
   flags["$lastword"]="$(( ${flags["$lastword"]} | "$1" ))"
}

inline()     { setheaderflag "$inline" ; }

# move header to compiler context vocabulary
immediate()  {
   headerscompileonly["$lastword"]="${headersstateless["$lastword"]}"
   unset -v 'headersstateless["$lastword"]'
}

# move header to interpreter context vocabulary
interactive()   {
   headersinterpretonly["$lastword"]="${headersstateless["$lastword"]}"
   unset -v 'headersstateless["$lastword"]'
}

where()  {                                                           # remember source location
   wherefile["$1"]="$2"                                              # remember file handle
   whereline["$1"]="$3"                                              # remember line nr
}


# create header, but don't compile, and don't generate function yet.
# compiling (that is, creating a bash function) is left to semicolon, calling compile
# won't detect redefinition if word was moved to context vocabulary
# arg1: word name
# arg2: function name
# not allowed to generate function names because some names want to be
# determined by caller
header()  {
   lastword="$1"                                                     # global variable. setting header flags needs this one
   (( linenr < 0 )) ||                                               # not entered at keyboard
      where "$lastword" "$((filehandle))" "$((linenr))"              # remember source location
   [[ -z "${headersstateless["$1"]}" ]] ||  {
      [[ ${headersstateless["$1"]} == "${header_code}_"* ]] &&
         echo "redefining $1"
   }
   headersstateless["$1"]="$2"                                       # associate word with name
   flags["$1"]="0"                                                   # default to no flags
   body=()                                                           # reinitialise code buffer
   analyser=()                                                       # reinitialise code tags for analyser
}


# ----- pretend optimiser -------------------------------- #fold00
# currently only a detokeniser. Plugged preparing further use.
# The way it works:
#    when a word gets compiled to a function, it will first be
#    cached in an array "body". semicolon then calls compile,
#    which generates a bash function from body.
#    first thing compile does is calling optimise, which visits
#    all items in body, potentially modifies or substitutes them
#    while transferring to an array named target.
#    compile then creates the bash function from target, which
#    at that point is expected to contain literal code only.
#    Compiling words which add to body array can tag entries,
#    informing optimiser/detokeniser about their nature, so it
#    can respond in an appropriate way to body array entries.

# sets analyser flag(s) arg1 for last code/atom compiled instruction.
# something tricky with setting analyser flags when an inlinable word
# was compiled to an immediate word which executes during compilation
# of the word is was used in, because in that situation applies:
#  - compilation state is on
#  - compiler copies analyser flag setting code to new word
analyserflag()  {
   (( ${#body[@]} )) || error "attempted to mark code in $lastword as $2 while body empty"
   (( analyser[-1] |= $1 ))
}



# doesn't actually do any optimizing at this point.
# Function is now limited to:
# - expanding atoms
# - generating code pushing literals
# - dealing with does>
optimise()  {                                                        # run code generator on ${analyser[@]} data
   ((${#body[@]}==${#analyser[@]}))||echo "body/analyser<>1"
   target=()
   dodoes_at=0
#   corresponding=()                                                 # index array source line to target line.

   ((codedump))&& {
      echo ": $lastword"
      for ((tmp=0; tmp<${#body[@]}; tmp++)); do
         printf "%2d %-5s %s\n" "$tmp" "${analyser[tmp]}" "${body[tmp]}"
      done
      echo "------------------------------------------------"
   }

   for ((tmp=0; tmp<${#body[@]}; tmp++)); do
#      corresponding[tmp]="${#target[@]}"                            # allow optimiser to locate target code for any source line.
                                                                     # needed for post mod or removal
      bodyline="${body[tmp]}"
      bodyflag="${analyser[tmp]}"

      if ! (( bodyflag )); then                                      # no flags: literal code, copy
         targetline="$bodyline"
# some analyser flags were set. Examine.
      elif (( analyser[tmp] & functionheader )); then                # test attempting to delegate header creation to detokeniserr
# only pretending anyway right now, real headers are
# still defined in advance of compilation.
#
# preparing to delegate header creation to detokeniser
#           pretend "create function header for $lastword at body line $tmp"

# body[tmp]: "word name"
# analyser[tmp]

#           tmp2="${body[tmp]}"
#           header "${tmp2% *}" "${tmp2#* }"
#echo "optimise created header $tmp2"
         continue
      elif (( bodyflag & inlined )); then                            # inlined code: copy
         targetline="$bodyline"
      elif (( bodyflag & atomiccode )); then                         # atomic code: expand
         targetline="${atom[${bodyline}]}"
      elif (( bodyflag & literalnumber )); then                      # number literal: generate code pushing the number
         targetline="((s[++sp]=$bodyline))"
      elif (( bodyflag & does )); then                               # does>
         targetline="${body[tmp]}"                                   # compile dodoes call
         dodoes_at="$((${#target[@]}+1))"                            # remember end of target for splitting code (but only when whole word
      fi                                                             #   was compiled - we want to rip out all the run time code, after all.
      [[ -z "$targetline" ]] || target+=("$targetline")
   done
   ((dodoes_at)) && {
# in raw code was a does> encountered: split generated code in two parts.
# first part is compiled to defining word,
# second part is seperated to an array item associated with defining word.
# dodoes, when executed, knows how to retrieve and compile that code to defined word.
      doescode[${headersstateless[$lastword]}]=$(printf "%s\n" "${target[@]:$dodoes_at}")
      target=("${target[@]:0:$dodoes_at}")
   }
}

# ----- line parser -------------------------------------- #fold00

# these need extglobs, set with "shopt -s extglob"

# read space delimited word from line without removing it.
peek_word()  {
   word="${line##+([[:space:]])}"                                    # remove all leading spaces (nee
   word="${word%%[[:space:]]*}"                                      # bl lookahead
}

# read space delimited word from line, remove it,
# remove single leading space from remainder of line.
word()  {
   peek_word
   line="${line#*"$word"}"                                           # quotes around word are needed
   line="${line#+([[:space:]])}"                                     # remove single leading space (n
}

# read string from line and remove it, also remove delimiter.
# delimiter passed as argument.
# leading spaces aren't removed from remainder of line.
parse()  {
   word="${line%%"${1}"*}"
   [[ -z "$1" ]] && word="$line"
   line="${line#"${word}"}"                                          # " unconfuse efte syntax highlighting
   line="${line#"$1"}"
}

# ----- compiler ----------------------------------------- #fold00

# atoms may be:
#  - micro instructions
#  - single instructions
#  - primitives
# those can describe their effects more easily to the optimiser,
# enabling it to combine and remove them to target code.
# in addition are meta directives allowed:
#  - compile time instructions for word creation, such as header building

atom()  {
   [[ -z "${atom[$1]}" ]] && error "no atomic $1"
   code "$1" "$atomiccode"; }                                        # insert into code buffer, mark as atom


codebody()  {                                                        # inline compiler
   while read -r tmp; do
      [[ "${tmp:0:1}" == "{" ]] &&
      while read -r tmp; do
         [[ "${tmp:0:1}" == "}" ]] && break
         code "$tmp" "$inlined"
      done
   done < <(type "$1")
}

# rewrite run time semantics of most recently defined word
# arg1: new run time code.
use()  {
   name="${headersstateless["$lastword"]}"                           # rewrites function "$name",
   eval "$name() { $(printf '%s\n' "$@"); }"                         # using instructions received as arguments
}

compile()  {                                                         # build new function from code in body array
   restricted || {
      optimise                                                       # here's the proper place for static code evaluation.
      use "${target[@]}"
   }
}

# execute or compile args. Similar to invoke,
# maybe one of these can be eliminated.
stateless()   {
   if ((compiling)); then
      code "$@"
   else
      eval "$*"
   fi
}


# ----- defining words ----------------------------------- #fold00


# make stack effect of word known, aiding the optimiser
inout()  {
   stackin["$lastword"]="$1"
   stackout["$lastword"]="$2"
}


# arg1: code token, arg2: code token type (opt)
code()  {                                                            # literal code compiler
   body+=("$1")
   analyser+=("${2:-0}")                                             # default to no optimiser intervention
}

push()  {
   code "$1"   "$literalnumber"                                      # leave it to detokeniser to generate code
}


# quite some factoring possible in this section
# arg1: word name
create()  {
   [[ -z "$2" ]] || echo "still passing arg2=$2 to create"
   [[ -z "$1" ]] && emptyname
   names[nextname]="$1"
   name="${header_code}_$((nextname++))"
   header "$1" "$name"

#   code "$1" "$functionheader"                                      # preparing to delegate header creation to detokeniser
#   code "$1 $name" "$functionheader"                                # preparing to delegate header creation to detokeniser
#   lastword="$1"                                                    # global variable. setting header flags needs this one
#   body=()                                                          # reinitialise code buffer
#   analyser=()                                                      # reinitialise code tags for analyser

   [[ -z "$linenr" ]] &&
      where "$lastword" "1" "$((BASH_LINENO[0]))"                    # remember source location
}



# primitive wordname  functionname
primitive()  {
   create "$1"
   [[ -z "$linenr" ]] &&
      where "$lastword" "1" "$((BASH_LINENO[0]))"                    # remember source location
   inline
   use "$2"
}


colon()  {
   [[ -z "$1" ]] && emptyname
   if [[ -z "${headersunresolved[$1]}" ]]; then                    # check whether word is an unresolved forward reference
      names[nextname]="$1"
      name="${header_code}_$((nextname++))"                          # prefix function names will avoid effect described on next line
   else                                                              # created word will resolve forward reference(s)
      name="${headersunresolved[$1]}"                                # as word name use name of forward reference
      foo="$1"
      unset -v 'headersunresolved[$foo]'                               # remove forward reference
   fi
   header "$1" "$name"

# -- hack alert:
# source location isn't recorded properly when definition is
# created by  "evaluate ': foo ... ;' as done several time in here
# In order to fix their source locations in the "where" array, it
# is examined here whether call to colon happened two levels higher
# from evaluate. This hack is needed for another hack which is here
# too and similar enough that they both can be pulled together:
# source locations from primitives in general need that other hack
# which takes source location from BASH_LINENO[0] (and from BASH_LINENO[2]
# for the hack of the hack).
# So when suddenly source lookup of primitives through "review" fails, this
# would be the place to look at.
   [[ -z "$linenr" ]] && {
      tmp="${BASH_LINENO[0]}"
#      echo "-- ${FUNCNAME[@]:0:4}"
      [[ "${FUNCNAME[2]}" == "evaluate" ]] &&
         tmp="${BASH_LINENO[2]}"
      where "$lastword" "1"  "$tmp"                                  # remember source location
   }

#   code "$1" "$functionheader"                                      # preparing to delegate header creation to detokeniser
#   code "$1 $name" "$functionheader"                                # preparing to delegate header creation to detokeniser
#   lastword="$1"                                                    # global variable. setting header flags needs this one
#   body=()                                                          # reinitialise code buffer
#   analyser=()                                                      # reinitialise code tags for analyser

   compiling=1
}


semicolon()  {
   compile                                                           # compilation is gathered in an array body. Only
   compiling=0                                                       # when semicolon completes compilation, is
   derestrict
}                                                                    # a function created from contents of array.


constant()  {
   colon "$1"
   push "$2"
   semicolon
   inline
   inout 0 1
   [[ -z "$linenr" ]] &&
      where "$lastword" "1" "$((BASH_LINENO[0]))"                    # remember source location
}


# initialized with 0 or optional arg2
variable()  {
   (( "$1"="$dp" ))
   m[dp]="${2:-0}"
   constant "$1" "$((dp++))"
   [[ -z "$linenr" ]] &&
      where "$lastword" "1"  "$((BASH_LINENO[0]))"                   # remember source location
}


variable 'shell'              "0"
variable 'forwardrefs'        "0"
variable 'instantresolve'     "0"
variable 'callstack'          "0"
variable 'base'               "10"
variable 'stringvariables'    "0"

constant 'maxuint'            "$maxuint"
constant 'maxint'             "$maxint"
constant 'msb'                "$msb"
constant 'cell'               "1"
constant 'true'               "$maxuint"
constant 'false'              "0"
constant '0'                  "0"
constant 'esc'                "27"
constant 'bl'                 "32"
constant 'bits'               "$bits"



# ----- errors, traps, entry points----------------------- #fold00

warm()  {
   line=""                                                           # signal to evaluate to stop evaluation of current line
   linenr="-1"                                                       # signal to from to stop sending more lines to evaluate
   compiling=0                                                       # interpret
   error=0
   derestrict                                                        # turn off code suppressing
   r=() rp=0
   ((sp<0)) &&s=() sp=0                                              # always clear stack underflow
   ((clean))&&s=() sp=0 ss=()                                        # empty stacks
   m[base]="10"                                                      # set decimal if base exists
}

coldvector=""                                                        # colon word "boot" assigns coldvector. started when compilation completed.
cold()  {                                                            # also by running cold. error restarts interpreter at cold
   [[ -z "$coldvector" ]] && exit 1
   warm; $coldvector
}

callstack()  {
   printf "%s: " "Call stack"
   printf "%s " "${FUNCNAME[@]:5:${m[callstack]}}"                   # remove callstack and error from output
   printf "\n"
}

error()  {                                                           # Zeile mit fehlerwort ANSI markieren
#         >--<              >--<   >--------------------------<                                >-----<     begin and end of line
#                  >--<                                                    >----<                          error word
#            >-----<  >----<                                      >---<              >------<              ANSI sequences
   printf "%s\e[%dm%s\e[%sm %s\n" "${tib%"${word}"*"${line}"}" "${redbg}" "${word}" "${normal}" "$line"
   printf 'ERROR: %s\n' "$@"
   row=$((${#tib}-${#line}-${#word}))
# passing file name in lasterror - could pass file handle instead
   lasterror=("$file" "$linenr" "$row")
   (( linenr < 0 )) || printf "at %s of %s\n" "$linenr,$row" "$file"
   ((m[callstack]))&&callstack
   cold
}


# error handling will probably change completely:
# coproc will print error line, then exit with error number as exit value.
# from that value, the appropriate error message is selected and printed.
# wait may need to pick that value up.
# bye needs special attention.

declare -a errortext
nexterror=0

errornr()   {
   error="$1"
   shift
   error "${errortext[error]} $*"
}

# a somewhat wild construct, sort of attempting
# to emulate Forth's create ... does> here. I'm
# surprised that shellcheck finds this acceptable
newerror() {
   (( "$1" = nexterror ))                                            # assign new error number to error name
   eval "$1()  { errornr \"$1\" "\"\$*"\"; }"                        # synthesise error function with error name
   shift
   errortext[nexterror++]="$*"                                       # associate error message with error number
}

newerror "noerror"         "no error"
newerror "emptyname"       "no or empty name"
newerror "stackunderflow"  "stack underflow"
newerror "notfound"        "not found:"
newerror "nosource"        "no source for"
newerror "stillcompiling"  "still compiling after"
newerror "unbalancedstack" "unbalanced stack in file"
newerror "unstructured"    "unstructured: missing"
newerror "abort"           "abort"
newerror "shellerror"      "shell returned"
newerror "filenotfound"    "file not found:"


ctrl-c()  {
   printf "%s\n" "break"
   ((break == 1))  && exit 1
   ((m[callstack]))&& callstack
   ((break == 2))  && cold
}
trap ctrl-c SIGINT

# may come in handy with tput
# resized()  { echo "resized"; }
# trap foo SIGWINCH

# ----- patterns ----------------------------------------- #fold00

declare -A bases=(['%']=2 ['#']=10 ['$']=16)
pattern()  {                                                         # pattern interpreted as
   restricted || {
# some patterns can simply be ignored when code creation is muted
      ((radix=m[base]))
      tmp="0123456789abcdefghijklmnopqrstuvwxyz"                     # cut legal chars for base
      [[ $word =~ ^[${tmp:0:$radix}]+$ ]] && {                       # 1234      unsigned number
         stateless "((s[++sp]=$((${radix}#${word}&maxuint))))"       # convert signless numbers without special treatment
         return 0; }
      [[ $word =~ ^-[${tmp:0:$radix}]+$ ]] && {                      # -1234     negative number
         stateless "((s[++sp]=$((-${radix}#${word:1}&maxuint))))"
         return 0; }
      [[ ${word:0:1} == [%\$\#] ]] && {
         radix="${bases[${word:0:1}]}"                               # yes: read radix associated with char
         [[ ${word:1} =~ ^[${tmp:0:$radix}]+$ ]] && {                # remainder of number all legal chars?
            stateless "((s[++sp]=$((${radix}#${word:1}&maxuint))))"  # yes: convert from base and deal with it
            return 0; }
      }
      [[ ${word} == \'? || ${word} == \'?\' ]] && {                  # 'X bzw 'X' return ASCII - easier on editor syntax highlighting
         read -r tmp < <(printf "%d" "'${word:1:1}'")
         stateless "s[++sp]=\"$tmp\""; return 0; }
      [[ ${word} == ^[a-zA-Z\[] ]] && {                              # ^X        return control char
         read -r tmp < <(printf "%d" "'${word:1:1}")
         stateless "s[++sp]=\"$((tmp&31))\""; return 0; }
   }
# other patterns, especially those doing parsing or modifying line, must partially execute

# while only single word, this may not be skipped during
# code muting, or multi word double quote register a
# false match and parses to line end.
   [[ "${word:0:1}${word:0-1}" == '""' ]] && {                       # quoted string, single word
      restricted && return 0
      (( ${#word} > 1 )) &&  {                                       # prevent false matches with leading spaces where a single " is both 0:1 and 0-1
         ((compiling)) && {                                          # arg for compile differs with quoting, to make strings like $1 $2  literal
            code  "ss+=('${word:1:${#word}-2}')"                     # But variable expansion take place in interpreted branch.
            return 0                                                 # Both requirements are hard to formulate in one common version.
         }
         ss+=("${word:1:${#word}-2}")
         return 0
      }
   }
   [[ "${word:0:2}" == '#!' ]] && {                                  # #!        ignore hashbang
      line=""; return 0; }                                           # only relevant when loading hashbang file with from. OS doesn't pass hashbang line

   [[ "${word:0:1}" == \" ]] && {                                    # quoted string, multiple words (single words already dealt with)
      tmp="${word:1}"                                                # strip leading " from first word
      parse '"'                                                      # parse rest of line for closing quotes
      restricted || {
         ((compiling)) && {
            code "ss+=('$tmp $word')"                                # compile: compile code to add string to string stack unless compilation was muted
            return 0; }
         ss+=("$tmp $word")                                          # interpret push string to string stack
         return 0;
      }
   }
   [[ "${word:0:1}" == '>' ]] && {                                   # >foo      execute a shell command
      tmp="${word:1}"                                                #           up to ; as args
      if [[ "$line" == *';'* ]]; then                                # if line contains ;
         parse ';'                                                   # then parse input until ;
      else
         word="$line"                                                # otherwise is whole line passed as arguments
         line=""                                                     # and removed from further evaluation
      fi
      restricted || stateless "$tmp $word"                           # execute or compile the parsed shell command
      return 0
   }
   ((m[shell])) || return 1                                          # done unless shell flag was set
   restricted || {
      stateless "${word} ${line}" ||                                 # in which case execution as shell command is attempted
      shellerror "$?"                                                # non-zero exit values of shell commands will be passed on to yoda error handler
   }
   line=""                                                           # assignment sets return value to 0
}


# ----- resolve forward refs ----------------------------- #fold00

# total headers count is used to help determining if resolving
# forward refs create new forward refs, in which case resolving
# will be repeated.
totalheaders()  {
   totalheaders=$((
      ${#headersstateless[@]}
   +  ${#headerscompileonly[@]}
   +  ${#headersinterpretonly[@]}
   +  ${#headersunresolved[@]}
   ))
}
dependencies="$mydir/dependencies"

# satisfy one single reference, passed as arg1
satisfy1()  {
   [[ -z ${headersstateless[$1]} ]] || return                        # word exists - already satisfied
   local word="$1"
   local forwarding="$((m[forwardrefs]))"
   ((m[forwardrefs]=-1))                                             # turn on forward references
   read -r _ tmp < <(
       awk -v word="$word" '$1 == word' "$dependencies"              # search dependency database
   )
   [[ -n "$tmp" && -f "$tmp" ]] && {
      from "$tmp"                                                    # source found: load
   }
   ((m[forwardrefs]=forwarding))                                     # restore forward refs status
}

resolving=0
# looping resolve until header count stabilised.
# doing so because resolving forward references may create
# new forward references, which also need resolving.
resolve()  {
   (( ${#headersunresolved[@]} )) || return                          # only run if unresolved words exist
   ((resolving)) && return                                           # nesting into resolve doesn't get any more work done -
   local file                                                        #   we'll resolve anything open, or we don't, no matter
   local resolving=1                                                 #   how often resolve calls itself. This would only slow down
   previousheaders="-1"
   totalheaders                                                      # total headers count before inclusion
   until (( totalheaders == previousheaders )); do                   # loop until header count stabilises
      previousheaders="$totalheaders"
      for word in "${!headersunresolved[@]}"; do                     # try to resolve all in unresolved vocabulary
         satisfy1 "$word"                                            # satisfying a word can create new forward references
      done
      ((${#headersunresolved[@]})) || break                          # no forwardrefs left: done
      totalheaders                                                   # total headers count now, after inclusion
   done
   sleep 1
}



# ----- line interpreter, evaluate------------------------ #fold00

# text compiler and interpreter, the so-called outer interpreter

# do a single word, which has already been found.
# must still figure out run- or compile time action,
# arg1: word
# arg2: name found
invoke() {
   ((compiling)) || { $2;  return; }                                 # not compiling: execute function
   ((${flags["$1"]}&inline)) && { codebody "$2"; return;  }          # inline:     compile function body
   code "$2"                                                         # not inline: compile call to function
}

# create a forward ref by the name of arg1
# now unused arg2 passes referer
forwardref()  {
   [[ -z ${headersunresolved["$word"]} ]] && {                       # don't re-forwardref and already forward ref'ed word
      names[nextname]="$1"
      headersunresolved["$1"]="${header_code}_$((nextname++))"       # create unresolved header with new name, associate with word
      log "new forw: $1"
   }
}

# interpret/compile the line passed as argument
# in here most compiling and interpreting work is done.
# time to split this thing up.
evaluate()  {
   local line="$*"                                                   # line may get modified, and that must be. some words depend on being able to change it,
   local tib="$line"                                                 # tib remains unaffected unless explicitely modified (query et al), For nesting evaluate
   trace "line=[$line]"
   until [[ -z "$line" ]]; do                                        # still more to process on line (parsing removes strings from line)
      ((error | (sp<0)))&&break
      word                                                           # parse white space delimited word
      [[ -z "$word" ]] && continue                                   # empty: tabs, line end, nothing of substance
      [[ -z "${headersstateless["$word"]}" ]] || {                   # word found in stateless dictionary
         invoke "$word" "${headersstateless["$word"]}"               # compile or execute
         continue
      }
      if ((compiling)); then                                         # word wasn't found. search state specific vocabularies
         [[ -z "${headerscompileonly["$word"]}" ]] || {              # found in in compileonly while compiling
            ${headerscompileonly["$word"]}                           # word in there are inherently "immediate", therefore they're executed here
            continue                                                 #     because that also deals with inline compilation.
         }
         [[ -z "${headersunresolved["$word"]}" ]] || {               # found in unresolved while compiling
            code "${headersunresolved[$word]}"                       # compile it
            continue
         }
      else                                                           # interpreting
         [[ -z "${headersinterpretonly["$word"]}" ]] || {            # word found in interpretonly
            ${headersinterpretonly["$word"]}
            continue
         }
      fi
      pattern "$word" && continue                                    # not found yet: try patterns (numbers, strings, chars, hashbang, shell commands)
      restricted && continue                                         # muted code generation: don't go through forward refs, but silently
                                                                     #     assume "word found", as it will be ignored anyway.
                                                                     # can't do that with patterns above - those may consume multi word strings.

      (( m[forwardrefs] )) && {                                      #     and forward references enabled ...
         restricted || {                                             #     don't create forward refs during suppressed compilation phases
            ((compiling)) && {                                       # still not successfully dealt with word. last resolve: in case of compiling ...
               forwardref "$word"  "$lastword"                       #     create a forward reference.
               code "${headersunresolved["$word"]}"                  #     compile dangling call to unresolved name. (tag as forward ref call for optimiser?)
               continue                                              # hope that it will eventually get resolved
            }
            (( m[instantresolve] )) && {                             # interpret time forward references enables?
               logplus "instant resolve needs $word"                 # log, then indent
               need "$word"; resolve                                 # yes: declare need, immediately try to resolve
               [[ -z "${headersunresolved[$word]}" ]] && {           # if resolved:
                  logminus "executing $word"                         #     unindent, log
                  ${headers["$word"]}                                #     execute
                  continue
               }
               logminus "can't resolve $word"                        # else unindent, log,
               unset -v 'headersunresolved["$word"]'                 # restore former state, proceed with unknown word handling
            }
         }
      }
      notfound "$word"                                               # nothing helped. get grouchy.
      line=""                                                        # stop evaluation: nothing left
   done
   ((sp<0))&&stackunderflow
}





# ----- load source files -------------------------------- #fold00

# return filehandle pointing to matching file in array files,
# or to end of array where new file will be added if no
# matching file was found. Also return a return values (1)
# if not loaded, return 0 when loaded.
# (seems twisted but allows condition  "if loaded; then ..."

# return filehandle as result, and return value
# indicating first time load or reload
loaded()  {
   local file="$1"
   for ((filehandle=1; filehandle<${#files[@]}; filehandle++)); do   # while multiple inclusion is allowed, those files won't be recorded multiple times
      [[ "${files[filehandle]}" == "$file" ]] && break               # so when already recorded, break out
   done
   return $(( filehandle >= ${#files[@]}))
}

# nestable source include
# this from differs from the colon word, as it doesn't
# try the different ${libdirs[@}} directories.
# file, possible with path, must exist, or no go.
# Callers did a check prior to calling.
from()  {
   [[ -z "$1" ]] && return 2                                         # no file
   local line lines linenr file filehandle word                      # must protect for nested includes.
   local stackeffect="$sp"                                           # included files must have net stack effect of 0
   file=""
   if [[ "$1" == */* ]]; then                                        # file contains slash(es): don't search
      file="$1"
   else
      for dir in "${libdirs[@]}"; do
         [[ -f "$dir/$1" ]] && { file="$dir/$1"; break; }            # search through lib dirs, break when/if found
      done
   fi
   [[ -f "$file" ]] || return 1                                      # file not found
   file="$(realpath "$file")"                                        # canonical or original name of file
   loaded "$file" || files[filehandle]="$file"                       # first time inclusion: add to files array
   readarray -t lines < "$file"                                      # read whole source into lines array
   for ((linenr=0; linenr<${#lines[@]};)); do                        # looping through line number, not through lines so that
      line="${lines[linenr++]}"                                      #   source can change line numbers for jumping
      evaluate "$line"                                               # process next line
      ((error | (linenr < 0)))&&break                                # source can flag "stop loading" with negative linenr
   done                                                              #   (warm and done do so)
   ((compiling)) && stillcompiling "$1"                              # can't have that, files leaving a dangling compiler
   ((stackeffect == sp)) || unbalancedstack "$1"                     # demanding stack clean files with net effect zero.
   ((loaded[filehandle]++))                                          # increment load counter, mark as loaded
   resolve
   return 0
}



# ----- primitives --------------------------------------- #fold00
# ----- populating detokeniser --------------------------- #fold01
# for testing, a handful of inlined single operation primitives
# and atomic operations are added. no optimising take place now.
# atoms are only substituted against corresponding code.
# atoms are tagged as such in the source, some correspond to
# names of primitives. This is meant for having the optimiser
# hooked into code generation, for doing some more substantial
# work later on. chosing these operations allows tracking of
# recent use of stack items and registers, for static elimination
# of redundant operations.

atom["dup"]='((s[++sp]=s[sp]))'
atom["over"]='((s[++sp]=s[sp-1]))'
atom["pluck"]='((s[++sp]=s[sp-2]))'
atom["drop"]='((sp--))'
atom["@"]='((s[sp]=m[s[sp]]))'
atom["1+"]='((s[sp]=(s[sp]+1)&maxuint))'
atom["1-"]='((s[sp]=(s[sp]-1)&maxuint))'
atom["2*"]='((s[sp]=(s[sp]<<1)&maxuint))'

atom["negate"]='((s[sp]=(-s[sp]&maxuint)))'
atom["invert"]='((s[sp]^=maxuint))'

atom["s1"]='((s1=s[sp]))'
atom["s2"]='((s2=s[sp-1]))'
atom["s3"]='((s3=s[sp-2]))'
atom["s4"]='((s4=s[sp-3]))'

atom["s1=tmp"]='((s[sp]=tmp))'
atom["s2=tmp"]='((s[sp-1]=tmp))'
atom["s3=tmp"]='((s[sp-2]=tmp))'
atom["s4=tmp"]='((s[sp-3]=tmp))'
atom["tmp=s1"]='((tmp=s[sp-0]))'
atom["tmp=s2"]='((tmp=s[sp-1]))'
atom["tmp=s3"]='((tmp=s[sp-2]))'
atom["tmp=s4"]='((tmp=s[sp-3]))'

atom["s1=s2"]='((s[sp]=s[sp-1]))'
atom["s1=s3"]='((s[sp]=s[sp-2]))'
atom["s2=s1"]='((s[sp-1]=s[sp]))'
atom["s2=s3"]='((s[sp-1]=s[sp-2]))'
atom["s3=s1"]='((s[sp-2]=s[sp]))'
atom["s3=s2"]='((s[sp-2]=s[sp-1]))'
atom["s4=s1"]='((s[sp-3]=s[sp]))'
atom["s4=s2"]='((s[sp-3]=s[sp-1]))'
atom["s4=s3"]='((s[sp-3]=s[sp-2]))'

atom["r@"]='((s[++sp]=r[rp]))'
atom['>r']='((r[++rp]=s[sp--]))'
atom['r>']='((s[++sp]=r[rp--]))'
atom['rdrop']='((r--))'

atom["allot"]='((dp+=s[sp--]))'
atom["here"]='((s[++sp]=dp))'

# ----- colon/semicolon ---------------------------------- #fold01

colon ';'      # semicolon
   code "(( s[sp--] == $magic )) || { unstructured ':'; return; }"   # check the magic left by :
   code '(( ${s[sp--]} == ${#body[@]} )) && code ":"'                # insert a noop into empty function bodies
   code 'semicolon'                                                  # compile $lastword from $body[@], resume interpreting
semicolon
immediate

colon ':'
   code 'word'                                                       # parse space delimited word from input stream
   code 'colon "$word"'                                              # generate synthetic name, associate with word
   code "((s[++sp]=\${#body[@]}))"                                   # allow check of empty function
   code "((s[++sp]=$magic))"                                         # allow check of structure
   code 'compiling=1'
semicolon
interactive

colon 'u:'
   code 'word'                                                       # parse space delimited word from input stream
   code '[[ -z "${headersunresolved["$word"]}" ]] &&'
   code ' restrict || colon "$word"'
   code "((s[++sp]=\${#body[@]}))"                                   # allow check of empty function
   code "((s[++sp]=$magic))"                                         # allow check of structure
   code 'compiling=1'
semicolon
interactive

primitive 'interactive'  'interactive'                               # move header to interpreter context vocabulary
primitive 'immediate'    'immediate'                                 # move header to compiler context vocabulary

# ----- diagnostics -------------------------

words()	{
   local headers
   for tmp in "${headerslistlist[@]}" "headersunresolved"; do
      declare -n headers="$tmp"
	   (( ${#headers[@]} )) && {
         printf '%s\n' "--- ${tmp#"headers"} ---"
   	   printf  "%s  " "${!headers[@]}"
         printf '\n\n'
      }
   done
}

crossref()  {
   local headers
   for tmp in "${headerslistlist[@]}" "headersunresolved"; do
      declare -n headers="$tmp"
      (( ${#headers[@]} )) && {
         printf '%s:\n' "${tmp#"headers"}"
         for tmp2 in "${!headers[@]}"; do
            printf "    %-16s %s\n" "${headers["$tmp2"]}" "$tmp2"
         done | sort -t'_' -k2,2 -n
      }
   done
}

# crossref lists name to word associations.
primitive 'crossref' 'crossref'

# TODO: factor context voc search.  see also  tick, undoc, forward refs
see()  {
   local headers
   word
   for tmp in "${headerslistlist[@]}"; do
      declare -n headers="$tmp"
      [[ -z "${headers["$word"]}" ]] || {
         printf "found in %s:\n" "${tmp#"headers"}"
         tmp="${headers["$word"]}"
         [[ -z "$tmp" ]] && notfound
         if [[ "$(type -t "$tmp")" == "function" ]]; then
            type "$tmp"
         else
       	   printf "%s\n" "$tmp"
         fi
      }
   done
}

# see word  "decompiles" and shows word.
primitive 'see' 'see'
primitive '.s' '((sp))&&printf "%s " "${s[@]:1:$sp}"'


# ----- does> -------------------------------------------- #fold01

# compiled to the end of a defining word,
# is therefore called by create part, and
# will consequently know who its caller is
# (function name).  Will also know, by virtue
# of $lastword, what function to add code to.
# (or rather, instruct detokeniser to add code
# to). Appends all defining word associated code
# portion of does> to the original address push
# compiled by create.
dodoes()  {                                                          # append does> part to original address pushing create semantics
   ${headersstateless[$lastword]}
   use  "s[++sp]=\"${s[sp--]}\"
         ${doescode[${FUNCNAME[1]}]}"
}

# detokeniser detects and reacts to this "$does" tagged code:
# code after does> is removed from defining word and written to
# an array item associated with it.
# dodoes then uses that code to rewrite run time semantics of
# defined word.
# Though somewhat Rube-Goldbergish, it's simpler than the other
# approaches I was thinking of.
primitive 'does>'  'code "dodoes" "$does"';   immediate

# ----- defining words ----------------------------------- #fold01

# essentially a constant with yet to be specified source for its
# value and overwritable run time semantics (push value by default)
define()  {
   code 'word'
   code "constant \"\$word\" \"$1\""                                 # not using single quotes because want $1 to expand
}

colon 'create'
    define '$dp'
semicolon

colon 'constant'
   define '${s[sp--]}'
semicolon

colon 'variable'
   define '$((dp))'
   code '((m[dp++]=0))'                                              # allocate and initialise
semicolon

colon "array"
   define '$header_code'
   code 'use "((s[sp]+=$dp))"'                                       # set run time semantics
   code "((dp+=s[sp--]))"                                            # allocate
semicolon

# factor code common with header
# ' foo alias bar
colon 'alias'
   define '0'
   code 'headersstateless["$word"]="${header_code}_${s[sp--]}"'
   code 'whereline["$lastword"]="${linenr:-BASH_LINENO[2]}"'         # correct source line number for aliases in this file
semicolon


# ----- compiler and word search related ----------------- #fold01

# ( -- 0 | a )
have() {
   local headers                                                     # meant to spare me from saving and restoring vectored headers variable
   word
   for tmp in "${headerslistlist[@]}"; do                            # loop through all vocs we want to search
      declare -n headers="$tmp"                                      # vector headers to next vocabulary
      [[ -z "${headers["$word"]}" ]] || {                            # word in there?
         tmp="${headers["$word"]}"                                   #     yes: remember name
         [[ $tmp == ${header_code}* ]] || break                      # can not tick data
         ((s[++sp]=${headers["$word"]#"${header_code}_"}))           # convert name to "address" and push
         return 0                                                    # found word, stacked execution token
      }
   done                                                              # go on search next voc
   ((s[++sp]=0))
}


# NOTE: tick and execute need names to look like foobar_4711
colon "'"
   code 'have'
   code '((s[sp])) || notfound "$word"'                              # none left -> all searched, but not found.
semicolon

colon "[']"
   code 'have'
   code '((s[sp])) || notfound "$word"'                              # none left -> all searched, but not found.
   code 'push "${s[sp--]}"'
semicolon
immediate

primitive '[' 'restricted||compiling=0'; immediate                   # don't allow to suspend compilation when compilation is muted
primitive ']' 'compiling=1'

colon 'literal'
   code 'restricted || {'
   code 'push "${s[sp--]}"'
   code '}'
semicolon
immediate

colon 'trash'
   code 'word'
   code 'unset "headersstateless[$word]"'
semicolon

primitive 'execute' "${header_code}_\${s[sp--]}"                     # ( xt -- )
primitive 'name'    'ss+=("${names[s[sp--]]}")'                      # ( xt -- ) ( string: -- $1 )
primitive '.name'   'printf "%s" "${names[s[sp--]]}"'                # ( xt -- )

# can be used after a colon definition
primitive 'inline'  'inline'                                         # ( -- )    set header flag for inline compilation
primitive 'resolve' 'resolve'                                        # ( -- )    attempt to resolve forward references
primitive '.unresolved'  '((${#headersunresolved[@]}))&&printf "%s " "${!headersunresolved[@]}"'   # print unresolved
primitive '#unresolved' '((s[++sp]=${#headersunresolved[@]}))'       # ( -- u )
primitive 'recurse' 'code "${headersstateless["$lastword"]}"'; immediate   # ( -- )


# ----- environment--------------------------------------- #fold01
# read number from environment variable with name on string stack
# ( -- x )  ( string:  $1 -- )
colon 'env'
   push '${!ss[-1]}'
   code 'unset "ss[-1]"'
semicolon
inline
inout 0 1

# store $1 in bash environment variable with name $2
# ( x -- ) ( string:  $1 -- )
colon '>env'
   code 'eval "${ss[-1]}=$((s[sp--]))"'
   code 'unset "ss[-1]"'
semicolon
inout 1 0


# read string from environment variable with name on string stack
# ( string:  $1 -- $2 )
primitive 'env$' 'ss[-1]="${!ss[-1]}"'; inout 0 0

# store string $1 in bash environment variable with name $2
# ( string:  $1 $2 -- )
colon '>env$'
   code 'eval "${ss[-1]}=${ss[-2]}"'
   code 'unset "ss[-1]"'
   code 'unset "ss[-1]"'
semicolon
inout 0 0



# ----- misc --------------------------------------------- #fold01

primitive 'noop' ':'
primitive "\\"   'line=""';   immediate                              # single quoted single backslash because
primitive "\\"   'line=""';   interactive                            # double quoted escaped backslash rather than
                                                                     # efte syntax highlighting gets confused
primitive '('    "parse ')'"; immediate
primitive '('    "parse ')'"; interactive


# ----- parameter stack ---------------------------------- #fold01


colon 'dup'
   atom 'dup'
semicolon
inline
inout 1 2

colon 'drop'
   atom 'drop'
semicolon
inline
inout 1 0

colon 'over'
   atom 'over'
semicolon
inline
inout 2 3

colon 'pluck'
   atom 'pluck'
semicolon
inline
inout 3 4

colon '2dup'
   atom 'over'
   atom 'over'
semicolon
inline
inout 2 4

primitive '2drop' '((sp-=2))'; inout 2 0

colon '2over'
   push 's[sp-3]'
   push 's[sp-3]'
semicolon
inline
inout 4 6

colon 'swap'
   atom 'tmp=s2'
   atom 's2=s1'
   atom 's1=tmp'
semicolon
inline
inout 2 2

colon '2swap'
   atom 'tmp=s4'
   atom 's4=s2'
   atom 's2=tmp'
   atom 'tmp=s3'
   atom 's3=s1'
   atom 's1=tmp'
semicolon
inout 4 4

colon 'nip'
   atom 's2=s1'
   atom 'drop'
semicolon
inline
inout 2 1

colon 'tuck'
   atom 'dup'
   atom 's2=s3'
   atom 's3=s1'
semicolon
inline
inout 2 3

colon 'rot'
   atom 'tmp=s1'
   atom 's1=s3'
   atom 's3=s2'
   atom 's2=tmp'
semicolon
inline
inout 3 3

colon '-rot'
   atom 'tmp=s1'
   atom 's1=s2'
   atom 's2=s3'
   atom 's3=tmp'
semicolon
inline
inout 3 3

colon '?dup'
   code '((s[sp])) &&'
   atom 'dup'
semicolon
inline

primitive 'depth'  '((s[++sp]=$sp))'
primitive 'pick'   '((s[++sp]=s[sp-s[sp]]))'

# ----- return stack ------------------------------------- #fold01

colon 'r@'
   atom 'r@'
semicolon
inline
inout 0 1

colon 'rdrop'
   atom 'rdrop'
semicolon
inline
inout 0 0

colon '>r'
   atom '>r'
semicolon
inline
inout 1 0

colon 'r>'
   atom 'r>'
semicolon
inline
inout 0 1

# ( x1 x2 -- )  ( return: -- x1 x2 )
colon '2>r'
   code '((r[++rp]=s[sp-1]))'
   code '((r[++rp]=s[sp--]))'
   atom 'drop'
semicolon
inline
inout 1 0

# ( -- x1 x2 )  ( return: x1 x2 -- )
colon '2r>'
   push 'r[rp-1]'
   push 'r[rp--]'
   code '((rp--))'
semicolon
inline
inout 0 1


primitive 'rdepth'  '((s[++sp]=rp))'; inout 0 1

# ----- string stack ------------------------------------- #fold01

primitive 'depth$'   's+=("${#ss[@]}")'
primitive 'empty$'   'ss=()'
primitive 'dup$'     'ss+=("${ss[-1]}")'
primitive '?dup$'    '[[ -z ${ss[-1]} ]] || ss+=("${ss[-1]}")'
primitive 'drop$'    'unset "ss[-1]"'
primitive 'over$'    'ss+=("${ss[-2]}")'
primitive 'pluck$'   'ss+=("${ss[-3]}")'
primitive 'pick$'    'ss+=("${ss[-s[sp--]-1]}")'

colon '2dup$'
   code 'ss+=("${ss[-2]}")'
   code 'ss+=("${ss[-2]}")'
semicolon
inline

colon '2drop$'
   code 'unset "ss[-1]"'
   code 'unset "ss[-1]"'
semicolon
inline

colon '2swap$'
   code 'tmp="${ss[-4]}"; ss[-4]="${ss[-2]}"; ss[-2]="$tmp"'
   code 'tmp="${ss[-3]}"; ss[-3]="${ss[-1]}"; ss[-1]="$tmp"'
semicolon
inline

colon 'swap$'
   code 'tmp="${ss[-2]}"; ss[-2]="${ss[-1]}"; ss[-1]="$tmp"'
semicolon
inline

colon 'nip$'
   code 'ss[-2]="${ss[-1]}"'
   code 'unset "ss[-1]"'
semicolon
inline

colon 'tuck$'
   code 'ss+=("${ss[-1]}"); ss[-2]="${ss[-3]}"; ss[-3]="${ss[-1]}"'
semicolon
inline

colon 'rot$'
   code 'tmp="${ss[-1]}"; ss[-1]="${ss[-3]}"; ss[-3]="${ss[-2]}"; ss[-2]="$tmp"'
semicolon
inline

colon '-rot$'
   code 'tmp="${ss[-1]}"; ss[-1]="${ss[-2]}"; ss[-2]="${ss[-3]}"; ss[-3]="$tmp"'
semicolon
inline

# results may not be what is expected: this removes *all* white space,
# not just leading and trailing white space. Actually a mistake, which
# I'll now try to sell as feature.
# or not. too specific, I better add some more general replace$ function
# ( string: $1 -- $2 )
primitive 'trim$'  'ss[-1]="${ss[-1]//[[:space:]]/}"'

#primitive '-leading$'  'ss[-1]="${ss[-1]//^[[:space:]]*/}"'
#primitive '-trailing$'  'ss[-1]="${ss[-1]//[[:space:]]*$/}"'
#evaluate ': trim$  -leading$ -trailing$ ;'

# ( -- u )  string: ( $1 $2 -- $3 )     remove  $2* from $1, return removed chars count
colon 'cut$'
   push '${#ss[-2]}'
   code 'ss[-2]="${ss[-2]%${ss[-1]}*}"'
   code '((s[sp]-=${#ss[-2]}))'
   code 'unset "ss[-1]"'
semicolon

# count substring occurances
# : #substrings  swap$ 0 begin over$ cut$ while 1+ repeat 2drop$ ;
# -leading$:  ${myVar##*( )}
# -trailing$: ${myVar%%*( )}

colon '.ss'
   code '((${#ss[@]})) &&'
   code 'printf "\"%s\" " "${ss[@]}"'
semicolon

colon 'type$'
   code 'printf "%s" "${ss[-1]}"'
   code 'unset "ss[-1]"'
semicolon
inline

colon 'count$'
   push '${#ss[-1]}'
   code 'unset "ss[-1]"'
semicolon
inline

# split string into single words at white space, return count of resulting single word strings.
# ( -- u )   ss: ( $ -- $1 $2 $3 .. $u )
colon 'chop$'
   code 'tmp="${ss[-1]}"'
   code 'unset "ss[-1]"'
   code 's1=("${#ss[@]}")'
   code 'ss+=($tmp)'
   push '${#ss[@]}-s1'
semicolon

# ---------- command ---------      - output -        ----- mnemonic -----
# "abcdefgh"   2 left$   type$      ab                "keep 2 left"
# "abcdefgh"  -2 left$   type$      abcdef            "keep left all but last 2"
# "abcdefgh"   2 right$  type$      gh                "keep 2 right"
# "abcdefgh"  -2 right$  type$      cdefgh            "keep right all but first 2"
# "abcdefgh"   2 split$  type$      ab cdefgh         "split at left"
# "abcdefgh"  -2 split$  type$      abcdef gh         "split at right"

primitive 'left$'  'ss[-1]=${ss[-1]:0:s[sp--]}'
primitive 'right$' 'ss[-1]=${ss[-1]:0-s[sp--]}'

# remove u1 chars from the left, return u2 chars from what remains
# ( u1 u2 -- ) ( $1 -- $2 )
colon 'mid$'
   code 'ss[-1]=${ss[-1]:s[sp-1]:s[sp--]}'
   atom 'drop'
semicolon

# ( u -- ) ( $1 -- $2 $3 )
colon 'split$'
   code 'ss+=("${ss[-1]:s[sp]}")'
   code 'ss[-2]="${ss[-2]:0:s[sp--]}"'
semicolon

colon 'join$'
   code 'ss[-2]+="${ss[-1]}"'
   code 'unset "ss[-1]"'
semicolon
inline

colon '$='
   code '[[ ${ss[-1]} != ${ss[-2]} ]]'
   push '(-$?)&maxuint'
   code 'unset "ss[-1]"'
   code 'unset "ss[-1]"'
semicolon

colon '$<'
   code '[[ ${ss[-1]} > ${ss[-2]} ]]'
   push '($?-1)&maxuint'
   code 'unset "ss[-1]"'
   code 'unset "ss[-1]"'
semicolon

colon '$>'
   code '[[ ${ss[-1]} < ${ss[-2]} ]]'
   push '($?-1)&maxuint'
   code 'unset "ss[-1]"'
   code 'unset "ss[-1]"'
semicolon

# "nice"    "this is a very *** foo"   "***" replace$    ->   "this is a very nice foo"
# "nope"    "this is a very *** foo"   "?" replace$      ->   "this is a very *** foo"
# "123"     "abcd" 1 insert$  -> "a123bcd"


declare -a stringvariables=()            # an array for strings

# push string array item u to string stack
# ( u -- ) ( -- $1 )
primitive '$@'  'ss+=("${stringvariables[s[sp--]]}")';  inline

# ( u -- )  ( $1 -- )
colon '$!'
   code 'stringvariables[s[sp--]]="${ss[-1]}"'
   code 'unset "ss[-1]"'
semicolon


# --- mixed mode operations, exchanges between stack and string stack ---
asc()  {
   if [[ -z "${ss[-1]}" ]]; then
      ((s[++sp]=0))
   else
      ((s[++sp]=${asc[${ss[-1]:0:1}]}))
      ss[-1]="${ss[-1]:1}"
   fi
}

primitive  'asc'    'asc'
primitive  'char$'  'ss+=("${char[s[sp--]]}")'


# $ -> a -- n
unpackstring()  {
   string="${ss[-1]}"
   unset "ss[-1]"
   ((tmp="${#string}", s1=s[sp]))
   for ((len=0; tmp--;)); do
      ((m[s1++]="asc[${string:len++:1}]"))
   done
   ((s[sp]="$len"))
}

primitive 'unpack$' 'unpackstring'

# ( a n -- ) ( string: -- $ )
colon 'pack$'
   atom 's1'
   atom 's2'
   code '((sp-=2))'
   code 'tmp=""'
   code 'for ((; s1--; )); do tmp+="${char[m[s2++]]}"; done'
   code 'ss+=("$tmp")'
semicolon
inout 2 0

primitive 'append$' 'ss[-1]+="${char[s[sp--]]}"'; inout 1 0          # ( c -- ) ( string: $1 -- $2 )
primitive 'prepend$' 'ss[-1]="${char[s[sp--]]}${ss[s-1]}"'           # ( c -- ) ( string: $1 -- $2 )
inout 1 0

# convert a string representation of a number
# or arithmetic expression to an integer.
# respects base
# ( -- x ) (string: $1 -- )
colon 'convert$'
   push '${m[base]}#${ss[-1]}'
   code 'unset "ss[-1]"'
semicolon
inline
inout 0 1




# ----- bit logic ---------------------------------------- #fold01

primitive 'and'     '((s[sp-1]&=s[sp--]))'
primitive 'or'      '((s[sp-1]|=s[sp--]))'
primitive 'xor'     '((s[sp-1]^=s[sp--]))'
primitive 'lshift'  '((s[sp]=(s[sp-1]<<s[sp--])&maxuint))'
primitive 'rshift'  '((s[sp-1]>>=s[sp--]))'
evaluate "' lshift alias <<"
evaluate "' rshift alias >>"
colon    'invert';  atom 'invert'; semicolon; inline

# ----- numeric comparison ------------------------------- #fold01

primitive '0='   '((s[sp]=s[sp]?0:maxuint))'                         # 0->maxuint  x->0
primitive '0<>'  '((s[sp]=s[sp]?maxuint:0))'                         # 0->0   x->maxuint
primitive '0<'   '((s[sp]=s[sp]&msb?maxuint:0))'                     # &msb: 0->0   msb->maxuint

colon '='
   code '((s1=s[sp--]))'
   code '((s[sp]=(s[sp])==(s1)?maxuint:0))'
semicolon
inline

colon '<>'
   code '((s1=s[sp--]))'
   code '((s[sp]=(s[sp])==(s1)?0:maxuint))'
semicolon
inline

colon 'u<'
   code '((s1=s[sp--]&maxuint))'
   code '((s[sp]=(s[sp]&maxuint)<(s1)?maxuint:0))'
semicolon
inline

colon 'u>'
   code '((s1=s[sp--]&maxuint))'
   code '((s[sp]=(s[sp]&maxuint)>(s1)?maxuint:0))'
semicolon
inline

colon '<'
   code '((s1=s[sp--]&maxuint))'
   code '((sign=((s1^s[sp])&msb)?1:0))'                              # set bit 0 if signs differ
   code '((s[sp]=((s1>s[sp]&maxuint)^sign)?maxuint:0))'
semicolon
inline

colon '>'
   code '((s1=s[sp--]&maxuint))'
   code '((sign=((s1^s[sp])&msb)?1:0))'                              # set bit 0 if signs differ
   code '((s[sp]=((s1<s[sp]&maxuint)^sign)?maxuint:0))'
semicolon
inline

#    flag
#   s2 < s1        sign           result
#   0 (true)       0   (same)     maxuint
#   1 (false)      0   (same)     0
#   0 (true)       msb (diff)     0
#   1 (false)      msb (diff)     maxuint

#  flag  sign      result
#  0     0         maxuint
#  1     0         0
#  0     $xxx1     0
#  1     $xxx1     maxuint

# ( x1 x2 x3 x4 -- 0 | -1 )
colon 'd='
   code '((s1=s[sp--]))'
   code '((s2=s[sp--]))'
   code '((s3=s[sp--]))'
   code '((s[sp]=(s1==s3&s2==s[sp])?maxuint:0))'
semicolon
inline
inout 4 1



# ----- arithmetics -------------------------------------- #fold01

colon '1+'
   atom '1+'
semicolon
inline
inout 1 1

colon '1-'
   atom '1-'
semicolon
inline
inout 1 1

primitive '2+'   '((s[sp]=(s[sp]+2)&maxuint))'; inout 1 1
primitive '2-'   '((s[sp]=(s[sp]-2)&maxuint))'; inout 1 1

colon '2*'
   atom '2*'
semicolon
inline
inout 1 1


primitive '+'   '((s[sp]=(s[sp-1]+s[sp--])&maxuint))'; inout 2 1
primitive '-'   '((s[sp]=(s[sp-1]-s[sp--])&maxuint))'; inout 2 1

# floored 2/
#primitive '2/'   '((s[sp]=(s[sp]>>1)|(s[sp]&msb)))'  ; inout 1 1

colon  '2/'
   atom 's1'
   code '((s[sp]=s1&msb?-((-s1&maxint)>>1)&maxuint:s1>>1))'
semicolon
inout 1 1

evaluate ': cells ;'      ; immediate  ; inout 1 1
evaluate ': cells ;'      ; interactive; inout 1 1
evaluate ': cell+ 1+ ;'   ; inline;      inout 1 1



#                     msb&    msb&
#  s3 s2 s1 -- r q  s1^s2^s3  s2^s3
# ---------------------------------
#  +  +  +     + +     0        0
#  +  +  -     + -     1        0
#  +  -  +     - -     1        1
#  +  -  -     - +     0        1
#  -  +  +     - -     1        1
#  -  +  -     - +     0        1
#  -  -  +     + +     0        0
#  -  -  -     + -     1        0
# ( s3 s2 s1  -- s3*s2%s1 s3*s2/s1 )
colon '*/mod'
   atom 's1'
   atom 's2'
   atom 's3'
   atom 'drop'
   code '((signr=(s2^s3)))'                                          # 0:+   x:-
   code '((signq=(signr^s1)))'                                       # 0:+   x:-
   code '((s1&msb&&(s1=-s1&maxuint)))'                               # abs s1
   code '((s2*=s3))'
   code '((s2&msb&&(s2=-s2&maxuint)))'
   code '((s[sp-1]=(signr&msb?(-s2%s1)&maxuint:s2%s1)))'
   code '((s[sp]=(signq&msb?-(s2/s1)&maxuint:s2/s1)))'
semicolon
inout 3 2
evaluate ': */     */mod nip ;'         ; inline; inout 3 1
evaluate ': /mod   1 -rot  */mod  ;'    ;         inout 2 2
evaluate ': *      1 */    ;'           ; inline; inout 2 1
evaluate ': /      /mod nip  ;'         ; inline; inout 2 1
evaluate ': mod    /mod drop  ;'        ; inline; inout 2 1


colon 'negate'
   atom 'negate'
semicolon
inline
inout 1 1

colon '?negate'
   code '((s[sp--]))&&'
   atom 'negate'
semicolon
inline
inout 2 1

colon 'abs'
   code '((s[sp]&msb))&&'
   atom 'negate'
semicolon
inline
inout 1 1

# needs testing
colon 'u/mod'		# u1 u2 -- rem quot
   code '((s1=s[sp]&maxuint, s2=s[sp-1]&maxuint, s[sp]=s2/s1, s[sp-1]=s2%s1))'
semicolon
inline
inout 2 2


# ----- memory ------------------------------------------- #fold01

colon '@'
   atom '@'
semicolon
inline
inout 1 1

colon '!'
   code '((m[s[sp--]]=s[sp-1]))'
   atom 'drop'
semicolon
inline
inout 2 0

primitive 'c@'  '((s[sp]=m[s[sp]]&255))'; inout 1 1

colon 'c!'
   code '((m[s[sp--]]=s[sp-1]&255))'
   atom 'drop'
semicolon
inline
inout 2 0


# ( a -- [a+cell] [a] )
colon '2@'
   atom 's1'
   code '((s[sp++]=m[s1+1]))'
   code '((s[sp]=m[s1]))'
semicolon
inline
inout 1 2


# ( [a+cell] [a] a -- )
colon '2!'
   code 's1=s[sp--]'
   code '((m[s1++]=s[sp--]))'
   code '((m[s1]=s[sp--]))'
semicolon
inline
inout 3 0


primitive 'skim'    '((s[++sp]=m[s[sp]++]))'; inout 1 2
primitive 'count'   '((s[++sp]=m[s[sp]++]&255))'; inout 1 2

colon '<-'                                                           # ( a x -- )   swap !
   code '((m[s[sp]]="s[sp--]"))'
   atom 'drop'
semicolon
inout 2 0

colon '+!'
   code '((m[s[sp--]]=(s[sp-1]+m[s[sp]])&maxuint))'
   atom 'drop'
semicolon
inline
inout 2 0

primitive 'on'   '((m[s[sp--]]=maxuint))';               inout 1 0
primitive 'off'  '((m[s[sp--]]=0))';                     inout 1 0
primitive 'inc'  '((m[s[sp--]]=(m[s[sp]]+1)&maxuint))';  inout 1 0
primitive 'dec'  '((m[s[sp--]]=(m[s[sp]]-1)&maxuint))';  inout 1 0

# ( x1 a -- x2 )
colon 'exchange'
   code '((tmp=m[s[sp]]))'
   code '((m[s[sp]]=s[sp-1]))'
   code '((s[--sp]=tmp))'
semicolon
inout 2 1

colon 'here'
   atom 'here'
semicolon
inline
inout 0 1

colon 'allot'
   atom 'allot'
semicolon
inline
inout 1 0

primitive ',' '((m[dp++]=s[sp--]))';  inout 1 0
primitive 'pad' '((s[++sp]=dp+256))'; inout 0 1                      # pad is 256 cells above here.

# c -> m[a++],  u times
# ( a u c -- )
colon 'fill'
   code '((s1=s[sp--], s2=s[sp--], s3=s[sp--]))'
   code 'for ((;s2--;)); do ((m[s3++] = s1)); done'                  # c -> m[a++],  u times
semicolon
inout 3 0

# ( a u -- )
evaluate ': erase   0 fill ;'    ; inline; inout 2 0                 # 0 -> m[a++],  u times

# ( a1 a2 u -- )
move()  {                                                            # deals with destination overlapping source
   ((s1=s[sp--], s2=s[sp--], s3=s[sp--]))
   if ((s3 < s2)); then                                              # copy highest to lowest:
      ((s2+=s1, s3+=s1))                                             # m[--a1+u} -> m[--a2+u],  u times
      for ((;s1--;)); do
         ((m[--s2] = m[--s3]))
      done
   else                                                              # copy lowest tio highest
      for ((;s1--;)); do                                             # m[a1++} -> m[a2++],  u times
         ((m[s2++] = m[s3++]))
      done
   fi
}

# ( a1 a2 u -- )
primitive 'move'   'move'; inout 3 0

# ----- flow control ------------------------------------- #fold01

remagic

colon 'if'
   code 'code "if ((s[sp--])); then"'
   push "\${#body[@]}"                                               # allow check of empty function
   push "$magic"                                                     # allow check of structure and empty function
semicolon
immediate

colon 'else'
   code "(( s[sp]++ == \"$magic\" )) || { unstructured 'if'; return; }"
   code '(( s[sp-1] == ${#body[@]} )) && code ":"'
   code 'code "else"'
   code '((s[sp-1]=${#body[@]}))'
semicolon
immediate

colon 'then'
   code "(( s[sp] == $magic ||  s[sp] == $((magic+1)) )) || { unstructured 'if or else'; return; }"
   atom 'drop'
   code '(( s[sp--] == ${#body[@]} )) && code ":"'
   code 'code "fi"'
semicolon
immediate


remagic

colon 'begin'
   code 'code "while :; do"'
   push "\${#body[@]}"                                               # allow check of empty function
   push "$magic"                                                     # allow check of structure and empty function
semicolon
immediate


colon 'again'
   code "(( s[sp--] == \"$magic\" )) || { unstructured 'begin'; return; }"
   code '(( s[sp--] == ${#body[@]} )) && code ":"'
   code 'code "done"'
semicolon
immediate

colon 'until'
   code "(( s[sp--] == \"$magic\" )) || { unstructured 'begin'; return; }"
   code 'code "((s[sp--]))&&break"'
   atom 'drop'
   code 'code "done"'
semicolon
immediate

colon 'while'
   code "(( s[sp]++ == $magic )) || { unstructured 'begin'; return; }"
   code 'code "((s[sp--]))||break"'
semicolon
immediate

colon 'repeat'
   code "(( s[sp--] == $((magic+1)) )) || { unstructured 'while'; return; }"
   atom 'drop'
   code 'code "done"'
semicolon
immediate


remagic
colon 'for'
   code 'code "((r[++rp]=i))"'
   code 'code "((i=s[sp--]))"'
   code 'code "for ((; i--; )); do"'
   push "\${#body[@]}"                                               # allow check of empty function
   push "$magic"                                                     # allow check of structure and empty function
semicolon
immediate

primitive 'i' '((s[++sp]=i))'; inout 0 1
evaluate ': j r@ ;'   ;  inout 0 1

colon 'next'
   code "((s[sp--] == $magic))|| { unstructured 'for'; return; }"
   code '((s[sp--] == ${#body[@]})) && code ":"'
   code 'code "done"'
   code "code '((i=r[rp--]))'"
semicolon
immediate


remagic

dodo()  {
   ((r[++rp]=ibar))
   ((r[++rp]=i))
   ((i=s[sp--]))
   ((ibar=s[sp--]))
}

colon 'do'
   code 'code "dodo"'
   code 'code "while :;do"'
   push "$magic"                                                     # allow check of structure and empty function
semicolon
immediate

colon '?do'
   code 'code "dodo"'
   code 'code "while :;do"'
   code 'code "((i==ibar))&&break"'
   push "$magic"                                                     # allow check of structure and empty function
semicolon
immediate

colon 'loop'
   code "((s[sp--] == $magic))|| { unstructured 'do'; return; }"
   code 'code "((i=(i+1)&maxuint))"'
   code 'code "((i == ibar))&&break"'
   code 'code "done"'
   code "code '((i=r[rp--]))'"
   code "code '((ibar=r[rp--]))'"
semicolon
immediate

colon '+loop'
   code "((s[sp--] == $magic))|| { unstructured 'do'; return; }"
   code 'code "((s1=s[sp--]))"'
   code 'code "((i+=s1))"'
   code 'code "((((ibar-(s1<msb)-i)^s1)&msb))&&break"'
   code 'code "done"'
   code "code '((i=r[rp--]))'"
   code "code '((ibar=r[rp--]))'"
semicolon
immediate

primitive 'leave'  'code "break"'; immediate                         # break out of loop
primitive '?leave' 'code "((s[sp--]))&&break"'; immediate            # break out of loop when false
primitive 'lest'   'code "((s[sp--]))||return"'; immediate           # interpreting version: skip rest of line when false
primitive 'lest'   '((s[sp--]))||line=""'; interactive               # compiling version: skip until end of word (i.e. return) when true
primitive 'unless' 'code "((s[sp--]))&&return" '; immediate          # interpreting version: skip rest of line when true
primitive 'unless' '((s[sp--]))&&line=""'; interactive               # compiling version: skip rest of word when false

# interpreting version: u times repeat evaluation of input line remainder
colon 'times'
   code '((r[++rp]=i))'
   code '((i=s[sp--]))'
   code 'while ((i--)); do evaluate "$line"; done'
   code '((i=r[rp--]))'
   atom 'rdrop'
   code 'line=""'
semicolon
interactive

# this is the prefered version, repeating the line upon encountering many
# prefered because its use is more symmetrical with times, both specified
# before the repeated sequence.  times is harder to put at the end.
colon 'many'
   code 'until read -rsn1 -t 0.01; do evaluate "$line"; done'
   code 'line=""'
semicolon

colon 'boot'
   code 'word'
   code 'satisfy1 "$word"'
   code 'coldvector="${headersstateless["$word"]}"'                  # because writing it to cold start vector
semicolon                                                            # this way cold start entry points can be forward referenced

primitive 'warm'  'warm'
primitive 'bye'  'exit 0'
primitive 'exit'  'return'; immediate
primitive 'abort'  'abort "${s[sp--]}"'                              # ( err -- )

# ( f err -- )
colon '?abort'
   code '((s[sp-1]))&&abort "${s[sp]}"'
   atom 'drop'
   atom 'drop'
semicolon


# ----- conditional compilation--------------------------- #fold01

# need can create forward ref even though forward refs are turned off.
# resolving will still be done, that way can specific words (and their
# dependencies) be picked from forward lib.
# arg1: name of needed word,  arg2; referer
need()  {                                                            # only ask for forward if word isn't in any context voc
   [[ -z "${headersstateless[$1]}" ]] || return
   [[ -z "${headersinterpretonly[$1]}" ]] || return
   [[ -z "${headerscompileonly[$1]}" ]] || return
   forwardref "$1"  "$2"                                             # forwardref protects itself against already forwardref'd words
}

colon 'need'
   code 'word'
   code 'need "$word" ""'                                            # empty arg indicates explicit need, no referer
semicolon

# ( -- f )     check unresolved status of word
colon 'needed'
   code 'word'
   code '[[ "${headersunresolved["$word"]}" ]]'
   push '${?}?0:maxuint'
semicolon

primitive 'have'   'have'
evaluate ': lack  have 0= ;'
# ----- i/o ---------------------------------------------- #fold01

# fade out in favour of lib/tput
colon 'esc['
   code 'printf "\e[%s" "${ss[-1]}"'
   code 'unset "ss[-1]"'
semicolon
inline
inout 1 0

primitive 'ansi' 'printf "\e[%bm" "${s[sp--]}"'; inout 1 0

# given an ASCII, print the character
primitive 'emit'  'printf "%c" "${char[s[sp--]&255]}"'; inout 1 0
evaluate ': type  pack$ type$ ;'  ; inline;  inout 2 0

# parse input for string delimited by string on string stack
# may be removed, and next word "parse" inheriting its name,
# following a suggestion of ruv
#colon 'parse$'
#   code 'parse "${ss[-1]}"'
#   code 'ss[-1]="$word"'
#semicolon

# parse input for string delimited by character specified by ASCII value on stack
colon 'parse$'
   code 'parse "${char[s[sp--]]}"'
   code 'ss+=("$word")'
semicolon

evaluate ': word$  bl parse$ ;  inline'

# duplicating 'char functionality because quoting in evaluate
# becomes sometimes hard when using ' ' for characters' ASCIIs
colon '[char]'
   code 'word'
   code 'push "${asc[${word:0:1}]}"'
semicolon
immediate


keybuf=""
colon 'key'
   code 'if [[ -z "$keybuf" ]]; then'                                # key? may have put chars into keybuf
   code 'IFS="" read -rsn1 tmp'                                      # keybuf empty: read from console
   code 'keybuf+="${tmp}"'                                           # consider space if -z $tmp
   code 'fi'
   code 'tmp="${keybuf:0:1}"'                                        # read key from keybuf
   code 'tmp=$(printf "%d" '"\"'""\${tmp}\")"                        # treat ctrls as spaces, convert to ASCII
   push 'tmp'                                                        # push ASCII
   code 'keybuf="${keybuf:1}"'                                       # strip key from keybuf
semicolon
inout 0 1

colon 'key?'
   code '[[ -z "$keybuf" ]] || { s+=("$maxuint"); return; }'         # key in keybuf: yes, flag "key ready"
   code 'IFS=""'                                                     # no key in keybuf: poll console
   code 'if read -rsn1 -t0.01 tmp; then'
   code 'keybuf+="$tmp"'                                             # add key to buffer. maybe add space if -z $tmp
   push 'maxuint'
   code 'return'
   code 'fi'
   push '0'
semicolon
inout 0 1

# read line into tib
# TODO: configurable ANSI sequences
query()  {
   printf '\e[%dm' "$greenfg"
   ss+=("")
   IFS="" read -er -i "$keybuf" "ss[-1]"                             # key? may have put chars into keybuf

   keybuf=""
   printf '\e[%dm' "$normal"
}

colon 'evaluate$'
   code 'local tib="${ss[-1]}"'
   code 'unset "ss[-1]"'
   code 'evaluate "$tib"'
semicolon
inline

colon 'spaces'
   code '((s1=s[sp--]))'
   code '((s1&msb))||printf "%${s1}s" ""'
semicolon
inout 1 0

evaluate ': ltype$ dup$ type$ count$ - spaces ;'; inout 1 0          # ( u -- ) (string: $1 -- )
evaluate ': rtype$ dup$ count$ - spaces type$ ;'; inout 1 0          # ( u -- ) (string: $1 -- )
primitive 'query$'    'query';           inout 0 0
primitive 'cr'        'printf "\n"';     inout 0 0
primitive 'space'     'printf " "';      inout 0 0

prompt()  {
   ((error)) && {
      warm
      return 1
   }

   ((compiling)) && {
      printf "|%-4s" ""                                              # just a vertical bar, then indenting, while compiling
      return 0
   }
   printf " %s" "ok"                                                 # ok prompt
   ((${#s[@]})) &&  {                                                # stack depth > 0?
      tmp=".........>"                                               # yes: print a dot for each item
      printf " %s" "${tmp:0:$sp}"                                    # but not more than in $tmp
   }
   ((${#headersunresolved[@]})) &&  {                                # unresolved words > 0?
      printf " (%d)" "${#headersunresolved[@]}"                      # yes: show count
   }
   printf "\n"                                                       # finalize with linefeed
}

primitive 'prompt' 'prompt'

# load file whose name is given on string stack
# ( -- ) ( string: $1 -- )
colon 'from$'
   code 'file="${ss[-1]}"'
   code 'unset "ss[-1]"'
   code 'from "$file"||filenotfound "$file"'
semicolon

# load file whose name is parsed from input
# ( -- ) ( input: parse word )
evaluate ': from word$ from$ ;'
primitive '#files' '((s[++sp]=${#files[@]}))'; inout 0 1
primitive 'files'  'printf "%s\n" "${files[@]}"|nl -v 0'; inout 0 0  # show list of already included files

# ----- pictured number conversion ----------

# ( x1 -- x2 ) ( string: $1 -- $2 )
colon '#'                                                            # : #
   code '((radix=m[base]))'                                          # base @
   code '((s1=s[sp]&maxuint, s[sp]=s1/radix, tmp=s1%radix+48))'      # /mod swap '0 +
   code '((tmp>57))&&((tmp+=39))'                                    # dup '9 > 39 and +
   code 'ss[-1]="${char[tmp]}${ss[-1]}"'                             # hold
semicolon                                                            # ;
inout 1 1

evaluate "' prepend$ alias hold"             ; inline; inout 1 0     # ( c -- ) ( string: $1 -- $2 )
evaluate ': <#       ""  ;'                  ; inline; inout 0 0     # ( -- ) ( string: -- $2 )
evaluate ': #s       begin # dup 0= until ;' ; inout 1 1             # ( x1 -- x2 ) ( string: $1 -- $2 )
evaluate ": sign     0< lest '-' hold ;"     ; inout 1 0             # ( f -- ) ( string: $1 -- $2 )
evaluate "' drop alias #>$"                  ; inline; inout 1 0     # ( x -- )
evaluate ': #>type   #>$ type$ ;'            ; inline; inout 1 0     # ( x -- ) ( string:  $1 -- )
evaluate ': #>       #>$ here here unpack$ ;'; inout 1 2             # ( x -- a n ) ( string:  $1 -- )
evaluate ': uconvert <# #s #>$ ;'            ; inout 1 0             # ( u -- ) (string: -- $1 )
evaluate ': convert  dup abs uconvert sign ;'; inout 1 0             # ( u -- ) (string: -- $1 )
evaluate ': .         convert type$ space ;' ; inout 1 0             # ( n -- )
evaluate ': u.       uconvert type$ space ;' ; inout 1 0             # ( u -- )
evaluate ': .r       >r  convert r> rtype$ ;'; inout 2 0             # ( n u -- )
evaluate ': u.r      >r uconvert r> rtype$ ;'; inout 2 0             # ( u1 u2 -- )

primitive 'decimal'  "m[$base]=10"; inout 0 0
primitive 'hex'      "m[$base]=16"; inout 0 0
primitive 'binary'   "m[$base]=2";  inout 0 0



# ----- documentation ------------------------------------ #fold01


undoc_template()  {
cat << EOF
created:             auto     (remove line after having checked and revised description)
name:                $1
stack:               ( -- )
return stack:        ( -- )
string stack:        ( -- )
category:
input stream:
decription:          none
contexts:            interpreting, compiling
example:             none
notes:               none
EOF
}

undoc()  {
   for word in "${!headers[@]}"; do                                  # run through all headers
      name="$worddoc:${word/\//U+0002F;}"
      [[ -f "$name" ]] || {                                          # found one for which no doc file exists
         undoc_template "$word" >"$name"
         editor "$name"
         break
      }
   done
}
primitive 'undoc' 'undoc'

# candidates for $command further down
doc()       { editor "$worddoc:${1/\//U+0002F;}"; }
about()     { cat    "$worddoc:${1/\//U+0002F;}"; }

colon 'doc'
   code 'word'
   code 'doc "$word"'
semicolon

colon 'about'
   code 'word'
   code 'about "$word"'
semicolon


# ----- interactive mode -------------------------------- #fold01

evaluate ': quit warm begin query$ evaluate$ prompt again ;'

# ----- convenience -------------------------------------- #fold01
# TODO: optimiser: invalidate all stack register contents
# execute shell command "$2" with args "$1"
colon 'command$'
   code '${ss[-2]} "${ss[-1]}"'
   code 'unset "ss[-1]"'
   code 'unset "ss[-1]"'
semicolon
primitive empty  's=() sp=0'

# empty stack and string stack
# since warm doesn't empty them any longer, a convenient
# way to do so manually was needed.
evaluate ': _  empty empty$  ;'; inline
primitive 'words' 'words'
primitive 'random' '((s[++sp]=RANDOM&maxuint))'; inout 0 1           # ( -- u )        15 bits random number
primitive 'realtime' '((s[++sp]=${EPOCHREALTIME//,/}&maxuint))';     # a microseconds epoch, used for benchmarking
primitive 'secs' 'sleep "${s[sp--]}"'

colon 'filename$'
   code 'ss+=("${files[s[sp--]]}")'                                  # ( u -- ) ( string: -- $1 ) push name of file u (from output of files) to string stack
semicolon

evaluate ': edit  "editor" filename$  command$ ;'
evaluate ': list  "cat"    filename$  command$ ;'

# x1 x2 -- x1+x2 x1
# : bounds   over + swap ;
colon 'bounds'
   atom 's1'
   atom 's2'
   code '((s[sp-1]=(s1+s2)&maxuint))'
   code '((s[sp]=s2))'
semicolon
inline
inout 2 2

# return handle of source. 0=console, >0 correspond files number
# allows words to check whether they're executed while loaded
# from file or console.
# ( -- u )
colon 'source'
   push '${filehandle:-"0"}'
semicolon
inline
inout 0 1

# check whether current source was had already been compiled before.
# most useful when used interpretatively in a file, for testing whether
# it will be or has been reloaded, such as with "loaded lest done"
# ( -- f )
colon 'loaded'
   push 'loaded[filehandle]'
semicolon

# stop loading file
colon 'done'
   code 'line=""'                                                    # nothing more to process on current line
   code 'linenr="-1"'                                                # signal "all done" to from
semicolon

# produce name of currently loaded file
# ( string: -- $1 )
evaluate ': thisfile$  source filename$ ;'

colon 'where$'
    code 'tmp="${ss[-1]}"'                                           # name of word to look up
    code 'unset "ss[-1]"'
    code '[[ -z $tmp ]]&&emptyname'                                  # no name given
    code '((${wherefile[$tmp]}))||nosource "$tmp"'                   # file handle empty or 0: no source available
    push '${wherefile[$tmp]}'
    push '${whereline[$tmp]}'
semicolon

evaluate ': where word$ where$ swap filename$ type$ [char] : emit u. ;'

colon 'version'
   push '$version'
   push '$subversion'
   push '$subsubversion'
semicolon

primitive 'version$'  'ss+=("$version.$subversion.$subsubversion")'

# ----- experimental ------------------------------------- #fold01


# leftovers from running quit as coproc, exiting by error and
# therefore having a word - the word calling quit - as outermost
# error handler. While this works, it suffers from that along
# with the quit session (which gets terminated) also all compiled
# words go bust. That behavior is a tad harsh for dealing with
# errors which may simply be a typo. But keeping them in, who knows
# what else they may come in handy with.
# similar to execute, but seperate process
colon 'coproc'
   atom 's1'
   atom 'drop'
   code "coproc ${header_code}_\${s1} < /dev/tty > /dev/tty"
   code 'echo "coproc return value=$?"'
   code 'echo "coproc fd=${COPROC[@]}"'
semicolon

colon 'wait'
   code 'echo "wait fd=${COPROC[@]}"'
   code 'echo "wait pid=$COPROC_PID"'
   code 'wait -n -p pid $COPROC_PID'
   code 'ret="$?"'
   code '((ret==255))&&exit 255'
   code 'echo "wait return value=$ret"'
   code 'echo "wait pid=$pid"'
semicolon



# complementing existing forward referencing scheme, which could now
# possibly lose a few support words, from dependency files, which
# map word names to file names.
# This allows quickly locating source of required code, and consequently
# including it.

# experimental early support here consists of 3 words:
#  provides:
#     like \ treating rest of line as comment.
#     purpose is to allow grepping libraries for file names
#     providing the words listed there, to generate a simple
#     form of dependency files.
#     Insert it into library files, listing the words which can
#     be resolved by library. Idea is to have very short library
#     files, often just containing a single word.
#
#  dependencies
#     run through library directories and their subdirectories, and
#     look for lines starting with provides:
#     extract the list of names, and write names, one per line, followed
#     by file name, into the "dependencies" file.
#     This build the dependencies "database", and needs only done when
#     dependencies are outdated, stale or missing.
#
#  satisfy
#  needs:
#     turns forward refs on, parses space delimited strings from input
#     line (the name of needed words). For each word is the library
#     file containing word's source located by searching the dependencies
#     file, the source is included from file, thereby satisfying the
#     forward reference. When done is old forward refs state restored.
#
#  Purpose is to allow library inclusion with much finer granulation than
#  what is possible with including library files which unconditionally
#  include heaps of words, without the need to restructure the libraries
#  towards conditional compilation.
#
#  How useful this scheme is will still have to be determined, that's why
#  it is likely to remain in "experimental" for a while.


dependencies()  {                                                    # library inclusion dependency file builder
   grep -r "^provides:" "${libdirs[0]}" |
   while read -r file words; do
      file="${file%:provides:}"
# "Double quote to prevent globbing and word splitting."
# I actually *want* word splitting here, for fprint to produce one line per word
# shellcheck disable=SC2086
      printf "%-31s $file\n" $words
   done > "$dependencies"
}

# try to resolve all words given on input line.
satisfy()  {
   until [[ -z "$line" ]]; do
      word
      satisfy1 "$word"
   done
}

primitive 'dependencies' 'dependencies'
primitive "provides:"   'line=""'        ;   interactive             # double quoted escaped backslash rather than
primitive 'needs:' 'satisfy'                                         # more symmetric with "provided:"
primitive 'satisfy' 'satisfy'                                        # nice for interactive use


# ----- evaluate command line----------------------------- #fold00



# shellcheck source=./yoda.conf                                      # try to load custom configuration
[[ -f "$mydir/$config" ]] && source "$mydir/$config"                 # currently only looking in dir where yoda resides
args=("$@")
files[1]="$(realpath "$0")"
((${#args[@]})) || args[0]="$default"
evaluate "${args[*]}"
if [[ -n "$coldvector" ]]; then                                      # if cold launch point was specified, try to run.
   resolve                                                           # still unresolved words? try to resolve those.
   if (( ${#headersunresolved[@]} )); then
      printf "%s\n" "unresolved forward references:"                 # still unresolved words
      printf "%s\n" "${!headersunresolved[@]}"
      printf "%s\n" "Run this not I will."
   else
      cold
   fi
fi
